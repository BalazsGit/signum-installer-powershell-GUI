# Change directory to the script's location
Set-Location $PSScriptRoot
$host.UI.RawUI.WindowTitle = "Signum Installer"

$WEB_GUI_PORT = 8089  # Web UI port
$CONFIG_FILE_NAME = "config.json"

### Global variables ###
$UserResponse = $null

$DATABASE_NAME = $null
$DATABASE_USERNAME = $null
$DATABASE_PASSWORD = $null

$DOWNLOADS_DIR_NAME = "Downloads"

$SLEEP_SECONDS = 20

### PowerShell variables ###
$POWERSHELL_VERSION = "7.5.0"
$POWERSHELL_DIR_NAME = "PowerShell"
$POWERSHELL_EXEC_NAME = "pwsh.exe"
$POWERSHELL_UNZIP_NAME = "PowerShell-${POWERSHELL_VERSION}-win-x64"
$POWERSHELL_ZIP_NAME = "${POWERSHELL_UNZIP_NAME}.zip"
$POWERSHELL_UNZIP_PATH = "${POWERSHELL_DIR_NAME}\${POWERSHELL_UNZIP_NAME}"
$POWERSHELL_ZIP_PATH = "${POWERSHELL_DIR_NAME}\${POWERSHELL_ZIP_NAME}"
$POWERSHELL_EXEC_PATH = "${POWERSHELL_UNZIP_PATH}\${POWERSHELL_EXEC_NAME}"
$POWERSHELL_URL = "https://github.com/PowerShell/PowerShell/releases/download/v${POWERSHELL_VERSION}/PowerShell-${POWERSHELL_VERSION}-win-x64.zip"

### Signum Directory variables ###
$SIGNUM_MAINNET_DIR_NAME = "Mainnet"
$SIGNUM_TESTNET_DIR_NAME = "Testnet"

### Signum Node variables ###
$SIGNUM_NODE_DIR_NAME = "Node"

$SIGNUM_NODE_STARTER_PS1_NAME = "start-node.ps1"
$SIGNUM_NODE_STARTER_EXEC_NAME = "start-node.bat"

### Signum Node Mainnet variables ###
$SIGNUM_NODE_MAINNET_VERSION = "v3.8.4"
$SIGNUM_NODE_MAINNET_DIR_PATH = "${SIGNUM_MAINNET_DIR_NAME}\${SIGNUM_NODE_DIR_NAME}"
$SIGNUM_NODE_MAINNET_ZIP_NAME = "signum-node-${SIGNUM_NODE_MAINNET_VERSION}-win_x64.zip"
$SIGNUM_NODE_MAINNET_UNZIP_NAME = "signum-node-${SIGNUM_NODE_MAINNET_VERSION}-win_x64"
$SIGNUM_NODE_MAINNET_UNZIP_PATH = "${SIGNUM_NODE_MAINNET_DIR_PATH}\${SIGNUM_NODE_MAINNET_UNZIP_NAME}"
$SIGNUM_NODE_MAINNET_STARTER_PS1_PATH = "$SIGNUM_NODE_MAINNET_UNZIP_PATH\${SIGNUM_NODE_STARTER_PS1_NAME}"
$SIGNUM_NODE_MAINNET_STARTER_EXEC_PATH = "$SIGNUM_NODE_MAINNET_UNZIP_PATH\${SIGNUM_NODE_STARTER_EXEC_NAME}"
$SIGNUM_NODE_MAINNET_DEFAULT_PROPERTIES_PATH = "$SIGNUM_NODE_MAINNET_UNZIP_PATH\conf\node-default.properties"
$SIGNUM_NODE_MAINNET_PROPERTIES_PATH = "$SIGNUM_NODE_MAINNET_UNZIP_PATH\conf\node.properties"
$SIGNUM_NODE_MAINNET_URL = "https://github.com/signum-network/signum-node/releases/download/${SIGNUM_NODE_MAINNET_VERSION}/${SIGNUM_NODE_MAINNET_ZIP_NAME}"
$SIGNUM_NODE_MAINNET_P2P_PORT = 8123
$SIGNUM_NODE_MAINNET_API_PORT = 8125
$SIGNUM_NODE_MAINNET_API_WEBSOCKET_PORT = 8126

### Signum Node Testnet variables ###
$SIGNUM_NODE_TESTNET_VERSION = "v3.8.4"
$SIGNUM_NODE_TESTNET_DIR_PATH = "${SIGNUM_TESTNET_DIR_NAME}\${SIGNUM_NODE_DIR_NAME}"
$SIGNUM_NODE_TESTNET_ZIP_NAME = "signum-node-${SIGNUM_NODE_TESTNET_VERSION}-win_x64.zip"
$SIGNUM_NODE_TESTNET_UNZIP_NAME = "signum-node-${SIGNUM_NODE_TESTNET_VERSION}-win_x64"
$SIGNUM_NODE_TESTNET_UNZIP_PATH = "${SIGNUM_NODE_TESTNET_DIR_PATH}\${SIGNUM_NODE_TESTNET_UNZIP_NAME}"
$SIGNUM_NODE_TESTNET_STARTER_PS1_PATH = "$SIGNUM_NODE_TESTNET_UNZIP_PATH\${SIGNUM_NODE_STARTER_PS1_NAME}"
$SIGNUM_NODE_TESTNET_STARTER_EXEC_PATH = "$SIGNUM_NODE_TESTNET_UNZIP_PATH\${SIGNUM_NODE_STARTER_EXEC_NAME}"
$SIGNUM_NODE_TESTNET_DEFAULT_PROPERTIES_PATH = "$SIGNUM_NODE_TESTNET_UNZIP_PATH\conf\node-default.properties"
$SIGNUM_NODE_TESTNET_PROPERTIES_PATH = "$SIGNUM_NODE_TESTNET_UNZIP_PATH\conf\node.properties"
$SIGNUM_NODE_TESTNET_URL = "https://github.com/signum-network/signum-node/releases/download/${SIGNUM_NODE_TESTNET_VERSION}/${SIGNUM_NODE_TESTNET_ZIP_NAME}"
$SIGNUM_NODE_TESTNET_P2P_PORT = # TODO TBD
$SIGNUM_NODE_TESTNET_API_PORT = 6876
$SIGNUM_NODE_TESTNET_API_WEBSOCKET_PORT = # TODO TBD

### Signum NeoClassic variables ###
$SIGNUM_WALLET_NEOCLASSIC_ZIP_NAME = "neoclassic.zip"
$SIGNUM_WALLET_NEOCLASSIC_DIR_NAME = "neoclassic"

### Signum NeoClassic Mainnet variables ###
$SIGNUM_WALLET_MAINNET_NEOCLASSIC_VERSION = "1.0.0"
$SIGNUM_WALLET_MAINNET_UI_DIR_PATH = "${SIGNUM_NODE_MAINNET_UNZIP_PATH}\html\ui"
$SIGNUM_WALLET_MAINNET_NEOCLASSIC_ZIP_PATH = "${SIGNUM_WALLET_MAINNET_UI_DIR_PATH}\${SIGNUM_WALLET_NEOCLASSIC_ZIP_NAME}"
$SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH = "${SIGNUM_WALLET_MAINNET_UI_DIR_PATH}\${SIGNUM_WALLET_NEOCLASSIC_DIR_NAME}"
$SIGNUM_WALLET_MAINNET_NEOCLASSIC_URL = "https://github.com/deleterium/neoclassic-wallet/releases/download/v${SIGNUM_WALLET_MAINNET_NEOCLASSIC_VERSION}/neoclassic-wallet-${SIGNUM_WALLET_MAINNET_NEOCLASSIC_VERSION}.zip"

### Signum NeoClassic Testnet variables ###
$SIGNUM_WALLET_TESTNET_NEOCLASSIC_VERSION = "1.0.0"
$SIGNUM_WALLET_TESTNET_UI_DIR_PATH = "${SIGNUM_NODE_TESTNET_UNZIP_PATH}\html\ui"
$SIGNUM_WALLET_TESTNET_NEOCLASSIC_ZIP_PATH = "${SIGNUM_WALLET_TESTNET_UI_DIR_PATH}\${SIGNUM_WALLET_NEOCLASSIC_ZIP_NAME}"
$SIGNUM_WALLET_TESTNET_NEOCLASSIC_UNZIP_PATH = "${SIGNUM_WALLET_TESTNET_UI_DIR_PATH}\${SIGNUM_WALLET_NEOCLASSIC_DIR_NAME}"
$SIGNUM_WALLET_TESTNET_NEOCLASSIC_URL = "https://github.com/deleterium/neoclassic-wallet/releases/download/v${SIGNUM_WALLET_MAINNET_NEOCLASSIC_VERSION}/neoclassic-wallet-${SIGNUM_WALLET_TESTNET_NEOCLASSIC_VERSION}.zip"

### Signum Pool variables ###
$SIGNUM_POOL_DIR_NAME = "Pool"
$SIGNUM_POOL_STARTER_PS1_NAME = "start-pool.ps1"
$SIGNUM_POOL_STARTER_EXEC_NAME = "start-pool.bat"
$SIGNUM_POOL_PROPERTIES_NAME = "pool.properties"
$SIGNUM_POOL_PROPERTIES_ORIGINAL_NAME = "pool-original.properties"

### Signum Pool Mainnet variables ###
$SIGNUM_POOL_MAINNET_VERSION = "v2.2.1"
$SIGNUM_POOL_MAINNET_DIR_PATH = "${SIGNUM_MAINNET_DIR_NAME}\${SIGNUM_POOL_DIR_NAME}"
$SIGNUM_POOL_MAINNET_UNZIP_NAME = "signum-pool-${SIGNUM_POOL_MAINNET_VERSION}"
$SIGNUM_POOL_MAINNET_ZIP_NAME = "${SIGNUM_POOL_MAINNET_UNZIP_NAME}.zip"
$SIGNUM_POOL_MAINNET_ZIP_PATH = "${SIGNUM_POOL_MAINNET_DIR_PATH}\${SIGNUM_POOL_MAINNET_ZIP_NAME}"
$SIGNUM_POOL_MAINNET_UNZIP_PATH = "${SIGNUM_POOL_MAINNET_DIR_PATH}\${SIGNUM_POOL_MAINNET_UNZIP_NAME}"
$SIGNUM_POOL_MAINNET_PROPERTIES_PATH = "$SIGNUM_POOL_MAINNET_UNZIP_PATH\$SIGNUM_POOL_PROPERTIES_NAME"
$SIGNUM_POOL_MAINNET_PROPERTIES_ORIGINAL_PATH = "$SIGNUM_POOL_MAINNET_UNZIP_PATH\$SIGNUM_POOL_PROPERTIES_ORIGINAL_NAME"
$SIGNUM_POOL_MAINNET_STARTER_PS1_PATH = "$SIGNUM_POOL_MAINNET_UNZIP_PATH\${SIGNUM_POOL_STARTER_PS1_NAME}"
$SIGNUM_POOL_MAINNET_STARTER_EXEC_PATH = "$SIGNUM_POOL_MAINNET_UNZIP_PATH\${SIGNUM_POOL_STARTER_EXEC_NAME}"
$SIGNUM_POOL_MAINNET_URL = "https://github.com/signum-network/signum-pool/releases/download/${SIGNUM_POOL_MAINNET_VERSION}/${SIGNUM_POOL_MAINNET_ZIP_NAME}"
$SIGNUM_POOL_MAINET_PORT = 8000

### Signum Pool Testnet variables ###
$SIGNUM_POOL_TESTNET_VERSION = "v2.2.1"
$SIGNUM_POOL_TESTNET_DIR_PATH = "${SIGNUM_TESTNET_DIR_NAME}\${SIGNUM_POOL_DIR_NAME}"
$SIGNUM_POOL_TESTNET_UNZIP_NAME = "signum-pool-${SIGNUM_POOL_TESTNET_VERSION}"
$SIGNUM_POOL_TESTNET_ZIP_NAME = "${SIGNUM_POOL_TESTNET_UNZIP_NAME}.zip"
$SIGNUM_POOL_TESTNET_ZIP_PATH = "${SIGNUM_POOL_TESTNET_DIR_PATH}\${SIGNUM_POOL_TESTNET_ZIP_NAME}"
$SIGNUM_POOL_TESTNET_UNZIP_PATH = "${SIGNUM_POOL_TESTNET_DIR_PATH}\${SIGNUM_POOL_TESTNET_UNZIP_NAME}"
$SIGNUM_POOL_TESTNET_PROPERTIES_PATH = "$SIGNUM_POOL_TESTNET_UNZIP_PATH\$SIGNUM_POOL_PROPERTIES_NAME"
$SIGNUM_POOL_TESTNET_PROPERTIES_ORIGINAL_PATH = "$SIGNUM_POOL_TESTNET_UNZIP_PATH\$SIGNUM_POOL_PROPERTIES_ORIGINAL_NAME"
$SIGNUM_POOL_TESTNET_STARTER_PS1_PATH = "$SIGNUM_POOL_TESTNET_UNZIP_PATH\${SIGNUM_POOL_STARTER_PS1_NAME}"
$SIGNUM_POOL_TESTNET_STARTER_EXEC_PATH = "$SIGNUM_POOL_TESTNET_UNZIP_PATH\${SIGNUM_POOL_STARTER_EXEC_NAME}"
$SIGNUM_POOL_TESTNET_URL = "https://github.com/signum-network/signum-pool/releases/download/${SIGNUM_POOL_TESTNET_VERSION}/${SIGNUM_POOL_TESTNET_ZIP_NAME}"
$SIGNUM_POOL_TESTNET_PORT = 8001

### Signum Explorer variables ###
$SIGNUM_EXPLORER_DIR_NAME = "Explorer"
$SIGNUM_EXPLORER_STARTER_PS1_NAME = "start-explorer.ps1"
$SIGNUM_EXPLORER_STARTER_EXEC_NAME = "start-explorer.bat"

### Signum Explorer Mainnet variables ###
$SIGNUM_EXPLORER_MAINNET_UNZIP_NAME = "signum-explorer-master"
$SIGNUM_EXPLORER_MAINNET_ZIP_NAME = "${SIGNUM_EXPLORER_MAINNET_UNZIP_NAME}.zip"
$SIGNUM_EXPLORER_MAINNET_DIR_PATH = "${SIGNUM_MAINNET_DIR_NAME}\${SIGNUM_EXPLORER_DIR_NAME}"
$SIGNUM_EXPLORER_MAINNET_ZIP_PATH = "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}\${SIGNUM_EXPLORER_MAINNET_ZIP_NAME}"
$SIGNUM_EXPLORER_MAINNET_UNZIP_PATH = "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}\${SIGNUM_EXPLORER_MAINNET_UNZIP_NAME}"
# $SIGNUM_EXPLORER_MAINNET_GUNICORN_PATH = "$SIGNUM_POOL_MAINNET_UNZIP_PATH\gunicorn.conf.py"
$SIGNUM_EXPLORER_MAINNET_STARTER_PS1_PATH = "$SIGNUM_EXPLORER_MAINNET_UNZIP_PATH\${SIGNUM_EXPLORER_STARTER_PS1_NAME}"
$SIGNUM_EXPLORER_MAINNET_STARTER_EXEC_PATH = "$SIGNUM_EXPLORER_MAINNET_UNZIP_PATH\${SIGNUM_EXPLORER_STARTER_EXEC_NAME}"
$SIGNUM_EXPLORER_MAINNET_URL = "https://github.com/signum-network/signum-explorer/archive/refs/heads/master.zip"
$SIGNUM_EXPLORER_MAINNET_PORT = 6000
$SIGNUM_EXPLORER_MAINNET_SUPERVISOR_SATUS_PORT = 9000

### Signum Explorer Mainnet Python variables ###
$SIGNUM_EXPLORER_MAINNET_PYTHON_VERSION = "3.10.11"
$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME = "python310"
$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_ZIP_NAME = "${SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME}.zip"
$SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_NAME = "python-${SIGNUM_EXPLORER_MAINNET_PYTHON_VERSION}-embed-amd64}.zip"
$SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH = "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}\${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_NAME}"
$SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH = "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}\${SIGNUM_EXPLORER_MAINNET_UNZIP_NAME}"
$SIGNUM_EXPLORER_MAINNET_PYTHON_URL = "https://www.python.org/ftp/python/${SIGNUM_EXPLORER_MAINNET_PYTHON_VERSION}/python-${SIGNUM_EXPLORER_MAINNET_PYTHON_VERSION}-embed-amd64.zip"
$SIGNUM_EXPLORER_MAINNET_PYTHON_GETPIP_URL = "https://bootstrap.pypa.io/get-pip.py"

### Signum Explorer Testnet variables ###
$SIGNUM_EXPLORER_TESTNET_UNZIP_NAME = "signum-explorer-master"
$SIGNUM_EXPLORER_TESTNET_ZIP_NAME = "${SIGNUM_EXPLORER_TESTNET_UNZIP_NAME}.zip"
$SIGNUM_EXPLORER_TESTNET_DIR_PATH = "${SIGNUM_TESTNET_DIR_NAME}\${SIGNUM_EXPLORER_DIR_NAME}"
$SIGNUM_EXPLORER_TESTNET_ZIP_PATH = "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}\${SIGNUM_EXPLORER_TESTNET_ZIP_NAME}"
$SIGNUM_EXPLORER_TESTNET_UNZIP_PATH = "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}\${SIGNUM_EXPLORER_TESTNET_UNZIP_NAME}"
# $SIGNUM_EXPLORER_TESTNET_GUNICORN_PATH = "$SIGNUM_POOL_TESTNET_UNZIP_PATH\gunicorn.conf.py"
$SIGNUM_EXPLORER_TESTNET_STARTER_PS1_PATH = "$SIGNUM_EXPLORER_TESTNET_UNZIP_PATH\${SIGNUM_EXPLORER_STARTER_PS1_NAME}"
$SIGNUM_EXPLORER_TESTNET_STARTER_EXEC_PATH = "$SIGNUM_EXPLORER_TESTNET_UNZIP_PATH\${SIGNUM_EXPLORER_STARTER_EXEC_NAME}"
$SIGNUM_EXPLORER_TESTNET_URL = "https://github.com/signum-network/signum-explorer/archive/refs/heads/master.zip"
$SIGNUM_EXPLORER_TESTNET_PORT = 6001
$SIGNUM_EXPLORER_TESTNET_SUPERVISOR_SATUS_PORT = 9001

### Signum Explorer Testnet Python variables ###
$SIGNUM_EXPLORER_TESTNET_PYTHON_VERSION = "3.10.11"
$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME = "python310"
$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_ZIP_NAME = "${SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME}.zip"
$SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_NAME = "python-${SIGNUM_EXPLORER_TESTNET_PYTHON_VERSION}-embed-amd64}.zip"
$SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH = "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}\${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_NAME}"
$SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH = "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}\${SIGNUM_EXPLORER_TESTNET_UNZIP_NAME}"
$SIGNUM_EXPLORER_TESTNET_PYTHON_URL = "https://www.python.org/ftp/python/${SIGNUM_EXPLORER_TESTNET_PYTHON_VERSION}/python-${SIGNUM_EXPLORER_TESTNET_PYTHON_VERSION}-embed-amd64.zip"
$SIGNUM_EXPLORER_TESTNET_PYTHON_GETPIP_URL = "https://bootstrap.pypa.io/get-pip.py"

### Java Pool Mainnet variables ###
$JAVA_POOL_MAINNET_DIR_NAME = "jre"
$JAVA_POOL_MAINNET_UNZIP_NAME = "zulu11.56.19-ca-fx-jre11.0.15-win_x64"
$JAVA_POOL_MAINNET_ZIP_NAME = "$JAVA_POOL_MAINNET_UNZIP_NAME.zip"
$JAVA_POOL_MAINNET_DIR_PATH = "$SIGNUM_POOL_MAINNET_UNZIP_PATH\$JAVA_POOL_MAINNET_DIR_NAME"
$JAVA_POOL_MAINNET_ZIP_PATH = "${JAVA_POOL_MAINNET_DIR_PATH}\${JAVA_POOL_MAINNET_ZIP_NAME}"
$JAVA_POOL_MAINNET_UNZIP_PATH = "${JAVA_POOL_MAINNET_DIR_PATH}\${JAVA_POOL_MAINNET_UNZIP_NAME}"
$JAVA_POOL_MAINNET_URL = "https://cdn.azul.com/zulu/bin/$JAVA_POOL_MAINNET_ZIP_NAME"

### Java Pool Testnet variables ###
$JAVA_POOL_TESTNET_DIR_NAME = "jre"
$JAVA_POOL_TESTNET_UNZIP_NAME = "zulu11.56.19-ca-fx-jre11.0.15-win_x64"
$JAVA_POOL_TESTNET_ZIP_NAME = "$JAVA_POOL_TESTNET_UNZIP_NAME.zip"
$JAVA_POOL_TESTNET_DIR_PATH = "$SIGNUM_POOL_TESTNET_UNZIP_PATH\$JAVA_POOL_TESTNET_DIR_NAME"
$JAVA_POOL_TESTNET_ZIP_PATH = "${JAVA_POOL_TESTNET_DIR_PATH}\${JAVA_POOL_TESTNET_ZIP_NAME}"
$JAVA_POOL_TESTNET_UNZIP_PATH = "${JAVA_POOL_TESTNET_DIR_PATH}\${JAVA_POOL_TESTNET_UNZIP_NAME}"
$JAVA_POOL_TESTNET_URL = "https://cdn.azul.com/zulu/bin/$JAVA_POOL_TESTNET_ZIP_NAME"

### BTDEX variables ###
$BTDEX_STARTER_PS1_NAME = "start-btdex.ps1"
$BTDEX_STARTER_EXEC_NAME = "start-btdex.bat"
$BTDEX_VERSION = "v0.6.8"
$BTDEX_DIR_NAME = "BTDEX"
$BTDEX_EXEC_NAME = "btdex-${BTDEX_VERSION}-win.exe"
$BTDEX_EXEC_PATH = "${BTDEX_DIR_NAME}\${BTDEX_EXEC_NAME}"
$BTDEX_STARTER_PS1_PATH = "${BTDEX_DIR_NAME}\${BTDEX_STARTER_PS1_NAME}"
$BTDEX_STARTER_EXEC_PATH = "${BTDEX_DIR_NAME}\${BTDEX_STARTER_EXEC_NAME}"
# TODO download BTDEX all.jar
# $BTDEX_URL = "https://github.com/btdex/btdex/releases/download/${BTDEX_VERSION}/btdex-${BTDEX_VERSION}-all.jar"
$BTDEX_URL = "https://github.com/btdex/btdex/releases/download/${BTDEX_VERSION}/${BTDEX_EXEC_NAME}"

### Phoenix variables ###
$PHOENIX_STARTER_PS1_NAME = "start-phoenix.ps1"
$PHOENIX_STARTER_EXEC_NAME = "start-phoenix.bat"
$PHOENIX_VERSION = "1.5.0-beta.3"
$PHOENIX_DIR_NAME = "Phoenix"
$PHOENIX_EXEC_NAME = "win-phoenix-signum-wallet.${PHOENIX_VERSION}.exe"
$PHOENIX_EXEC_PATH = "${PHOENIX_DIR_NAME}\${PHOENIX_EXEC_NAME}"
$PHOENIX_STARTER_PS1_PATH = "${PHOENIX_DIR_NAME}\${PHOENIX_STARTER_PS1_NAME}"
$PHOENIX_STARTER_EXEC_PATH = "${PHOENIX_DIR_NAME}\${PHOENIX_STARTER_EXEC_NAME}"
$PHOENIX_URL = "https://github.com/signum-network/phoenix/releases/download/desktop-${PHOENIX_VERSION}/${PHOENIX_EXEC_NAME}"

### Plotter variables ###
$PLOTTER_DIR_NAME = "Plotter"

### Turbo Plotter variables ###
$TURBOPLOTTER_STARTER_PS1_NAME = "start-turboplotter.ps1"
$TURBOPLOTTER_STARTER_EXEC_NAME = "start-turboplotter.bat"
$TURBOPLOTTER_VERSION = "0.10.2"
$TURBOPLOTTER_DIR_NAME = "TurboPlotter"
$TURBOPLOTTER_EXEC_NAME = "TurboPlotter.exe"
$TURBOPLOTTER_UNZIP_NAME = "TurboPlotter_$TURBOPLOTTER_VERSION"
$TURBOPLOTTER_ZIP_NAME = "TurboPlotter_$TURBOPLOTTER_VERSION.zip"
$TURBOPLOTTER_DIR_PATH = "$PLOTTER_DIR_NAME\$TURBOPLOTTER_DIR_NAME"
$TURBOPLOTTER_UNZIP_PATH = "$TURBOPLOTTER_DIR_PATH\$TURBOPLOTTER_UNZIP_NAME"
$TURBOPLOTTER_ZIP_PATH = "$TURBOPLOTTER_DIR_PATH\$TURBOPLOTTER_ZIP_NAME"
$TURBOPLOTTER_EXEC_PATH = "$TURBOPLOTTER_UNZIP_PATH\${TURBOPLOTTER_EXEC_NAME}"
$TURBOPLOTTER_STARTER_PS1_PATH = "$TURBOPLOTTER_UNZIP_PATH\${TURBOPLOTTER_STARTER_PS1_NAME}"
$TURBOPLOTTER_STARTER_EXEC_PATH = "$TURBOPLOTTER_UNZIP_PATH\${TURBOPLOTTER_STARTER_EXEC_NAME}"
$TURBOPLOTTER_URL = "https://blackpawn.com/tp/drop/TurboPlotter_$TURBOPLOTTER_VERSION.zip"

### Signum Plotter variables ###
$SIGNUMPLOTTER_STARTER_PS1_NAME = "start-signumplotter.ps1"
$SIGNUMPLOTTER_STARTER_EXEC_NAME = "start-signumplotter.bat"
$SIGNUMPLOTTER_VERSION = "v2.5.0"
$SIGNUMPLOTTER_DIR_NAME = "SignumPlotter"
$SIGNUMPLOTTER_EXEC_NAME = "signum-plotter.exe"
$SIGNUMPLOTTER_DIR_PATH = "$PLOTTER_DIR_NAME\$SIGNUMPLOTTER_DIR_NAME\$SIGNUMPLOTTER_VERSION"
$SIGNUMPLOTTER_EXEC_PATH = "$SIGNUMPLOTTER_DIR_PATH\${SIGNUMPLOTTER_EXEC_NAME}"
$SIGNUMPLOTTER_STARTER_PS1_PATH = "$SIGNUMPLOTTER_DIR_PATH\${SIGNUMPLOTTER_STARTER_PS1_NAME}"
$SIGNUMPLOTTER_STARTER_EXEC_PATH = "$SIGNUMPLOTTER_DIR_PATH\${SIGNUMPLOTTER_STARTER_EXEC_NAME}"
$SIGNUMPLOTTER_URL = "https://github.com/signum-network/signum-plotter/releases/download/$SIGNUMPLOTTER_VERSION/signum-plotter.exe"

### Signum Miner variables ###
$MINER_DIR_NAME = "Miner"

$SIGNUM_MINER_STARTER_PS1_NAME = "start-miner.ps1"
$SIGNUM_MINER_STARTER_EXEC_NAME = "start-miner.bat"
$SIGNUM_MINER_DIR_NAME = "SignumMiner"

### Signum Miner Mainnet variables ###
$SIGNUM_MINER_MAINNET_VERSION = "v1.8.0"
$SIGNUM_MINER_MAINNET_EXEC_NAME = "signum-miner.exe"
$SIGNUM_MINER_MAINNET_VERSION_DIR_NAME = "$SIGNUM_MINER_MAINNET_VERSION"
$SIGNUM_MINER_MAINNET_VERSION_DIR_PATH = "$SIGNUM_MAINNET_DIR_NAME\$MINER_DIR_NAME\$SIGNUM_MINER_DIR_NAME\$SIGNUM_MINER_MAINNET_VERSION_DIR_NAME"
$SIGNUM_MINER_MAINNET_EXEC_PATH = "$SIGNUM_MINER_MAINNET_VERSION_DIR_PATH\${SIGNUM_MINER_MAINNET_EXEC_NAME}"
$SIGNUM_MINER_MAINNET_STARTER_PS1_PATH = "$SIGNUM_MINER_MAINNET_VERSION_DIR_PATH\${SIGNUM_MINER_STARTER_PS1_NAME}"
$SIGNUM_MINER_MAINNET_STARTER_EXEC_PATH = "$SIGNUM_MINER_MAINNET_VERSION_DIR_PATH\${SIGNUM_MINER_STARTER_EXEC_NAME}"
$SIGNUM_MINER_MAINNET_CONF_PATH = "$SIGNUM_MINER_MAINNET_VERSION_DIR_PATH\config.yaml"
$SIGNUM_MINER_MAINNET_CONF_URL = "https://github.com/signum-network/signum-miner/releases/download/${SIGNUM_MINER_MAINNET_VERSION}/config.yaml"
$SIGNUM_MINER_MAINNET_URL = "https://github.com/signum-network/signum-miner/releases/download/${SIGNUM_MINER_MAINNET_VERSION}/${SIGNUM_MINER_MAINNET_EXEC_NAME}"

### Signum Miner Testnet variables ###
$SIGNUM_MINER_TESTNET_VERSION = "v1.8.0"
$SIGNUM_MINER_TESTNET_EXEC = "signum-miner.exe"
$SIGNUM_MINER_TESTNET_VERSION_DIR = "$SIGNUM_MINER_TESTNET_VERSION"
$SIGNUM_MINER_TESTNET_VERSION_DIR_PATH = "$SIGNUM_TESTNET_DIR_NAME\$MINER_DIR_NAME\$SIGNUM_MINER_DIR_NAME\$SIGNUM_MINER_TESTNET_VERSION_DIR"
$SIGNUM_MINER_TESTNET_EXEC_PATH = "$SIGNUM_MINER_TESTNET_VERSION_DIR_PATH\${SIGNUM_MINER_TESTNET_EXEC}"
$SIGNUM_MINER_TESTNET_STARTER_PS1_PATH = "$SIGNUM_MINER_TESTNET_VERSION_DIR_PATH\${SIGNUM_MINER_STARTER_PS1_NAME}"
$SIGNUM_MINER_TESTNET_STARTER_EXEC_PATH = "$SIGNUM_MINER_TESTNET_VERSION_DIR_PATH\${SIGNUM_MINER_STARTER_EXEC_NAME}"
$SIGNUM_MINER_TESTNET_CONF_PATH = "$SIGNUM_MINER_TESTNET_VERSION_DIR_PATH\config.yaml"
$SIGNUM_MINER_TESTNET_CONF_URL = "https://github.com/signum-network/signum-miner/releases/download/${SIGNUM_MINER_TESTNET_VERSION}/config.yaml"
$SIGNUM_MINER_TESTNET_URL = "https://github.com/signum-network/signum-miner/releases/download/${SIGNUM_MINER_TESTNET_VERSION}/${SIGNUM_MINER_TESTNET_EXEC}"

### Signum Documents variables ###
$DOCUMENTS_DIR = "Documents"

### Signum Whitepaper Documents variables ###
$WHITEPAPER_VERSION = "v1"
$WHITEPAPER_DOC_NAME = "Whitepaper_$WHITEPAPER_VERSION.pdf"
$WHITEPAPER_DOC_PATH = "$DOCUMENTS_DIR\$WHITEPAPER_DOC_NAME.pdf"
$WHITEPAPER_URL = "https://signum-network.github.io/whitepaper/business/${WHITEPAPER_VERSION}.pdf"

### Signum Whitehouse Documents variables ###
$WHITEHOUSE_DOC_NAME = "Climate_And_Energy_Implications_Of_Crypto_Assets_In_The_United_States.pdf"
$WHITEHOUSE_DOC_PATH = "$DOCUMENTS_DIR\$WHITEHOUSE_DOC_NAME"
$WHITEHOUSE_URL = "https://github.com/BalazsGit/Signum-Documents/blob/main/09-2022-Crypto-Assets-and-Climate-Report.pdf"
# $WHITEHOUSE_URL = "https://www.whitehouse.gov/wp-content/uploads/2022/09/09-2022-Crypto-Assets-and-Climate-Report.pdf"

### Signum Indecs Documents variables ###
$INDECS_DOC_NAME = "Sustainabiliy_Of_Blockchain_For_Strong_Private_Data_From_IOT_Devices.pdf"
$INDECS_DOC_PATH = "$DOCUMENTS_DIR\$INDECS_DOC_NAME"
$INDECS_URL = "https://indecs.eu/2024/indecs2024-pp738-762.pdf"

### Signum Link Collection variables ###
$SIGNUM_LINK_COLLECTION = "Signum-Link-Collection.html"
$SIGNUM_LINK_COLLECTION_PATH = "$DOCUMENTS_DIR\$SIGNUM_LINK_COLLECTION"

### Database variables ###
$DATABASE_DIR = "Database"

### MariaDB variables ###
$MARIADB_STARTER_PS1_NAME = "start-mariadb.ps1"
$MARIADB_STARTER_EXEC_NAME = "start-mariadb.bat"
$MARIADB_EXEC_NAME = "mariadb.exe"
$MARIADBD_EXEC_NAME = "mariadbd.exe"
$MARIADB_INSTALL_EXEC_NAME = "mysql_install_db.exe"
$MARIADB_VERSION = "10.6.20"
$MARIADB_DIR_NAME = "MariaDB"
# TODO thinking about naming convetion
# $MARIADB_NAME_DIR = "MariaDB"
$MARIADB_DIR_PATH = "${DATABASE_DIR}\${MARIADB_DIR_NAME}"
$MARIADB_DOWNLOADS_DIR_PATH = "$MARIADB_DIR_PATH\$DOWNLOADS_DIR_NAME"
$MARIADB_UNZIP_NAME = "mariadb-${MARIADB_VERSION}-winx64"
$MARIADB_ZIP_NAME = "${MARIADB_UNZIP_NAME}.zip"
# $MARIADB_UNZIP_PATH = "${MARIADB_DIR_PATH}\${MARIADB_UNZIP_NAME}"
# TODO delete MARIADB_UNZIP_PATH
$MARIADB_UNZIP_PATH = "${MARIADB_DOWNLOADS_DIR_PATH}\${MARIADB_UNZIP_NAME}"
$MARIADB_ZIP_PATH = "${MARIADB_DOWNLOADS_DIR_PATH}\${MARIADB_ZIP_NAME}"
$MARIADB_BIN_PATH = "${MARIADB_DIR_PATH}\bin"
$MARIADB_DATA_PATH = "${MARIADB_DIR_PATH}\data"
$MARIADB_STARTER_PS1_PATH = "${MARIADB_DIR_PATH}\${MARIADB_STARTER_PS1_NAME}"
$MARIADB_STARTER_EXEC_PATH = "${MARIADB_DIR_PATH}\${MARIADB_STARTER_EXEC_NAME}"
$MARIADB_URL = "https://archive.mariadb.org/mariadb-${MARIADB_VERSION}/winx64-packages/mariadb-${MARIADB_VERSION}-winx64.zip"
$MARIADB_PORT = 3306
$MARIADB_ROOT_USER = "root"
$MARIADB_ROOT_PASSWORD = ""

function updateMariadbVariables {
	param (
        [string]$version,
		[string]$port
    )

    $global:MARIADB_VERSION = $version
    $global:MARIADB_UNZIP_NAME = "mariadb-${global:MARIADB_VERSION}-winx64"
	$global:MARIADB_UNZIP_PATH = "${global:MARIADB_DOWNLOADS_DIR_PATH}\${global:MARIADB_UNZIP_NAME}"
    $global:MARIADB_ZIP_NAME = "${global:MARIADB_UNZIP_NAME}.zip"
	$global:MARIADB_ZIP_PATH = "${global:MARIADB_DOWNLOADS_DIR_PATH}\${global:MARIADB_ZIP_NAME}"
    $global:MARIADB_URL = "https://archive.mariadb.org/mariadb-${global:MARIADB_VERSION}/winx64-packages/mariadb-${global:MARIADB_VERSION}-winx64.zip"
    $global:MARIADB_PORT = $Port
}

<#
$DATABASE_NAME = ""
$DATABASE_USERNAME = ""
$DATABASE_PASSWORD = ""
#>

### Smart Contract variables ###
$SMART_CONTRACT_DIR_NAME = "SmartContract"

### SmartC variables ###
$SMARTC_SIGNUM_COMPILER_VERSION = "2.3.0"
$SMARTC_ASSEMBLY_HIGHLIGHT_VERSION = "1.1.1"

### SmartC WEB UI variables ###
$SMARTC_WEB_UI_STARTER_PS1_NAME = "start-smartc.ps1"
$SMARTC_WEB_UI_STARTER_EXEC_NAME = "start-smartc.bat"

$SMARTC_WEB_UI_ZIP_ORIGINAL_NAME = "smartc-web-ui-main"
$SMARTC_WEB_UI_UNZIP_NAME = "SmartC-WEB-UI"
$SMARTC_WEB_UI_ZIP_NAME = "$SMARTC_WEB_UI_UNZIP_NAME.zip"
$SMARTC_WEB_UI_ZIP_DOWNLOAD_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_WEB_UI_ZIP_ORIGINAL_NAME}"
$SMARTC_WEB_UI_ZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_WEB_UI_ZIP_NAME}"
$SMARTC_WEB_UI_UNZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_WEB_UI_UNZIP_NAME}"
$SMARTC_WEB_UI_STARTER_PS1_PATH = "${SMARTC_WEB_UI_UNZIP_PATH}\${SMARTC_WEB_UI_STARTER_PS1_NAME}"
$SMARTC_WEB_UI_STARTER_EXEC_PATH = "${SMARTC_WEB_UI_UNZIP_PATH}\${SMARTC_WEB_UI_STARTER_EXEC_NAME}"
$SMARTC_WEB_UI_URL = "https://github.com/deleterium/smartc-web-ui/archive/refs/heads/main.zip"
$SMARTC_WEB_UI_PORT = 7000

### SmartC Retro UI variables ###
$SMARTC_RETRO_UI_STARTER_PS1_NAME = "start-smartc.ps1"
$SMARTC_RETRO_UI_STARTER_EXEC_NAME = "start-smartc.bat"

$SMARTC_RETRO_UI_ZIP_ORIGINAL_NAME = "smartc-retro-ui-main"
$SMARTC_RETRO_UI_UNZIP_NAME = "SmartC-RETRO-UI"
$SMARTC_RETRO_UI_ZIP_NAME = "$SMARTC_RETRO_UI_UNZIP_NAME.zip"
$SMARTC_RETRO_UI_ZIP_DOWNLOAD_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_RETRO_UI_ZIP_ORIGINAL_NAME}"
$SMARTC_RETRO_UI_ZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_RETRO_UI_ZIP_NAME}"
$SMARTC_RETRO_UI_UNZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_RETRO_UI_UNZIP_NAME}"
$SMARTC_RETRO_UI_STARTER_PS1_PATH = "${SMARTC_RETRO_UI_UNZIP_PATH}\${SMARTC_RETRO_UI_STARTER_PS1_NAME}"
$SMARTC_RETRO_UI_STARTER_EXEC_PATH = "${SMARTC_RETRO_UI_UNZIP_PATH}\${SMARTC_RETRO_UI_STARTER_EXEC_NAME}"
$SMARTC_RETRO_UI_URL = "https://github.com/deleterium/smartc-retro-ui/archive/refs/heads/main.zip"
$SMARTC_RETRO_UI_PORT = 7001

### SmartC Signum Decompiler variables ###
$SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_NAME = "start-smartc-decompiler.ps1"
$SMARTC_SIGNUM_DECOMPILER_STARTER_EXEC_NAME = "start-smartc-decompiler.bat"

$SMARTC_SIGNUM_DECOMPILER_ZIP_ORIGINAL_NAME = "smartc-signum-decompiler-main"
$SMARTC_SIGNUM_DECOMPILER_UNZIP_NAME = "SmartC-SIGNUM-DECOMPILER"
$SMARTC_SIGNUM_DECOMPILER_ZIP_NAME = "$SMARTC_SIGNUM_DECOMPILER_UNZIP_NAME.zip"
$SMARTC_SIGNUM_DECOMPILER_ZIP_ORIGINAL_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_SIGNUM_DECOMPILER_ZIP_ORIGINAL_NAME}"
$SMARTC_SIGNUM_DECOMPILER_ZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_SIGNUM_DECOMPILER_ZIP_NAME}"
$SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTC_SIGNUM_DECOMPILER_UNZIP_NAME}"
$SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_PATH = "${SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH}\${SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_NAME}"
$SMARTC_SIGNUM_DECOMPILER_STARTER_EXEC_PATH = "${SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH}\${SMARTC_SIGNUM_DECOMPILER_STARTER_EXEC_NAME}"
$SMARTC_SIGNUM_DECOMPILER_URL = "https://github.com/deleterium/smartc-signum-decompiler/archive/refs/heads/main.zip"
$SMARTC_SIGNUM_DECOMPILER_PORT = 7002

### SC Simulator variables ###
$SC_SIMULATOR_STARTER_PS1_NAME = "start-sc-simulator.ps1"
$SC_SIMULATOR_STARTER_EXEC_NAME = "start-sc-simulator.bat"

$SC_SIMULATOR_ZIP_ORIGINAL_NAME = "sc-simulator-main"
$SC_SIMULATOR_UNZIP_NAME = "SC-Simulator"
$SC_SIMULATOR_ZIP_NAME = "$SC_SIMULATOR_UNZIP_NAME.zip"
$SC_SIMULATOR_ZIP_ORIGINAL_PATH = "${SMART_CONTRACT_DIR_NAME}\${SC_SIMULATOR_ZIP_ORIGINAL_NAME}"
$SC_SIMULATOR_ZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SC_SIMULATOR_ZIP_NAME}"
$SC_SIMULATOR_UNZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SC_SIMULATOR_UNZIP_NAME}"
$SC_SIMULATOR_STARTER_PS1_PATH = "${SC_SIMULATOR_UNZIP_PATH}\${SC_SIMULATOR_STARTER_PS1_NAME}"
$SC_SIMULATOR_STARTER_EXEC_PATH = "${SC_SIMULATOR_UNZIP_PATH}\${SC_SIMULATOR_STARTER_EXEC_NAME}"
$SC_SIMULATOR_URL = "https://github.com/deleterium/SC-Simulator/archive/refs/heads/main.zip"
$SC_SIMULATOR_PORT = 7003

### Signum D-OR variables ###
$SIGNUM_D_OR_STARTER_PS1_NAME = "start-signum-d-or.ps1"
$SIGNUM_D_OR_STARTER_EXEC_NAME = "start-signum-d-or.bat"

$SIGNUM_D_OR_ZIP_ORIGINAL_NAME = "signum-d-or-main"
$SIGNUM_D_OR_UNZIP_NAME = "Signum-D-OR"
$SIGNUM_D_OR_ZIP_NAME = "$SIGNUM_D_OR_UNZIP_NAME.zip"
$SIGNUM_D_OR_ZIP_ORIGINAL_PATH = "${SMART_CONTRACT_DIR_NAME}\${SIGNUM_D_OR_ZIP_ORIGINAL_NAME}"
$SIGNUM_D_OR_ZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SIGNUM_D_OR_ZIP_NAME}"
$SIGNUM_D_OR_UNZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SIGNUM_D_OR_UNZIP_NAME}"
$SIGNUM_D_OR_STARTER_PS1_PATH = "${SIGNUM_D_OR_UNZIP_PATH}\${SIGNUM_D_OR_STARTER_PS1_NAME}"
$SIGNUM_D_OR_STARTER_EXEC_PATH = "${SIGNUM_D_OR_UNZIP_PATH}\${SIGNUM_D_OR_STARTER_EXEC_NAME}"
$SIGNUM_D_OR_URL = "https://github.com/deleterium/Signum-D-Or/archive/refs/heads/main.zip"

### Signum SmartJ variables ###
$SMARTJ_STARTER_PS1_NAME = "start-smartj.ps1"
$SMARTJ_STARTER_EXEC_NAME = "start-smartj.bat"

$SMARTJ_ZIP_ORIGINAL_NAME = "signum-smartj-master"
$SMARTJ_UNZIP_NAME = "Signum-SmartJ"
$SMARTJ_ZIP_NAME = "$SMARTJ_UNZIP_NAME.zip"
$SMARTJ_ZIP_ORIGINAL_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTJ_ZIP_ORIGINAL_NAME}"
$SMARTJ_ZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTJ_ZIP_NAME}"
$SMARTJ_UNZIP_PATH = "${SMART_CONTRACT_DIR_NAME}\${SMARTJ_UNZIP_NAME}"
$SMARTJ_STARTER_PS1_PATH = "${SMARTJ_UNZIP_PATH}\${SMARTJ_STARTER_PS1_NAME}"
$SMARTJ_STARTER_EXEC_PATH = "${SMARTJ_UNZIP_PATH}\${SMARTJ_STARTER_EXEC_NAME}"
$SMARTJ_URL = "https://github.com/signum-network/signum-smartj/archive/refs/heads/master.zip"

### Signum SmartJ Java variables ###
$JAVA_SMARTJ_DIR_NAME = "jre"
$JAVA_SMARTJ_UNZIP_NAME = "openlogic-openjdk-8u432-b06-windows-x64"
$JAVA_SMARTJ_ZIP_NAME = "$JAVA_SMARTJ_UNZIP_NAME.zip"
$JAVA_SMARTJ_DIR_PATH = "$SMARTJ_UNZIP_PATH\$JAVA_SMARTJ_DIR_NAME"
$JAVA_SMARTJ_ZIP_PATH = "${JAVA_SMARTJ_DIR_PATH}\${JAVA_SMARTJ_ZIP_NAME}"
$JAVA_SMARTJ_UNZIP_PATH = "${JAVA_SMARTJ_DIR_PATH}\${JAVA_SMARTJ_UNZIP_NAME}"
$JAVA_SMARTJ_URL = "https://builds.openlogic.com/downloadJDK/openlogic-openjdk/8u432-b06/$JAVA_SMARTJ_ZIP_NAME"

### IPFS variables ###
$IPFS_DIR_NAME = "IPFS"

$IPFS_SIGNUMART_STARTER_PS1_NAME = "start-ipfs-signumart.ps1"
$IPFS_SIGNUMART_STARTER_EXEC_NAME = "start-ipfs-signumart.bat"
$IPFS_SIGNUMART_STARTER_PS1_PATH = "$IPFS_DIR_NAME\$IPFS_SIGNUMART_STARTER_PS1_NAME"
$IPFS_SIGNUMART_STARTER_EXEC_PATH = "$IPFS_DIR_NAME\$IPFS_SIGNUMART_STARTER_EXEC_NAME"

### IPFS Client variables ###
$IPFS_CLIENT_STARTER_PS1_NAME = "start-ipfs-client.ps1"
$IPFS_CLIENT_STARTER_EXEC_NAME = "start-ipfs-client.bat"

$IPFS_CLIENT_REPOSITORY_DIR_NAME = "Repository"
$IPFS_CLIENT_VERSION = "0.33.0"
$IPFS_CLIENT_DIR_NAME = "IPFS-CLIENT"
$IPFS_CLIENT_STORAGEMAX = "1000GB"
$IPFS_CLIENT_EXEC_NAME = "ipfs.exe"
$IPFS_CLIENT_UNZIP_NAME = "kubo_v${IPFS_CLIENT_VERSION}_windows-amd64"
$IPFS_CLIENT_ZIP_NAME = "${IPFS_CLIENT_UNZIP_NAME}.zip"
$IPFS_CLIENT_REPOSITORY_DIR_PATH = "$IPFS_DIR_NAME\$IPFS_CLIENT_REPOSITORY_DIR_NAME"
$IPFS_CLIENT_CONFIG_DIR_PATH = "$IPFS_CLIENT_REPOSITORY_DIR_PATH\config"
$IPFS_CLIENT_DIR_PATH = "$IPFS_DIR_NAME\$IPFS_CLIENT_DIR_NAME"
$IPFS_CLIENT_ZIP_PATH = "${IPFS_CLIENT_DIR_PATH}\${IPFS_CLIENT_ZIP_NAME}"
$IPFS_CLIENT_UNZIP_PATH = "${IPFS_CLIENT_DIR_PATH}\${IPFS_CLIENT_UNZIP_NAME}"
$IPFS_CLIENT_EXEC_PATH = "${IPFS_CLIENT_UNZIP_PATH}\${IPFS_CLIENT_EXEC_NAME}"
$IPFS_CLIENT_STARTER_PS1_PATH = "${IPFS_CLIENT_UNZIP_PATH}\${IPFS_CLIENT_STARTER_PS1_NAME}"
$IPFS_CLIENT_STARTER_EXEC_PATH = "${IPFS_CLIENT_UNZIP_PATH}\${IPFS_CLIENT_STARTER_EXEC_NAME}"
$IPFS_CLIENT_URL = "https://github.com/ipfs/kubo/releases/download/v${IPFS_CLIENT_VERSION}/${IPFS_CLIENT_ZIP_NAME}"
$IPFS_CLIENT_SWARN_PORT = 4001
$IPFS_CLIENT_API_PORT = 5001
$IPFS_CLIENT_GATEWAY_PORT = 8080

### IPFS Cluster Follow variables ###
$IPFS_CLUSTER_FOLLOW_STARTER_PS1_NAME = "start-ipfs-cluster-follow.ps1"
$IPFS_CLUSTER_FOLLOW_STARTER_EXEC_NAME = "start-ipfs-cluster-follow.bat"

$IPFS_CLUSTER_FOLLOW_VERSION = "1.1.2"
$IPFS_CLUSTER_FOLLOW_DIR_NAME = "IPFS-CLUSTER-FOLLOW"
$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_NAME = "service.json"
$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_NAME = "Signumart"
$IPFS_CLUSTER_FOLLOW_DATA_DIR_NAME = "Data"
$IPFS_CLUSTER_FOLLOW_EXEC_NAME = "ipfs-cluster-follow.exe"
$IPFS_CLUSTER_FOLLOW_UNZIP_NAME = "ipfs-cluster-follow_v${IPFS_CLUSTER_FOLLOW_VERSION}_windows-amd64"
$IPFS_CLUSTER_FOLLOW_ZIP_NAME = "${IPFS_CLUSTER_FOLLOW_UNZIP_NAME}.zip"
$IPFS_CLUSTER_FOLLOW_DIR_PATH = "$IPFS_DIR_NAME\$IPFS_CLUSTER_FOLLOW_DIR_NAME"
$IPFS_CLUSTER_FOLLOW_ZIP_PATH = "${IPFS_CLUSTER_FOLLOW_DIR_PATH}\${IPFS_CLUSTER_FOLLOW_ZIP_NAME}"
$IPFS_CLUSTER_FOLLOW_UNZIP_PATH = "${IPFS_CLUSTER_FOLLOW_DIR_PATH}\${IPFS_CLUSTER_FOLLOW_UNZIP_NAME}"
$IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH = "$IPFS_CLUSTER_FOLLOW_UNZIP_PATH\$IPFS_CLUSTER_FOLLOW_DATA_DIR_NAME"
$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH = "$IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH\$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_NAME"
$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH = "$IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH\$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_NAME"
$IPFS_CLUSTER_FOLLOW_EXEC_PATH = "${IPFS_CLUSTER_FOLLOW_UNZIP_PATH}\${IPFS_CLUSTER_FOLLOW_EXEC_NAME}"
$IPFS_CLUSTER_FOLLOW_STARTER_PS1_PATH = "${IPFS_CLUSTER_FOLLOW_UNZIP_PATH}\${IPFS_CLUSTER_FOLLOW_STARTER_PS1_NAME}"
$IPFS_CLUSTER_FOLLOW_STARTER_EXEC_PATH = "${IPFS_CLUSTER_FOLLOW_UNZIP_PATH}\${IPFS_CLUSTER_FOLLOW_STARTER_EXEC_NAME}"
$IPFS_CLUSTER_FOLLOW_URL = "https://dist.ipfs.tech/ipfs-cluster-follow/v${IPFS_CLUSTER_FOLLOW_VERSION}/$IPFS_CLUSTER_FOLLOW_ZIP_NAME"
$IPFS_CLUSTER_FOLLOW_SIGNUMART_CONFIG_URL = "https://ipfs.io/ipfs/QmPu3KCckVKHPJh4BcyKEpHjcuQtp9GcspkcVbDcTQraSU"
$IPFS_CLUSTER_FOLLOW_PORT = 9094

### IPFS Cluster Ctl variables ###
$IPFS_CLUSTER_CTL_STARTER_PS1_NAME = "start-ipfs-cluster-ctl.ps1"
$IPFS_CLUSTER_CTL_STARTER_EXEC_NAME = "start-ipfs-cluster-ctl.bat"

$IPFS_CLUSTER_CTL_VERSION = "1.1.2"
$IPFS_CLUSTER_CTL_DIR_NAME = "IPFS-CLUSTER-CTL"
$IPFS_CLUSTER_CTL_EXEC_NAME = "ipfs-cluster-ctl.exe"
$IPFS_CLUSTER_CTL_UNZIP_NAME = "ipfs-cluster-ctl_v${IPFS_CLUSTER_CTL_VERSION}_windows-amd64"
$IPFS_CLUSTER_CTL_ZIP_NAME = "${IPFS_CLUSTER_CTL_UNZIP_NAME}.zip"
$IPFS_CLUSTER_CTL_DIR_PATH = "$IPFS_DIR_NAME\$IPFS_CLUSTER_CTL_DIR_NAME"
$IPFS_CLUSTER_CTL_ZIP_PATH = "${IPFS_CLUSTER_CTL_DIR_PATH}\${IPFS_CLUSTER_CTL_ZIP_NAME}"
$IPFS_CLUSTER_CTL_UNZIP_PATH = "${IPFS_CLUSTER_CTL_DIR_PATH}\${IPFS_CLUSTER_CTL_UNZIP_NAME}"
$IPFS_CLUSTER_CTL_DATA_DIR_PATH = "$IPFS_CLUSTER_CTL_UNZIP_PATH\$IPFS_CLUSTER_CTL_DATA_DIR_NAME"
$IPFS_CLUSTER_CTL_EXEC_PATH = "${IPFS_CLUSTER_CTL_UNZIP_PATH}\${IPFS_CLUSTER_CTL_EXEC_NAME}"
$IPFS_CLUSTER_CTL_STARTER_PS1_PATH = "${IPFS_CLUSTER_CTL_UNZIP_PATH}\${IPFS_CLUSTER_CTL_STARTER_PS1_NAME}"
$IPFS_CLUSTER_CTL_STARTER_EXEC_PATH = "${IPFS_CLUSTER_CTL_UNZIP_PATH}\${IPFS_CLUSTER_CTL_STARTER_EXEC_NAME}"
$IPFS_CLUSTER_CTL_URL = "https://dist.ipfs.tech/ipfs-cluster-ctl/v${IPFS_CLUSTER_CTL_VERSION}/$IPFS_CLUSTER_CTL_ZIP_NAME"
$IPFS_CLUSTER_CTL_PORT = $null

### IPFS Cluster Service variables ###
$IPFS_CLUSTER_SERVICE_STARTER_PS1_NAME = "start-ipfs-cluster-service.ps1"
$IPFS_CLUSTER_SERVICE_STARTER_EXEC_NAME = "start-ipfs-cluster-service.bat"

$IPFS_CLUSTER_SERVICE_VERSION = "1.1.2"
$IPFS_CLUSTER_SERVICE_DIR_NAME = "IPFS-CLUSTER-SERVICE"
$IPFS_CLUSTER_SERVICE_EXEC_NAME = "ipfs-cluster-service.exe"
$IPFS_CLUSTER_SERVICE_UNZIP_NAME = "ipfs-cluster-service_v${IPFS_CLUSTER_SERVICE_VERSION}_windows-amd64"
$IPFS_CLUSTER_SERVICE_ZIP_NAME = "${IPFS_CLUSTER_SERVICE_UNZIP_NAME}.zip"
$IPFS_CLUSTER_SERVICE_DIR_PATH = "$IPFS_DIR_NAME\$IPFS_CLUSTER_SERVICE_DIR_NAME"
$IPFS_CLUSTER_SERVICE_ZIP_PATH = "${IPFS_CLUSTER_SERVICE_DIR_PATH}\${IPFS_CLUSTER_SERVICE_ZIP_NAME}"
$IPFS_CLUSTER_SERVICE_UNZIP_PATH = "${IPFS_CLUSTER_SERVICE_DIR_PATH}\${IPFS_CLUSTER_SERVICE_UNZIP_NAME}"
$IPFS_CLUSTER_SERVICE_DATA_DIR_PATH = "$IPFS_CLUSTER_SERVICE_UNZIP_PATH\$IPFS_CLUSTER_SERVICE_DATA_DIR_NAME"
$IPFS_CLUSTER_SERVICE_EXEC_PATH = "${IPFS_CLUSTER_SERVICE_UNZIP_PATH}\${IPFS_CLUSTER_SERVICE_EXEC_NAME}"
$IPFS_CLUSTER_SERVICE_STARTER_PS1_PATH = "${IPFS_CLUSTER_SERVICE_UNZIP_PATH}\${IPFS_CLUSTER_SERVICE_STARTER_PS1_NAME}"
$IPFS_CLUSTER_SERVICE_STARTER_EXEC_PATH = "${IPFS_CLUSTER_SERVICE_UNZIP_PATH}\${IPFS_CLUSTER_SERVICE_STARTER_EXEC_NAME}"
$IPFS_CLUSTER_SERVICE_URL = "https://dist.ipfs.tech/ipfs-cluster-service/v${IPFS_CLUSTER_SERVICE_VERSION}/$IPFS_CLUSTER_SERVICE_ZIP_NAME"
$IPFS_CLUSTER_SERVICE_PORT = $null

### Tools variables ###
$TOOLS_DIR_NAME = "Tools"

### HeidiSQL variables ###
$HEIDISQL_STARTER_PS1_NAME = "start-heidisql.ps1"
$HEIDISQL_STARTER_EXEC_NAME = "start-heidisql.bat"

$HEIDISQL_VERSION = "12.8"
$HEIDISQL_DIR_NAME = "HeidiSQL"
$HEIDISQL_EXEC_NAME = "heidisql.exe"
$HEIDISQL_UNZIP_NAME = "HeidiSQL_${HEIDISQL_VERSION}_Portable"
$HEIDISQL_ZIP_NAME = "$HEIDISQL_UNZIP_NAME.zip"
$HEIDISQL_DIR_PATH = "${TOOLS_DIR_NAME}\${HEIDISQL_DIR_NAME}"
$HEIDISQL_UNZIP_PATH = "${HEIDISQL_DIR_PATH}\${HEIDISQL_UNZIP_NAME}"
$HEIDISQL_ZIP_PATH = "${HEIDISQL_DIR_PATH}\${HEIDISQL_ZIP_NAME}"
$HEIDISQL_EXEC_PATH = "${HEIDISQL_UNZIP_PATH}\${HEIDISQL_EXEC_NAME}"
$HEIDISQL_STARTER_PS1_PATH = "${HEIDISQL_UNZIP_PATH}\${HEIDISQL_STARTER_PS1_NAME}"
$HEIDISQL_STARTER_EXEC_PATH = "${HEIDISQL_UNZIP_PATH}\${HEIDISQL_STARTER_EXEC_NAME}"
$HEIDISQL_URL = "https://www.heidisql.com/downloads/releases/HeidiSQL_${HEIDISQL_VERSION}_64_Portable.zip"

### DBeaver variables ###
$DBEAVER_STARTER_PS1_NAME = "start-dbeaver.ps1"
$DBEAVER_STARTER_EXEC_NAME = "start-dbeaver.bat"

$DBEAVER_VERSION = "24.3.1"
$DBEAVER_DIR_NAME = "DBeaver"
$DBEAVER_EXEC_NAME = "dbeaver.exe"
$DBEAVER_UNZIP_NAME = "dbeaver-ce-${DBEAVER_VERSION}-win32.win32.x86_64"
$DBEAVER_ZIP_NAME = "${DBEAVER_UNZIP_NAME}.zip"
$DBEAVER_DIR_PATH = "${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}"
$DBEAVER_UNZIP_PATH = "${DBEAVER_DIR_PATH}\${DBEAVER_UNZIP_NAME}"
$DBEAVER_ZIP_PATH = "${DBEAVER_DIR_PATH}\${DBEAVER_ZIP_NAME}"
$DBEAVER_EXEC_PATH = "${DBEAVER_UNZIP_PATH}\${DBEAVER_EXEC_NAME}"
$DBEAVER_STARTER_PS1_PATH = "${DBEAVER_UNZIP_PATH}\${DBEAVER_STARTER_PS1_NAME}"
$DBEAVER_STARTER_EXEC_PATH = "${DBEAVER_UNZIP_PATH}\${DBEAVER_STARTER_EXEC_NAME}"
$DBEAVER_URL = "https://dbeaver.io/files/${DBEAVER_VERSION}/${DBEAVER_ZIP_NAME}"

### NodeJS variables ###
$NODEJS_STARTER_PS1_NAME = "start-nodejs.ps1"
$NODEJS_STARTER_EXEC_NAME = "start-nodejs.bat"

$NODEJS_VERSION = "23.7.0"
$NODEJS_DIR_NAME = "NodeJS"
$NODEJS_EXEC_NAME = "node.exe"
$NODEJS_ZIP_NAME = "node-v${NODEJS_VERSION}-win-x64.zip"
$NODEJS_UNZIP_NAME = "node-v${NODEJS_VERSION}-win-x64"
$NODEJS_DIR_PATH = "${TOOLS_DIR_NAME}\${NODEJS_DIR_NAME}"
$NODEJS_ZIP_PATH = "${NODEJS_DIR_PATH}\${NODEJS_ZIP_NAME}"
$NODEJS_UNZIP_PATH = "${NODEJS_DIR_PATH}\${NODEJS_UNZIP_NAME}"
$NODEJS_EXEC_PATH = "${NODEJS_UNZIP_PATH}\${NODEJS_EXEC_NAME}"
$NODEJS_STARTER_PS1_PATH = "${NODEJS_UNZIP_PATH}\${NODEJS_STARTER_PS1_NAME}"
$NODEJS_STARTER_EXEC_PATH = "${NODEJS_UNZIP_PATH}\${NODEJS_STARTER_EXEC_NAME}"
$NODEJS_URL = "https://nodejs.org/dist/v${NODEJS_VERSION}/${NODEJS_ZIP_NAME}"

### Nginx variables ###
$NGINX_STARTER_PS1_NAME = "start-nginx.ps1"
$NGINX_STARTER_EXEC_NAME = "start-nginx.bat"

$NGINX_CREATE_CERTIFICATE_PS1_NAME = "create-certificate.ps1"
$NGINX_CREATE_CERTIFICATE_EXEC_NAME = "create-certificate.bat"

$NGINX_RENEW_CERTIFICATE_PS1_NAME = "renew-certificate.ps1"
$NGINX_RENEW_CERTIFICATE_EXEC_NAME = "renew-certificate.bat"

$NGINX_VERSION = "1.26.2"
$NGINX_DIR_NAME = "NGINX"
$NGINX_EXEC_NAME = "nginx.exe"
$NGINX_CONFIG_DIR_NAME = "conf"
$NGINX_CONFIG_FILE_NAME = "nginx.conf"
$NGINX_ORIGINAL_CONFIG_FILE_NAME = "nginx-original.conf"
$NGINX_UNZIP_NAME = "nginx-${NGINX_VERSION}"
$NGINX_ZIP_NAME = "${NGINX_UNZIP_NAME}.zip"
$NGINX_DIR_PATH = "${TOOLS_DIR_NAME}\${NGINX_DIR_NAME}"
$NGINX_UNZIP_PATH = "${NGINX_DIR_PATH}\${NGINX_UNZIP_NAME}"
$NGINX_ZIP_PATH = "${NGINX_DIR_PATH}\${NGINX_ZIP_NAME}"
$NGINX_CONFIG_DIR_PATH = "$NGINX_UNZIP_PATH\$NGINX_CONFIG_DIR_NAME"
$NGINX_CONFIG_FILE_PATH = "$NGINX_CONFIG_DIR_PATH\$NGINX_CONFIG_FILE_NAME"
$NGINX_ORIGINAL_CONFIG_FILE_PATH = "$NGINX_CONFIG_DIR_PATH\$NGINX_ORIGINAL_CONFIG_FILE_NAME"
$NGINX_EXEC_PATH = "${NGINX_UNZIP_PATH}\${NGINX_EXEC_NAME}"
$NGINX_STARTER_PS1_PATH = "${NGINX_UNZIP_PATH}\${NGINX_STARTER_PS1_NAME}"
$NGINX_STARTER_EXEC_PATH = "${NGINX_UNZIP_PATH}\${NGINX_STARTER_EXEC_NAME}"
$NGINX_CREATE_CERTIFICATE_PS1_PATH = "${NGINX_UNZIP_PATH}\${NGINX_CREATE_CERTIFICATE_PS1_NAME}"
$NGINX_CREATE_CERTIFICATE_EXEC_PATH = "${NGINX_UNZIP_PATH}\${NGINX_CREATE_CERTIFICATE_EXEC_NAME}"
$NGINX_RENEW_CERTIFICATE_PS1_PATH = "${NGINX_UNZIP_PATH}\${NGINX_RENEW_CERTIFICATE_PS1_NAME}"
$NGINX_RENEW_CERTIFICATE_EXEC_PATH = "${NGINX_UNZIP_PATH}\${NGINX_RENEW_CERTIFICATE_EXEC_NAME}"
$NGINX_URL = "https://nginx.org/download/nginx-${NGINX_VERSION}.zip"

### Notepad variables ###
$NOTEPAD_STARTER_PS1_NAME = "start-notepad.ps1"
$NOTEPAD_STARTER_EXEC_NAME = "start-notepad.bat"

$NOTEPAD_VERSION = "8.7.1"
$NOTEPAD_DIR_NAME = "Notepad"
$NOTEPAD_EXEC_NAME = "notepad++.exe"
$NOTEPAD_UNZIP_NAME = "npp.$NOTEPAD_VERSION.portable.x64"
$NOTEPAD_ZIP_NAME = "$NOTEPAD_UNZIP_NAME.zip"
$NOTEPAD_DIR_PATH = "${TOOLS_DIR_NAME}\${NOTEPAD_DIR_NAME}"
$NOTEPAD_UNZIP_PATH = "${NOTEPAD_DIR_PATH}\${NOTEPAD_UNZIP_NAME}"
$NOTEPAD_ZIP_PATH = "${NOTEPAD_DIR_PATH}\${NOTEPAD_ZIP_NAME}"
$NOTEPAD_EXEC_PATH = "${NOTEPAD_UNZIP_PATH}\${NOTEPAD_EXEC_NAME}"
$NOTEPAD_STARTER_PS1_PATH = "${NOTEPAD_UNZIP_PATH}\${NOTEPAD_STARTER_PS1_NAME}"
$NOTEPAD_STARTER_EXEC_PATH = "${NOTEPAD_UNZIP_PATH}\${NOTEPAD_STARTER_EXEC_NAME}"
$NOTEPAD_URL = "https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.7.1/npp.8.7.1.portable.x64.zip"

### Browser variables ###
$BROWSER_DIR_NAME = "Browser"

### Chromium Browser variables ###
$BROWSER_CHROMIUM_STARTER_PS1_NAME = "start-chromium.ps1"
$BROWSER_CHROMIUM_STARTER_EXEC_NAME = "start-chromium.bat"

$BROWSER_CHROMIUM_DIR_NAME = "Chromium"
$BROWSER_CHROMIUM_EXEC_NAME = "chrome.exe"
$BROWSER_CHROMIUM_UNZIP_NAME = "chrome-win"
$BROWSER_CHROMIUM_PROFILE_DIR_NAME = "Profile"

$BROWSER_CHROMIUM_ZIP_NAME = "${BROWSER_CHROMIUM_UNZIP_NAME}.zip"
$BROWSER_CHROMIUM_DIR_PATH = "${BROWSER_DIR_NAME}\${BROWSER_CHROMIUM_DIR_NAME}"
$BROWSER_CHROMIUM_UNZIP_PATH = "$BROWSER_CHROMIUM_DIR_PATH\$BROWSER_CHROMIUM_UNZIP_NAME"
$BROWSER_CHROMIUM_ZIP_PATH = "$BROWSER_CHROMIUM_DIR_PATH\$BROWSER_CHROMIUM_ZIP_NAME"
$BROWSER_CHROMIUM_EXEC_PATH = "$BROWSER_CHROMIUM_UNZIP_PATH\${BROWSER_CHROMIUM_EXEC_NAME}"
$BROWSER_CHROMIUM_STARTER_PS1_PATH = "$BROWSER_CHROMIUM_UNZIP_PATH\${BROWSER_CHROMIUM_STARTER_PS1_NAME}"
$BROWSER_CHROMIUM_STARTER_EXEC_PATH = "$BROWSER_CHROMIUM_UNZIP_PATH\${BROWSER_CHROMIUM_STARTER_EXEC_NAME}"
$BROWSER_CHROMIUM_URL = "https://download-chromium.appspot.com/dl/Win_x64?type=snapshots"

### Chromium Extension variables ###
$BROWSER_CHROMIUM_EXTENSIONS_DIR_NAME = "Extensions"
$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH = "$BROWSER_CHROMIUM_UNZIP_PATH\$BROWSER_CHROMIUM_EXTENSIONS_DIR_NAME"

# TODO Extention SignumXT should be installed manually by developer mode and add extention from Extentions folder path $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH to be added permanently
### Chromium Signum XT Wallet Extension variables ###
$BROWSER_CHROMIUM_SIGNUM_XT_DIR_NAME = "SignumXT"
$BROWSER_CHROMIUM_SIGNUM_XT_VERSION = "1.5.2"
$BROWSER_CHROMIUM_SIGNUM_XT_ZIP_NAME = "chrome.zip"
$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_INSTALL = $true
$BROWSER_CHROMIUM_SIGNUM_XT_DIR_PATH = "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH\$BROWSER_CHROMIUM_SIGNUM_XT_DIR_NAME"
$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH = "$BROWSER_CHROMIUM_SIGNUM_XT_DIR_PATH\$BROWSER_CHROMIUM_SIGNUM_XT_VERSION"
$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH = "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH\$BROWSER_CHROMIUM_SIGNUM_XT_ZIP_NAME"
$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_URL = "https://github.com/signum-network/signum-xt-wallet/releases/download/${BROWSER_CHROMIUM_SIGNUM_XT_VERSION}/${BROWSER_CHROMIUM_SIGNUM_XT_ZIP_NAME}"

# TODO temporary solution untill /refs/heads/main has issues with build
# $BROWSER_CHROMIUM_SIGNUM_XT_BRANCH_NAME = "main"
$BROWSER_CHROMIUM_SIGNUM_XT_BRANCH_NAME = "8b5fe07253c2ec6acd6beda91402da5fffea0fd4"
$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_NAME = "signum-xt-wallet-${BROWSER_CHROMIUM_SIGNUM_XT_BRANCH_NAME}"
$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_NAME = $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_NAME
$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_NAME = "${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_NAME}.zip"
$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH = "$BROWSER_CHROMIUM_SIGNUM_XT_DIR_PATH\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_NAME"
$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH = "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_NAME"
$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH = "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_NAME"

# TODO introduce the solution to other github downloads
# Regex pattern to check if it's a commit hash (SHA-1)
$commitHashPattern = "^[0-9a-f]{7,40}$"
if ($BROWSER_CHROMIUM_SIGNUM_XT_BRANCH_NAME -match $commitHashPattern) {
    # It's a commit hash
    $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_URL = "https://github.com/signum-network/signum-xt-wallet/archive/${BROWSER_CHROMIUM_SIGNUM_XT_BRANCH_NAME}.zip"
} else {
    # It's a branch name
    $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_URL = "https://github.com/signum-network/signum-xt-wallet/archive/refs/heads/${BROWSER_CHROMIUM_SIGNUM_XT_BRANCH_NAME}.zip"
}

### Certbot variables ###
$CERTBOT_DIR_NAME = "Certbot"

$CERTBOT_STARTER_PS1_NAME = "start-certbot.ps1"
$CERTBOT_STARTER_EXEC_NAME = "start-certbot.bat"

$CERTBOT_WEBROOT_MAP = "html/ssl/letsencrypt"

$CERTBOT_DIR_PATH = "${TOOLS_DIR_NAME}\${CERTBOT_DIR_NAME}"
$CERTBOT_STARTER_PS1_PATH = "${CERTBOT_DIR_PATH}\${CERTBOT_STARTER_PS1_NAME}"
$CERTBOT_STARTER_EXEC_PATH = "${CERTBOT_DIR_PATH}\${CERTBOT_STARTER_EXEC_NAME}"

### Certbot Python variables ###
$CERTBOT_FIRST_SSL_SERVER_NAME = $null

$CERTBOT_CONFIGURATION_RELATIVE_PATH = "CertbotData/config"
$CERTBOT_WORKING_DIR_RELATIVE_PATH = "CertbotData/work"
$CERTBOT_LOGS_DIR_RELATIVE_PATH = "CertbotData/logs"

$CERTBOT_PYTHON_VERSION = "3.13.1"
$CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME = "python310"
$CERTBOT_PYTHON_STANDARD_LIB_ZIP_NAME = "${CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME}.zip"
$CERTBOT_PYTHON_UNZIP_NAME = "python-${CERTBOT_PYTHON_VERSION}-embed-amd64"
$CERTBOT_PYTHON_ZIP_NAME = "${CERTBOT_PYTHON_UNZIP_NAME}.zip"
$CERTBOT_PYTHON_ZIP_PATH = "${CERTBOT_DIR_PATH}\${CERTBOT_PYTHON_ZIP_NAME}"
$CERTBOT_PYTHON_UNZIP_PATH = "${CERTBOT_DIR_PATH}\${CERTBOT_PYTHON_UNZIP_NAME}"
$CERTBOT_PYTHON_URL = "https://www.python.org/ftp/python/${SIGNUM_EXPLORER_TESTNET_PYTHON_VERSION}/python-${SIGNUM_EXPLORER_TESTNET_PYTHON_VERSION}-embed-amd64.zip"
$CERTBOT_PYTHON_GETPIP_URL = "https://bootstrap.pypa.io/get-pip.py"

# TODO change between databases to install
# TODO mark recommended applications

function Show-InstallMenu {
    Clear-Host
    Write-Host "====================================================="
    Write-Host "            Welcome to the Signum Installer          "
    Write-Host "====================================================="
    Write-Host "Please select an option:"
    Write-Host "[1] `tInstall Signum Mainnet with MariaDB"
    Write-Host "[2] `tInstall Signum Testnet with MariaDB"
	# Write-Host "[1] Install Signum Mainnet with PostgreSQL set different ports"
    # Write-Host "[2] Install Signum Testnet with PostgreSQL set different ports"
	# Write-Host "[1] Install Signum Mainnet with SQLite set different ports"
    # Write-Host "[2] Install Signum Testnet with SQLite set different ports"
    Write-Host "[3] `tInstall BTDEX"
    Write-Host "[4] `tInstall Phoenix"
	Write-Host "[5] `tInstall TurboPlotter"
	Write-Host "[6] `tInstall SignumPlotter"
    Write-Host "[7] `tInstall Signum Miner Mainnet"
    Write-Host "[8] `tInstall Signum Miner Testnet"
	# TODO add signum miner
	# TODO add signum pool
	# TODO add signum explorer
    Write-Host "[9] `tInstall Signum Pool Mainnet with MariaDB"
    Write-Host "[10] `tInstall Signum Pool Testnet with MariaDB"
    Write-Host "[11] `tInstall Signum Explorer Mainnet with MariaDB"
    Write-Host "[12] `tInstall Signum Explorer Testnet with MariaDB"
	Write-Host "[13] `tInstall SmartC Signum Smart Contract Compiler [WEB-UI]"
	Write-Host "[14] `tInstall SmartC Signum Smart Contract Compiler [RETRO-UI]"
	Write-Host "[15] `tInstall SmartC Signum Smart Decompiler"
	Write-Host "[16] `tInstall SC Simulator"
	Write-Host "[17] `tInstall Signum-D-OR"
	Write-Host "[18] `tInstall SmartJ Signum Smart Contract Compiler"
	Write-Host "[19] `tInstall SignumArt IPFS-Cluster"
	# Write-Host "====================================================="
	# Write-Host "            		 Databases	 			         "
	# Write-Host "====================================================="
    Write-Host "[20] `tInstall MariaDB"
	# Write-Host "====================================================="
	# Write-Host "            		 Tools	 			             "
	# Write-Host "====================================================="
    Write-Host "[21] `tInstall HeidiSQL"
	Write-Host "[22] `tInstall DBeaver"
    Write-Host "[23] `tInstall NGINX with Certbot"
	Write-Host "[24] `tInstall NodeJS"
	Write-Host "[25] `tInstall Notepad++"
	Write-Host "[26] `tInstall Chromium Browser"
	<# Write-Host "====================================================="
	Write-Host "            	  Developer Tools 			         "
	Write-Host "====================================================="
	Write-Host "[8] `tInstall Signum SmartC Smart Contract Compiler" #>
	# Write-Host "-----------------------------------------------------"
	Write-Host "[27] `tInstall Whitepaper And Documents"
	Write-Host "[28] `tInstall Signum Link Collection"
    Write-Host "-----------------------------------------------------"
	# TODO Signum pages menu
	# TODO add usefull signum pages wiki, official page, github stb. coinmarcetcap, bft portal, explorer
	# Developer menu SmartC SmartJ for smartcontracts
	# Signum provider menu
	# letsencrypt with ACME challege
	# open readme how to use the installer
    Write-Host "[29] `tSignum Starter Menu"
    Write-Host "[30] `tExit"
    Write-Host "====================================================="

	# Write-Host "PowerShell version: $($PSVersionTable.PSVersion)"
    $choice = Read-Host "Enter your choice (1-30)"

	function install-process($file, $name, $installFunction) {
		if (Test-Path $file) {
			Write-Host "${name} already installed."
			question-prompt "Reinstall" $name $installFunction
			Pause
			Show-InstallMenu
		} else {
			question-prompt "Install" $name $installFunction
			Pause
			Show-InstallMenu
		}
	}

    switch ($choice) {
        "1" {
			install-process $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH "Signum Mainnet Node" {Install-SignumMainnet}
        }
        "2" {
			install-process $SIGNUM_NODE_TESTNET_STARTER_PS1_PATH "Signum Testnet Node" {Install-SignumTestnet}
        }
        "3" {
			install-process $BTDEX_EXEC_PATH "BTDEX" {install_btdex}
        }
        "4" {
			install-process $PHOENIX_EXEC_PATH "Phoenix" {install_phoenix}
        }
		"5" {
			install-process $TURBOPLOTTER_EXEC_PATH "TurboPlotter" {install_turboplotter}
        }
		"6" {
			install-process $SIGNUMPLOTTER_EXEC_PATH "SignumPlotter" {install_signumplotter}
        }
		"7" {
			install-process $SIGNUM_MINER_MAINNET_EXEC_PATH "Signum Miner Mainnet" {install_signumminer_mainnet}
        }
		"8" {
			install-process $SIGNUM_MINER_TESTNET_EXEC_PATH "Signum Miner Testnet" {install_signumminer_testnet}
        }
		"9" {
			install-process $SIGNUM_POOL_MAINNET_STARTER_EXEC_PATH "Signum Pool Mainnet" {Install-SignumPoolMainnet}
        }
		"10" {
			install-process $SIGNUM_POOL_TESTNET_STARTER_EXEC_PATH "Signum Pool Testnet" {Install-SignumPoolTestnet}
        }
		"11" {
			install-process $SIGNUM_EXPLORER_MAINNET_STARTER_EXEC_PATH "Signum Explorer Mainnet" {Install-SignumExplorerMainnet}
        }
		"12" {
			install-process $SIGNUM_EXPLORER_TESTNET_STARTER_EXEC_PATH "Signum Explorer Testnet" {Install-SignumExplorerTestnet}
        }
		"13" {
			install-process $SMARTC_WEB_UI_STARTER_EXEC_PATH "SmartC Signum Smart Contract Compiler [WEB-UI]" {install-smartc-web-ui}
        }
		"14" {
			install-process $SMARTC_RETRO_UI_STARTER_EXEC_PATH "SmartC Signum Smart Contract Compiler [RETRO-UI]" {install-smartc-retro-ui}
        }
		"15" {
			install-process $SMARTC_SIGNUM_DECOMPILER_STARTER_EXEC_PATH "SmartC Signum Smart Contract Decompiler" {install-smartc-signum-decompiler}
        }
		"16" {
			install-process $SC_SIMULATOR_STARTER_EXEC_PATH "SC Simulator" {install-sc-simulator}
        }
		"17" {
			install-process $SIGNUM_D_OR_STARTER_EXEC_PATH "Signum-D-OR" {install-signum-d-or}
        }
		"18" {
			install-process $SMARTJ_STARTER_EXEC_PATH "SmartJ Signum Smart Contract Compiler" {install-smartj-compiler}
        }
		"19" {
			install-process $IPFS_CLIENT_STARTER_PS1_PATH "SignumArt IPFS-Cluster" {install_SignumArt_IPFS_CLIENT-Cluster}
        }
        "20" {
			install-process $MARIADB_STARTER_PS1_PATH "MariaDB" {install_mariadb}
        }
        "21" {
			install-process $HEIDISQL_EXEC_PATH "HeidiSQL" {install_heidisql}
        }
		"22" {
			install-process $DBEAVER_EXEC_PATH "DBeaver" {install_DBeaver}
        }
		"23" {
			install-process $NGINX_STARTER_EXEC_PATH "NGINX with Certbot" {install_nginx_and_certbot}
        }
		"24" {
			install-process $NODEJS_EXEC_PATH "NodeJs" {install_nodejs}
        }
		"25" {
			install-process $NOTEPAD_EXEC_PATH "Notepad" {install_notepad}
        }
		"26" {
			install-process $BROWSER_CHROMIUM_EXEC_PATH "Chromium Browser" {install_chromium_browser}
        }
		"27" {
			install-process $WHITEPAPER_DOC_PATH "Whitepaper And Documents" {install-doc}
        }
		"28" {
			install-process $SIGNUM_LINK_COLLECTION_PATH "Signum Link Collection" {install-doc}
        }
        "29" {
            Show-StartMenu
        }
        "30" {
            Exit-Script
        }
        default {
            Write-Host "Invalid choice! Please try again."
            Pause
            Show-InstallMenu
        }
    }
}

function Show-StartMenu {
    Clear-Host
    Write-Host "====================================================="
    Write-Host "                 Start Signum Node                   "
    Write-Host "====================================================="
    Write-Host "Please select an option:"
    Write-Host "[1] `tStart Signum Node Mainnet with MariaDB"
    Write-Host "[2] `tStart Signum Node Testnet with MariaDB"
    Write-Host "[3] `tStart BTDEX"
    Write-Host "[4] `tStart Phoenix"
	Write-Host "[5] `tStart TurboPlotter"
	Write-Host "[6] `tStart SignumPlotter"
	Write-Host "[7] `tStart Signum Miner Mainnet"
	Write-Host "[8] `tStart Signum Miner Testnet"
	Write-Host "[9] `tStart Signum Pool Mainnet"
	Write-Host "[10] `tStart Signum Pool Testnet"
	Write-Host "[11] `tStart Signum Explorer Mainnet"
	Write-Host "[12] `tStart Signum Explorer Testnet"
	Write-Host "[13] `tStart SmartC Signum Smart Contract [WEB-UI]"
	Write-Host "[14] `tStart SmartC Signum Smart Contract [RETRO-UI]"
	Write-Host "[15] `tStart SmartC Signum Smart Contract Decompiler"
	Write-Host "[16] `tStart SC Simulator"
	Write-Host "[17] `tStart Signum-D-OR"
	Write-Host "[18] `tStart SmartJ Signum Smart Contract Compiler"
	Write-Host "[19] `tStart SignumArt IPFS-Cluster"
    Write-Host "[20] `tStart MariaDB"
    Write-Host "[21] `tStart HeidiSQL"
	Write-Host "[22] `tStart DBeaver"
	Write-Host "[23] `tStart NGINX with Certbot"
	Write-Host "[24] `tStart NodeJS"
	Write-Host "[25] `tStart Notepad++"
	Write-Host "[26] `tStart Chromium Browser"
	Write-Host "[27] `tOpen Whitepaper"
	Write-Host "[28] `tOpen Signum Link Collection"
    Write-Host "-----------------------------------------------------"
    Write-Host "[29] `tSignum Installer Menu"
    Write-Host "[30] `tExit"
    Write-Host "====================================================="

    $choice = Read-Host "Enter your choice (1-30)"

	function start-process-menu($file, $name, $installFunction) {
		if (Test-Path $file) {
			Write-Host "Starting ${name} ..."
			# Start-Process -FilePath $file $command
			& $POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "$file"
			# Start-Process -FilePath $POWERSHELL_EXEC_PATH -ArgumentList "-ExecutionPolicy Bypass", "-File", $file
			Pause
			Show-StartMenu
		} else {
			Write-Host "${name} is not installed, please install first!"
			question-prompt "Install" $name $installFunction
			Pause
			Show-StartMenu
		}
	}
	
	function open-doc-menu($file, $name, $installFunction) {
		if (Test-Path $file) {
			Write-Host "Opening ${name} ..."
			# Start-Process -FilePath $file $command
			Start-Process -FilePath "$file"
			# Start-Process -FilePath $POWERSHELL_EXEC_PATH -ArgumentList "-ExecutionPolicy Bypass", "-File", $file
			Pause
			Show-StartMenu
		} else {
			Write-Host "${name} is not downloaded, please download first!"
			question-prompt "Download" $name $installFunction
			Pause
			Show-StartMenu
		}
	}

    switch ($choice) {
        "1" {
			start-process-menu $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH "Signum Node Mainnet" {Install-SignumMainnet} 
        }
        "2" {
			start-process-menu $SIGNUM_NODE_TESTNET_STARTER_PS1_PATH "Signum Node Testnet" {Install-SignumTestnet}
        }
        "3" {
			start-process-menu $BTDEX_STARTER_PS1_PATH "BTDEX" {install_btdex}
		}
        "4" {
			start-process-menu $PHOENIX_STARTER_PS1_PATH "Phoenix" {install_phoenix}
        }
		"5" {
			start-process-menu $TURBOPLOTTER_STARTER_PS1_PATH "TurboPlotter" {install_turboplotter}
        }
		"6" {
			start-process-menu $SIGNUMPLOTTER_STARTER_PS1_PATH "SignumPlotter" {install_signumplotter}
        }
		"7" {
			start-process-menu $SIGNUM_MINER_MAINNET_STARTER_PS1_PATH "Signum Miner Mainnet" {install_signumminer_mainnet}
        }
		"8" {
			start-process-menu $SIGNUM_MINER_TESTNET_STARTER_PS1_PATH "Signum Miner Testnet" {install_signumminer_testnet}
        }
		"9" {
			start-process-menu $SIGNUM_POOL_MAINNET_STARTER_PS1_PATH "Signum Pool Mainnet" {Install-SignumPoolMainnet}
        }
		"10" {
			start-process-menu $SIGNUM_POOL_TESTNET_STARTER_PS1_PATH "Signum Pool Testnet" {Install-SignumPoolTestnet}
        }
		"11" {
			start-process-menu $SIGNUM_EXPLORER_MAINNET_STARTER_PS1_PATH "Signum Explorer Mainnet" {Install-SignumExplorerMainnet}
        }
		"12" {
			start-process-menu $SIGNUM_EXPLORER_TESTNET_STARTER_PS1_PATH "Signum Explorer Testnet" {Install-SignumExplorerTestnet}
        }
		"13" {
			start-process-menu $SMARTC_WEB_UI_STARTER_PS1_PATH "SmartC Signum Smart Contract Compiler [WEB-UI]" {install-smartc-web-ui}
        }
		"14" {
			start-process-menu $SMARTC_RETRO_UI_STARTER_PS1_PATH "SmartC Signum Smart Contract Compiler [RETRO-UI]" {install-smartc-retro-ui}
        }
		"15" {
			start-process-menu $SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_PATH "SmartC Signum Signum Smart Contract Decompiler" {install-smartc-signum-decompiler}
        }
		"16" {
			start-process-menu $SC_SIMULATOR_STARTER_PS1_PATH "SC Simulator" {install-sc-simulator}
        }
		"17" {
			start-process-menu $SIGNUM_D_OR_STARTER_PS1_PATH "Signum-D-OR" {install-signum-d-or}
        }
		"18" {
			start-process-menu $SMARTJ_STARTER_PS1_PATH "SmartJ Signum Smart Contract Compiler" {install-smartj-compiler}
        }
		"19" {
			start-process-menu $IPFS_SIGNUMART_STARTER_PS1_PATH "SignumArt IPFS-Cluster" {install_SignumArt_IPFS_CLIENT-Cluster}
        }
        "20" {
			start-process-menu $MARIADB_STARTER_PS1_PATH "MariaDB" {install_mariadb}
        }
        "21" {
			start-process-menu $HEIDISQL_STARTER_PS1_PATH "HeidiSQL" {install_heidisql}
		}
		"22" {
			start-process-menu $DBEAVER_STARTER_PS1_PATH "DBeaver" {install_DBeaver}
        }
		"23" {
			start-process-menu $NGINX_STARTER_PS1_PATH "NGINX with Certbot" {install_nginx_and_certbot}
        }
		"24" {
			start-process-menu $NODEJS_STARTER_PS1_PATH "NodeJs" {install_nodejs}
        }
		"25" {
			start-process-menu $NOTEPAD_STARTER_PS1_PATH "Notepad" {install_notepad}
        }
		"26" {
			start-process-menu $BROWSER_CHROMIUM_STARTER_PS1_PATH "Chromium Browser" {install_chromium_browser}
        }
		"27" {
            open-doc-menu $WHITEPAPER_DOC_PATH "Whitepaper" {install-doc}
		}
		"28" {
            open-doc-menu $SIGNUM_LINK_COLLECTION_PATH "Signum Link Collection" {install-doc}
		}
        "29" {
            Show-InstallMenu
        }
        "30" {
            Exit-Script
        }
        default {
            Write-Host "Invalid choice! Please try again."
            Pause
            Show-StartMenu
        }
    }
}

function Exit-Script {
    Write-Host "Press any key to exit Signum Installer. Goodbye!"
    Pause
    Exit
}

# TODO check for one answer and select configuration with default values, or make configuration steps
# TODO Would You like to setup configuration, or use default configuration?

function install-doc-init {
	
	# Create directory
    if (-not (Test-Path -Path $DOCUMENTS_DIR)) {
		New-Item -Path "$DOCUMENTS_DIR" -ItemType Directory | Out-Null
	} else {
		Write-Host "$DOCUMENTS_DIR already exists."
	}
	
	$content = 
@"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signum Cryptocurrency Resources</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            text-align: center;
        }
        .section {
            margin-bottom: 20px;
        }
        .section h2 {
            border-bottom: 2px solid #000;
            padding-bottom: 5px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li {
            margin: 5px 0;
        }
        a {
            color: #007BFF;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Signum Cryptocurrency Resources</h1>
    
    <div class="section">
        <h2>Documentation & Development</h2>
        <ul>
            <li><a href="https://github.com/deleterium/SmartC/blob/v2.1/docs%2FREADME.md">SmartC README</a></li>
            <li><a href="https://docs.signum.network/ecosystem/resources-for-developers">Developer Resources</a></li>
            <li><a href="https://wiki.signum.network/signum-software/index.htm">Signum Software Wiki</a></li>
            <li><a href="https://github.com/signum-network/signumj">SignumJ GitHub</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Research & Papers</h2>
        <ul>
            <li><a href="https://www.signum.network/wp/Signum_Business_Whitepaper.pdf">Signum Business Whitepaper</a></li>
            <li><a href="https://indecs.eu/2024/indecs2024-pp738-762.pdf">Blockchain for IoT Devices</a></li>
            <li><a href="https://www.whitehouse.gov/wp-content/uploads/2022/09/09-2022-Crypto-Assets-and-Climate-Report.pdf">Crypto-Assets and Climate Report</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Community & Social Media</h2>
        <ul>
            <li><a href="https://discord.com/invite/QHZkF4KHDS">Signum Discord</a></li>
            <li><a href="https://x.com/signum_official">Signum X</a></li>
            <li><a href="https://t.me/signumnetwork">Signum Network Telegram</a></li>
            <li><a href="https://t.me/Signum_Russia">Signum Russia Telegram</a></li>
            <li><a href="https://t.me/signumchain">Signum Chain Telegram</a></li>
            <li><a href="https://t.me/Signum_HK">Signum HK Telegram</a></li>
            <li><a href="https://t.me/signa_holders">Signa Holders Telegram</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Tools & Services</h2>
        <ul>
            <li><a href="https://miningpoolstats.stream/signa">Mining Pool Stats</a></li>
            <li><a href="http://ciyam.org/at/">CIYAM AT</a></li>
            <li><a href="https://signum.dappository.world/">Signum Dappository</a></li>
            <li><a href="https://signum-neo-node.pages.dev/">Signum Neo Node</a></li>
            <li><a href="https://docs.signum.network/signumswap/add-a-customised-icon">SignumSwap Custom Icon</a></li>
            <li><a href="https://explorer.signum.network/">Signum Explorer</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>External Resources</h2>
        <ul>
            <li><a href="https://coindar.org/en/coin/signum">Coindar Signum</a></li>
            <li><a href="https://bitcointalk.org/index.php?action=profile;u=364787">BitcoinTalk Profile</a></li>
            <li><a href="https://xeggex.com/market/SIGNA_BTC">Xeggex Market SIGNA/BTC</a></li>
            <li><a href="https://fomplo.com/signum-subscriptions">Signum Subscriptions</a></li>
            <li><a href="https://signum.network/">Signum Network</a></li>
            <li><a href="https://www.signumart.io/">NFT Portal</a></li>
        </ul>
    </div>
</body>
</html>
"@
	
	# Create Signum link collection page
	if (-not (Test-Path $SIGNUM_LINK_COLLECTION_PATH)) {
		
		# Create Signum-Link-Collection.html file with the desired content
		$content | Out-File -FilePath $SIGNUM_LINK_COLLECTION_PATH -Force
		Write-Host "${SIGNUM_LINK_COLLECTION_PATH} successfully created."
		
	} else {
		
		Write-Host "File already exists: ${SIGNUM_LINK_COLLECTION_PATH}"
		$fileContent = Get-Content -Path $SIGNUM_LINK_COLLECTION_PATH -Raw
		# Compare the content
		
		if ($fileContent.TrimEnd() -eq $content.TrimEnd()) {
			
			Write-Output "The contents are the same."
			
		} else {
			
			Write-Output "The contents are different."
			Write-Output "Update $SIGNUM_LINK_COLLECTION."
			$content | Out-File -FilePath $SIGNUM_LINK_COLLECTION_PATH -Force
			
		}
	}
	
	if (-not (Test-Path -Path $WHITEPAPER_DOC_PATH)) {
		Write-Host "Downloading $WHITEPAPER_DOC_NAME"
		Invoke-WebRequest -Uri $WHITEPAPER_URL -OutFile $WHITEPAPER_DOC_PATH
	} else {
		Write-Host "$WHITEPAPER_DOC_PATH already exists."
	}
	
	if (-not (Test-Path -Path $WHITEHOUSE_DOC_PATH)) {
		Write-Host "Downloading $WHITEHOUSE_DOC_NAME"
		Invoke-WebRequest -Uri $WHITEHOUSE_URL -OutFile $WHITEHOUSE_DOC_PATH
	} else {
		Write-Host "$WHITEHOUSE_DOC_PATH already exists."
	}
	
	if (-not (Test-Path -Path $INDECS_DOC_PATH)) {
		Write-Host "Downloading $INDECS_DOC_NAME"
		Invoke-WebRequest -Uri $INDECS_URL -OutFile $INDECS_DOC_PATH
	} else {
		Write-Host "$INDECS_DOC_PATH already exists."
	}

	Write-Host "Documents downloaded successfully"
	
}

function install-doc {
	
	install-doc-init

	Pause
	Show-InstallMenu
	
}

function Install-SignumMainnet {
    Write-Host "Installing Signum Mainnet ..."

    # Create mainnet/testnet directory
    if (-not (Test-Path -Path "${SIGNUM_NODE_MAINNET_DIR_PATH}")) {
        New-Item -Path "${SIGNUM_NODE_MAINNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_NODE_MAINNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_NODE_MAINNET_DIR_PATH}"
    }

    if (Test-Path -Path "${SIGNUM_NODE_MAINNET_DIR_PATH}\${SIGNUM_NODE_MAINNET_ZIP_NAME}") {
        Write-Host "${SIGNUM_NODE_MAINNET_ZIP_NAME} already downloaded."
    } else {
        # Download the Signum mainnet zip file
        Write-Host "Downloading Signum from GitHub ..."
        # Start-BitsTransfer -Source "${SIGNUM_NODE_MAINNET_URL}" -Destination "${SIGNUM_NODE_MAINNET_DIR_PATH}\${SIGNUM_NODE_MAINNET_ZIP_NAME}"
		Invoke-WebRequest -Uri ${SIGNUM_NODE_MAINNET_URL} -OutFile ${SIGNUM_NODE_MAINNET_DIR_PATH}\${SIGNUM_NODE_MAINNET_ZIP_NAME}

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_NODE_MAINNET_DIR_PATH}\${SIGNUM_NODE_MAINNET_ZIP_NAME}")) {
            Write-Host "Error: Failed to download Signum."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "$SIGNUM_NODE_MAINNET_UNZIP_PATH") {
        Write-Host "${SIGNUM_NODE_MAINNET_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to $SIGNUM_NODE_MAINNET_UNZIP_PATH ..."
        Expand-Archive -Path "${SIGNUM_NODE_MAINNET_DIR_PATH}\${SIGNUM_NODE_MAINNET_ZIP_NAME}" -DestinationPath "$SIGNUM_NODE_MAINNET_UNZIP_PATH" -Force
    }

	if (Test-Path -Path "${SIGNUM_NODE_MAINNET_PROPERTIES_PATH}") {
        Write-Host "${SIGNUM_NODE_MAINNET_PROPERTIES_PATH} already exists."
    } else {
        # Copy node-default.properties to node.properties
		Write-Host "Copying ${SIGNUM_NODE_MAINNET_DEFAULT_PROPERTIES_PATH} to ${SIGNUM_NODE_MAINNET_PROPERTIES_PATH} ..."
		Copy-Item -Path "${SIGNUM_NODE_MAINNET_DEFAULT_PROPERTIES_PATH}" -Destination "${SIGNUM_NODE_MAINNET_PROPERTIES_PATH}"
	}
	
<# #this true by default	
	# Add node.indirectIncomingService.enable = true propertie
	$content = Get-Content -Path $SIGNUM_NODE_MAINNET_PROPERTIES_PATH
	
	$content = $content | ForEach-Object {
        if ($_ -match "node.indirectIncomingService.enable = true") {
            $matchFound = $true
            Write-Host "node.indirectIncomingService.enable = true already set"
		}
    }

    if (-not $matchFound) {
        Write-Host "Add inode.indirectIncomingService.enable = true to node.properties"
        $content += "node.indirectIncomingService.enable = true"
    }

	# Write the updated content back to the file
	Set-Content -Path $SIGNUM_NODE_MAINNET_PROPERTIES_PATH -Value $content
#>
<#
	# Install NeoClassic wallet
	Write-Host "Install NeoClassic wallet."
	if (-not (Test-Path -Path "${SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH}")) {
        New-Item -Path "${SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH}"
    }
#>
	
	# Insall Signum NeoClassic Wallet if not installed yet
	if (Test-Path $SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH) {
		Write-Host "Signum NeoClassic Wallet already installed."
		question-prompt "Reinstall" "NeoClassic Wallet" {Install-NeoClassic-MAINNET-Wallet}
	} else {
		Write-Host "Signum NeoClassic Wallet is not yet installed."
		question-prompt "Install" "NeoClassic Wallet" {Install-NeoClassic-MAINNET-Wallet}
		# Pause
	}

    # Create starter ps1
    signum-starter-ps1 "Mainnet" ${SIGNUM_NODE_MAINNET_STARTER_PS1_PATH} $SIGNUM_NODE_MAINNET_API_PORT
	
	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_NODE_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_NODE_STARTER_EXEC_NAME} ${SIGNUM_NODE_MAINNET_STARTER_EXEC_PATH}

    # Install MariaDB
	if (Test-Path $MARIADB_STARTER_PS1_PATH) {
        Write-Host "MariaDB already installed!"
		question-prompt "Reinstall" "MariaDB" {install_mariadb}
    } else {
		Write-Host "MariaDB is not yet installed."
		question-prompt "Install" "MariaDB" {install_mariadb}
	}

    # Setup MariaDB for Mainnet
	question-prompt "Setup" "MariaDB for Signum Mainnet Node" {setup_mariadb "Signum Node Mainnet" "signum-node-mainnet" "signumuser_node_mainnet" "signumpassword"}
	
	if ($global:UserResponse -eq "yes") {	
		# Update database information in node.properties
		setup_db_node_properties ${SIGNUM_NODE_MAINNET_PROPERTIES_PATH}
	}

	# TODO Create start-node-v8.2.0-mariadb-v10.20.0.bat in root to start specific versions
	# TODO start-node-node.bat should be bat and start-mariadb.bat should be bat as well and OS spacific or ps1 + ps1 executer bat
	
	# Question prompt check if installed

    Write-Host "Signum Mainnet Node Installation complete."
    # Pause
<#
    if (-not (Test-Path -Path "${SIGNUM_NODE_TESTNET_STARTER_PS1_PATH}")) {
        question-prompt "Install" "Signum Node Testnet" Install-SignumTestnet
    }
#>
}

function Install-NeoClassic-MAINNET-Wallet {
	
	# Download NeoClassic
    if (Test-Path -Path "${SIGNUM_WALLET_MAINNET_NEOCLASSIC_ZIP_PATH}") {
        Write-Host "${SIGNUM_WALLET_NEOCLASSIC_ZIP_NAME} already downloaded."
    } else {
        # Download the Signum mainnet zip file
        Write-Host "Downloading Signum NeoClassic Wallet from GitHub ..."
		Invoke-WebRequest -Uri $SIGNUM_WALLET_MAINNET_NEOCLASSIC_URL -OutFile $SIGNUM_WALLET_MAINNET_NEOCLASSIC_ZIP_PATH
		
        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_WALLET_MAINNET_NEOCLASSIC_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum NeoClassic Wallet."
            Pause
            # Install-Menu
            # return
        }
    }
	
	# Unzip NeoClassic
	if (Test-Path -Path "${SIGNUM_WALLET_MAINNET_NEOCLASSIC_UNZIP_PATH}\src") {
        Write-Host "Signum NeoClassic Wallet already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum NeoClassic Wallet to ${SIGNUM_WALLET_MAINNET_UI_DIR_PATH} ..."
        Expand-Archive -Path "${SIGNUM_WALLET_MAINNET_NEOCLASSIC_ZIP_PATH}" -DestinationPath "${SIGNUM_WALLET_MAINNET_UI_DIR_PATH}\${SIGNUM_WALLET_NEOCLASSIC_DIR_NAME}" -Force
	
		# Setup index.html
		Write-Host "Setup index.html"
		
		# Check index.html if NeoClassic is added
		$foundNeoClassic = $false
		$content = Get-Content -Path ${SIGNUM_WALLET_MAINNET_UI_DIR_PATH}\index.html
		
		$content = $content | ForEach-Object {
			if ($_ -match $SIGNUM_WALLET_NEOCLASSIC_DIR_NAME) {
				$foundNeoClassic = $true
				Write-Host "index.html setup is ready"
			}
		}
		
		if (-not $foundNeoClassic) {
			$content = Get-Content -Path ${SIGNUM_WALLET_MAINNET_UI_DIR_PATH}\index.html
			
			# Define the HTML content to insert
			$newLine = 
@"
		<a class="card" id="neoclassic-link" href="./${SIGNUM_WALLET_NEOCLASSIC_DIR_NAME}/index.html" onclick="selectedWallet('neoclassic')">
			<div class="center-text">
				<img src="./assets/signum-logomark-white.svg">
				<h2 class="card__title">NeoClassic</h2>
			</div>
		</a>
"@
			
			for ($i = 0; $i -lt $content.Count; $i++) {

				# Get the current line
				$line = $content[$i]

				if ($line -match '^\s*</div>') {
					if ($content[$i+1] -match "^\s*</a>") {
						# Insert the new line after $content[$i+1]
						$content = $content[0..($i+1)] + $newLine + $content[($i+2)..($content.Count - 1)]
						break
					}
				}
			}

			# Write the changes back to the file
			$content | Set-Content -Path ${SIGNUM_WALLET_MAINNET_UI_DIR_PATH}\index.html
		}
	}
}

function Install-NeoClassic-TESTNET-Wallet {
	
	# Download NeoClassic
    if (Test-Path -Path "${SIGNUM_WALLET_TESTNET_NEOCLASSIC_ZIP_PATH}") {
        Write-Host "${SIGNUM_WALLET_NEOCLASSIC_ZIP_NAME} already downloaded."
    } else {
        # Download the Signum mainnet zip file
        Write-Host "Downloading Signum NeoClassic Wallet from GitHub ..."
		Invoke-WebRequest -Uri $SIGNUM_WALLET_TESTNET_NEOCLASSIC_URL -OutFile $SIGNUM_WALLET_TESTNET_NEOCLASSIC_ZIP_PATH
		
        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_WALLET_TESTNET_NEOCLASSIC_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum NeoClassic Wallet."
            Pause
            # Install-Menu
            # return
        }
    }
	
	# Unzip NeoClassic
	if (Test-Path -Path "${SIGNUM_WALLET_TESTNET_NEOCLASSIC_UNZIP_PATH}\src") {
        Write-Host "Signum NeoClassic Wallet already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum NeoClassic Wallet to ${SIGNUM_WALLET_TESTNET_UI_DIR_PATH} ..."
        Expand-Archive -Path "${SIGNUM_WALLET_TESTNET_NEOCLASSIC_ZIP_PATH}" -DestinationPath "${SIGNUM_WALLET_TESTNET_UI_DIR_PATH}\${SIGNUM_WALLET_NEOCLASSIC_DIR_NAME}" -Force
	
		# Setup index.html
		Write-Host "Setup index.html"
		
		# Check index.html if NeoClassic is added
		$foundNeoClassic = $false
		$content = Get-Content -Path ${SIGNUM_WALLET_TESTNET_UI_DIR_PATH}\index.html
		
		$content = $content | ForEach-Object {
			if ($_ -match $SIGNUM_WALLET_NEOCLASSIC_DIR_NAME) {
				$foundNeoClassic = $true
				Write-Host "index.html setup is ready"
			}
		}
		
		if (-not $foundNeoClassic) {
			$content = Get-Content -Path ${SIGNUM_WALLET_TESTNET_UI_DIR_PATH}\index.html
			
			# Define the HTML content to insert
			$newLine = 
@"
		<a class="card" id="neoclassic-link" href="./${SIGNUM_WALLET_NEOCLASSIC_DIR_NAME}/index.html" onclick="selectedWallet('neoclassic')">
			<div class="center-text">
				<img src="./assets/signum-logomark-white.svg">
				<h2 class="card__title">NeoClassic</h2>
			</div>
		</a>
"@
			
			for ($i = 0; $i -lt $content.Count; $i++) {

				# Get the current line
				$line = $content[$i]

				if ($line -match '^\s*</div>') {
					if ($content[$i+1] -match "^\s*</a>") {
						# Insert the new line after $content[$i+1]
						$content = $content[0..($i+1)] + $newLine + $content[($i+2)..($content.Count - 1)]
						break
					}
				}
			}

			# Write the changes back to the file
			$content | Set-Content -Path ${SIGNUM_WALLET_TESTNET_UI_DIR_PATH}\index.html
		}
	}
}

function Install-SignumTestnet {
    Write-Host "Installing Signum Testnet ..."

    # Create mainnet/testnet directory
    if (-not (Test-Path -Path "${SIGNUM_NODE_TESTNET_DIR_PATH}")) {
        New-Item -Path "${SIGNUM_NODE_TESTNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_NODE_TESTNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_NODE_TESTNET_DIR_PATH}"
    }

    if (Test-Path -Path "${SIGNUM_NODE_TESTNET_DIR_PATH}\${SIGNUM_NODE_TESTNET_ZIP_NAME}") {
        Write-Host "${SIGNUM_NODE_TESTNET_ZIP_NAME} already downloaded."
    } else {
        # Download the Signum testnet zip file
        Write-Host "Downloading Signum from GitHub ..."
		# TODO try out Invoke-WebRequest or System.Net.Http.HttpClient
        # Start-BitsTransfer -Source "${SIGNUM_NODE_TESTNET_URL}" -Destination "${SIGNUM_NODE_TESTNET_DIR_PATH}\${SIGNUM_NODE_TESTNET_ZIP_NAME}"
		Invoke-WebRequest -Uri $SIGNUM_NODE_TESTNET_URL -OutFile ${SIGNUM_NODE_TESTNET_DIR_PATH}\${SIGNUM_NODE_TESTNET_ZIP_NAME}

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_NODE_TESTNET_DIR_PATH}\${SIGNUM_NODE_TESTNET_ZIP_NAME}")) {
            Write-Host "Error: Failed to download Signum."
            Exit
        }
    }

    if (Test-Path -Path "$SIGNUM_NODE_TESTNET_UNZIP_PATH") {
        Write-Host "${SIGNUM_NODE_TESTNET_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to $SIGNUM_NODE_TESTNET_UNZIP_PATH ..."
        Expand-Archive -Path "${SIGNUM_NODE_TESTNET_DIR_PATH}\${SIGNUM_NODE_TESTNET_ZIP_NAME}" -DestinationPath "$SIGNUM_NODE_TESTNET_UNZIP_PATH" -Force
    }

	if (Test-Path -Path "${SIGNUM_NODE_TESTNET_PROPERTIES_PATH}") {
        Write-Host "${SIGNUM_NODE_TESTNET_PROPERTIES_PATH} already exists."
    } else {
        # Copy node-default.properties to node.properties
		Write-Host "Copying ${SIGNUM_NODE_TESTNET_DEFAULT_PROPERTIES_PATH} to ${SIGNUM_NODE_TESTNET_PROPERTIES_PATH} ..."
		Copy-Item -Path "${SIGNUM_NODE_TESTNET_DEFAULT_PROPERTIES_PATH}" -Destination "${SIGNUM_NODE_TESTNET_PROPERTIES_PATH}"
	}


    # Update node.properties with new database information
    Write-Host "Updating ${SIGNUM_NODE_TESTNET_PROPERTIES_PATH} with Testnet configurations ..."
    (Get-Content -Path $SIGNUM_NODE_TESTNET_PROPERTIES_PATH) -replace '# node.network = signum.net.TestnetNetwork', 'node.network = signum.net.TestnetNetwork' | Set-Content -Path $SIGNUM_NODE_TESTNET_PROPERTIES_PATH
	
<# #this true by default
	# Add node.indirectIncomingService.enable = true propertie
	$content = Get-Content -Path $SIGNUM_NODE_TESTNET_PROPERTIES_PATH
	
	$content = $content | ForEach-Object {
        if ($_ -match "node.indirectIncomingService.enable = true") {
            $matchFound = $true
            Write-Host "node.indirectIncomingService.enable = true already set"
		}
    }

    if (-not $matchFound) {
        Write-Host "Add node.indirectIncomingService.enable = true to node.properties"
        $content += "node.indirectIncomingService.enable = true"
    }

	# Write the updated content back to the file
	Set-Content -Path $SIGNUM_NODE_TESTNET_PROPERTIES_PATH -Value $content
#>

    Write-Host "Update complete."
	
	# Insall Signum NeoClassic Wallet if not installed yet
	if (Test-Path $SIGNUM_WALLET_TESTNET_NEOCLASSIC_UNZIP_PATH) {
		Write-Host "Signum NeoClassic Wallet already installed."
		question-prompt "Reinstall" "NeoClassic Wallet" {Install-NeoClassic-TESTNET-Wallet}
	} else {
		Write-Host "Signum NeoClassic Wallet is not yet installed."
		question-prompt "Install" "NeoClassic Wallet" {Install-NeoClassic-TESTNET-Wallet}
		# Pause
	}

    # Install Signum Testnet starter batch
    signum-starter-ps1 "Testnet" ${SIGNUM_NODE_TESTNET_STARTER_PS1_PATH} $SIGNUM_NODE_TESTNET_API_PORT
	
	# OS dependent start-node
	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_NODE_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_NODE_STARTER_EXEC_NAME} ${SIGNUM_NODE_TESTNET_STARTER_EXEC_PATH}

    # Install MariaDB
	if (Test-Path $MARIADB_STARTER_PS1_PATH) {
        Write-Host "MariaDB already installed!"
		question-prompt "Reinstall" "MariaDB" {install_mariadb}
    } else {
		Write-Host "MariaDB is not yet installed."
		question-prompt "Install" "MariaDB" {install_mariadb}
	}

    # Setup MariaDB for Testnet
    question-prompt "Setup" "MariaDB for Signum Testnet Node" {setup_mariadb "Signum Node Testnet" "signum-node-testnet" "signumuser_node_testnet" "signumpassword"}
	
	# Update database information in node.properties
	setup_db_node_properties ${SIGNUM_NODE_TESTNET_PROPERTIES_PATH}

    Write-Host "Signum Testnet Node Installation complete."
    # Pause

<#
    if (-not (Test-Path -Path "${SIGNUM_NODE_MAINNET_STARTER_PS1_PATH}")) {
        question-prompt "Install" "Signum Node Mainnet" {Install-SignumMainnet}
    }
#>
}

function Install-SignumPoolMainnet {
    Write-Host "Installing Signum Pool Mainnet ..."

	# install-process $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH "Signum Mainnet" {Install-SignumMainnet}

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }

    # Create Pool directory
    if (-not (Test-Path -Path "${SIGNUM_POOL_MAINNET_DIR_PATH}")) {
        New-Item -Path "${SIGNUM_POOL_MAINNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_POOL_MAINNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_POOL_MAINNET_DIR_PATH}"
    }

    if (Test-Path -Path "${SIGNUM_POOL_MAINNET_ZIP_PATH}") {
        Write-Host "${SIGNUM_POOL_MAINNET_ZIP_PATH} already downloaded."
    } else {
        # Download the Signum Pool Mainnet zip file
        Write-Host "Downloading Signum Pool from GitHub ..."
        # Start-BitsTransfer -Source "${SIGNUM_POOL_MAINNET_URL}" -Destination "${SIGNUM_POOL_MAINNET_ZIP_PATH}"
		Invoke-WebRequest -Uri $SIGNUM_POOL_MAINNET_URL -OutFile $SIGNUM_POOL_MAINNET_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_POOL_MAINNET_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum Pool."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SIGNUM_POOL_MAINNET_UNZIP_PATH}") {
        Write-Host "${SIGNUM_POOL_MAINNET_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SIGNUM_POOL_MAINNET_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_POOL_MAINNET_ZIP_PATH}" -DestinationPath "${SIGNUM_POOL_MAINNET_DIR_PATH}" -Force
    }
	
	# Create jre directory
    if (-not (Test-Path -Path "${JAVA_POOL_MAINNET_DIR_PATH}")) {
        New-Item -Path "${JAVA_POOL_MAINNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${JAVA_POOL_MAINNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${JAVA_POOL_MAINNET_DIR_PATH}"
    }
	
	# download java
	if (Test-Path -Path "${JAVA_POOL_MAINNET_ZIP_PATH}") {
        Write-Host "${JAVA_POOL_MAINNET_ZIP_PATH} already downloaded."
    } else {
        # Download Java zip file
        Write-Host "Downloading Java ..."
        # Start-BitsTransfer -Source "${JAVA_POOL_MAINNET_URL}" -Destination "${JAVA_POOL_MAINNET_ZIP_PATH}"
		Invoke-WebRequest -Uri $JAVA_POOL_MAINNET_URL -OutFile $JAVA_POOL_MAINNET_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${JAVA_POOL_MAINNET_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum Pool."
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip java
	if (Test-Path -Path "${JAVA_POOL_MAINNET_UNZIP_PATH}") {
        Write-Host "${JAVA_POOL_MAINNET_ZIP_PATH} already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Java to ${JAVA_POOL_MAINNET_UNZIP_PATH} ..."
        Expand-Archive -Path "${JAVA_POOL_MAINNET_ZIP_PATH}" -DestinationPath "${JAVA_POOL_MAINNET_DIR_PATH}" -Force
    }
	
	# Copy poopl.properties to pool-original.properties
	Write-Host "Copying ${SIGNUM_POOL_MAINNET_PROPERTIES_PATH} to ${SIGNUM_POOL_MAINNET_PROPERTIES_ORIGINAL_PATH} ..."
    Copy-Item -Path "${SIGNUM_POOL_MAINNET_PROPERTIES_PATH}" -Destination "${SIGNUM_POOL_MAINNET_PROPERTIES_ORIGINAL_PATH}"

	# Create starter ps1
	if (-not (Test-Path $SIGNUM_POOL_MAINNET_STARTER_PS1_PATH)) {
		# Create start-pool.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Signum Node
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting MariaDB ...'

# Start MariaDB
..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$MARIADB_STARTER_PS1_PATH" "-WindowStyle Minimized"
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-ExecutionPolicy Bypass", "-File", "..\..\..\$MARIADB_STARTER_PS1_PATH" -WindowStyle Minimized

Write-Host 'Starting Signum Node Mainnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$SIGNUM_NODE_MAINNET_STARTER_PS1_PATH" "-WindowStyle Minimized"

Write-Host 'Starting Signum Pool Mainnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

# Start Signum Pool
# Start-Process -FilePath ".\${JAVA_POOL_MAINNET_DIR_NAME}\${JAVA_POOL_MAINNET_UNZIP_NAME}\bin\java.exe" -ArgumentList "-jar", "signum-pool.jar" -WindowStyle Minimized
# Last OK
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'Signum Pool Mainnet'; .\${JAVA_POOL_MAINNET_DIR_NAME}\${JAVA_POOL_MAINNET_UNZIP_NAME}\bin\java.exe -jar signum-pool.jar"

Write-Host 'Starting Signum Pool Mainnet ...'
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'Signum Pool Mainnet'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SIGNUM_POOL_MAINET_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'Signum Pool Mainnet is already running.'
			exit
		} else {
			# Start Signum Pool Mainnet
			# Start-Process "http://localhost:$SIGNUM_POOL_MAINET_PORT"
			try {
				Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SIGNUM_POOL_MAINET_PORT"
			} catch {
        		Write-Host 'An error occurred while starting Browser' -ForegroundColor Red
    		}
			.\${JAVA_POOL_MAINNET_DIR_NAME}\${JAVA_POOL_MAINNET_UNZIP_NAME}\bin\java.exe -jar signum-pool.jar
		}
    } catch {
        Write-Host 'An error occurred while starting Signum Pool Mainnet' -ForegroundColor Red
    } finally {
        # Always set the title to 'Signum Pool Mainnet Stopped' after Signum Pool Mainnet exits
        ```$host.UI.RawUI.WindowTitle = 'Signum Pool Mainnet Stopped'
    }
"`@ ``
    -WindowStyle Minimized

# TODO check
# & ..\..\..\$POWERSHELL_EXEC_PATH -NoExit -Command .\jre\bin\java -jar signum-node.jar -WindowStyle Minimized
# "jre\bin\java" "-jar" "signum-node.jar" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "Set-Title 'Signum Mainnet Node'; Start-Process -NoNewWindow -FilePath 'jre\bin\java' -ArgumentList '-jar', 'signum-node.jar'"

exit
"@

		$content | Out-File -FilePath $SIGNUM_POOL_MAINNET_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_POOL_MAINNET_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_POOL_MAINNET_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_POOL_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_POOL_STARTER_EXEC_NAME} ${SIGNUM_POOL_MAINNET_STARTER_EXEC_PATH}

    # Install MariaDB
	if (Test-Path $MARIADB_STARTER_PS1_PATH) {
        Write-Host "MariaDB already installed!"
		question-prompt "Reinstall" "MariaDB" {install_mariadb}
    } else {
		Write-Host "MariaDB is not yet installed."
		question-prompt "Install" "MariaDB" {install_mariadb}
	}

    # Setup MariaDB for Signum Pool Mainnet
    question-prompt "Setup" "MariaDB for Signum Pool Mainnet" {setup_mariadb "Signum Pool Mainnet" "signum-pool-mainnet" "signumuser_pool_mainnet" "signumpassword"}
	
	if ($global:UserResponse -eq "yes") {	
		# Update database information in pool.properties
		setup_db_pool_properties ${SIGNUM_POOL_MAINNET_PROPERTIES_PATH}
	}
	
	# Setup pool.properties
	question-prompt "Setup" "Signum Pool Mainnet Properties" {setup_signumpool $SIGNUM_POOL_MAINNET_PROPERTIES_PATH  $SIGNUM_POOL_MAINNET_PROPERTIES_ORIGINAL_PATH "mainnet"}

	# TODO Create start-node-v8.2.0-mariadb-v10.20.0.bat in root to start specific versions
	# TODO start-node-node.bat should be bat and start-mariadb.bat should be bat as well and OS spacific or ps1 + ps1 executer bat

    Write-Host "Signum Pool Mainnet Installation complete."
    # Pause
	
	# Insall Signum Mainnet if not installed yet
	if (Test-Path $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH) {
		Write-Host "Signum Node Mainnet $SIGNUM_NODE_MAINNET_VERSION already installed."
		question-prompt "Reinstall" "Signum Node Mainnet" {Install-SignumMainnet}
	} else {
		Write-Host "Signum Node Mainnet $SIGNUM_NODE_MAINNET_VERSION is not yet installed."
		question-prompt "Install" "Signum Node Mainnet" {Install-SignumMainnet}
		# Pause
	}

<#	
	if (-not (Test-Path -Path "${SIGNUM_POOL_TESTNET_STARTER_PS1_PATH}")) {
        question-prompt "Install" "Signum Pool Testnet" Install-SignumPoolTestnet
    }
#>	
}

# TODO parameterize every function to use only once
# Currently by default installer use MariaDB -> maybe later multiple installation could be configured assigne with specific application

function Install-SignumPoolTestnet {
    Write-Host "Installing Signum Pool Testnet ..."

	# install-process $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH "Signum Testnet" {Install-SignumMainnet}

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }

    # Create Pool directory
    if (-not (Test-Path -Path "${SIGNUM_POOL_TESTNET_DIR_PATH}")) {
        New-Item -Path "${SIGNUM_POOL_TESTNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_POOL_TESTNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_POOL_TESTNET_DIR_PATH}"
    }

    if (Test-Path -Path "${SIGNUM_POOL_TESTNET_ZIP_PATH}") {
        Write-Host "${SIGNUM_POOL_TESTNET_ZIP_PATH} already downloaded."
    } else {
        # Download the Signum Pool Testnet zip file
        Write-Host "Downloading Signum Pool from GitHub ..."
        # Start-BitsTransfer -Source "${SIGNUM_POOL_TESTNET_URL}" -Destination "${SIGNUM_POOL_TESTNET_ZIP_PATH}"
		Invoke-WebRequest -Uri $SIGNUM_POOL_TESTNET_URL -OutFile $SIGNUM_POOL_TESTNET_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_POOL_TESTNET_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum Pool."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SIGNUM_POOL_TESTNET_UNZIP_PATH}") {
        Write-Host "${SIGNUM_POOL_TESTNET_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SIGNUM_POOL_TESTNET_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_POOL_TESTNET_ZIP_PATH}" -DestinationPath "${SIGNUM_POOL_TESTNET_DIR_PATH}" -Force
    }
	
	# Create jre directory
    if (-not (Test-Path -Path "${JAVA_POOL_TESTNET_DIR_PATH}")) {
        New-Item -Path "${JAVA_POOL_TESTNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${JAVA_POOL_TESTNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${JAVA_POOL_TESTNET_DIR_PATH}"
    }
	
	# download java
	if (Test-Path -Path "${JAVA_POOL_TESTNET_ZIP_PATH}") {
        Write-Host "${JAVA_POOL_TESTNET_ZIP_PATH} already downloaded."
    } else {
        # Download the Signum Pool Testnet zip file
        Write-Host "Downloading Java ..."
        # Start-BitsTransfer -Source "${JAVA_POOL_TESTNET_URL}" -Destination "${JAVA_POOL_TESTNET_ZIP_PATH}"
		Invoke-WebRequest -Uri $JAVA_POOL_TESTNET_URL -OutFile $JAVA_POOL_TESTNET_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${JAVA_POOL_TESTNET_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum Pool."
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip java
	if (Test-Path -Path "${JAVA_POOL_TESTNET_UNZIP_PATH}") {
        Write-Host "${JAVA_POOL_TESTNET_ZIP_PATH} already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Java to ${JAVA_POOL_TESTNET_UNZIP_PATH} ..."
        Expand-Archive -Path "${JAVA_POOL_TESTNET_ZIP_PATH}" -DestinationPath "${JAVA_POOL_TESTNET_DIR_PATH}" -Force
    }
	
	# Copy poopl.properties to pool-original.properties
	Write-Host "Copying ${SIGNUM_POOL_TESTNET_PROPERTIES_PATH} to ${SIGNUM_POOL_TESTNET_PROPERTIES_ORIGINAL_PATH} ..."
    Copy-Item -Path "${SIGNUM_POOL_TESTNET_PROPERTIES_PATH}" -Destination "${SIGNUM_POOL_TESTNET_PROPERTIES_ORIGINAL_PATH}"

	# Create starter ps1
	if (-not (Test-Path $SIGNUM_POOL_TESTNET_STARTER_PS1_PATH)) {
		# Create start-pool.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Signum Pool Testnet
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting MariaDB ...'

# Start MariaDB
..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$MARIADB_STARTER_PS1_PATH" "-WindowStyle Minimized"
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-ExecutionPolicy Bypass", "-File", "..\..\..\$MARIADB_STARTER_PS1_PATH" -WindowStyle Minimized

Write-Host 'Starting Signum Node Testnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$SIGNUM_NODE_TESTNET_STARTER_PS1_PATH" "-WindowStyle Minimized"

Write-Host 'Starting Signum Pool Testnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

# Start Signum Pool
# Start-Process -FilePath ".\${JAVA_POOL_TESTNET_DIR_NAME}\${JAVA_POOL_TESTNET_UNZIP_NAME}\bin\java.exe" -ArgumentList "-jar", "signum-pool.jar" -WindowStyle Minimized
# Last OK
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'Signum Pool Testnet'; .\${JAVA_POOL_TESTNET_DIR_NAME}\${JAVA_POOL_MAINNET_UNZIP_NAME}\bin\java.exe -jar signum-pool.jar"

Write-Host 'Starting Signum Pool Testnet ...'
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'Signum Pool Testnet'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SIGNUM_POOL_TESTNET_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'Signum Pool Testnet is already running.'
			exit
		} else {
			# Start Signum Pool Testnet
			# Start-Process "http://localhost:$SIGNUM_POOL_TESTNET_PORT"
			try {
				Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SIGNUM_POOL_TESTNET_PORT"
			} catch {
        		Write-Host 'An error occurred while starting Browser' -ForegroundColor Red
			}
			.\${JAVA_POOL_TESTNET_DIR_NAME}\${JAVA_POOL_TESTNET_UNZIP_NAME}\bin\java.exe -jar signum-pool.jar
		}
    } catch {
        Write-Host 'An error occurred while starting Signum Pool Testnet' -ForegroundColor Red
    } finally {
        # Always set the title to 'Signum Pool Testnet Stopped' after Signum Pool Testnet exits
        ```$host.UI.RawUI.WindowTitle = 'Signum Pool Testnet Stopped'
    }
"`@ ``
    -WindowStyle Minimized

# TODO check
# & ..\..\..\$POWERSHELL_EXEC_PATH -NoExit -Command .\jre\bin\java -jar signum-node.jar -WindowStyle Minimized
# "jre\bin\java" "-jar" "signum-node.jar" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "Set-Title 'Signum Testnet Node'; Start-Process -NoNewWindow -FilePath 'jre\bin\java' -ArgumentList '-jar', 'signum-node.jar'"

exit
"@

		$content | Out-File -FilePath $SIGNUM_POOL_TESTNET_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_POOL_TESTNET_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_POOL_TESTNET_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_POOL_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_POOL_STARTER_EXEC_NAME} ${SIGNUM_POOL_TESTNET_STARTER_EXEC_PATH}

    # Install MariaDB
	if (Test-Path $MARIADB_STARTER_PS1_PATH) {
        Write-Host "MariaDB already installed!"
		question-prompt "Reinstall" "MariaDB" {install_mariadb}
    } else {
		Write-Host "MariaDB is not yet installed."
		question-prompt "Install" "MariaDB" {install_mariadb}
	}

    # Setup MariaDB for Signum Pool Testnet
    question-prompt "Setup" "MariaDB for Signum Pool Testnet" {setup_mariadb "Signum Pool Testnet" "signum-pool-testnet" "signumuser_pool_testnet" "signumpassword"}
	
	if ($global:UserResponse -eq "yes") {	
		# Update database information in pool.properties
		setup_db_pool_properties ${SIGNUM_POOL_TESTNET_PROPERTIES_PATH}
	}
	
	# Setup pool.properties
	question-prompt "Setup" "Signum Pool Testnet Properties" {setup_signumpool $SIGNUM_POOL_TESTNET_PROPERTIES_PATH $SIGNUM_POOL_TESTNET_PROPERTIES_ORIGINAL_PATH "testnet"}

	# TODO Create start-node-v8.2.0-mariadb-v10.20.0.bat in root to start specific versions
	# TODO start-node-node.bat should be bat and start-mariadb.bat should be bat as well and OS spacific or ps1 + ps1 executer bat

    Write-Host "Signum Pool Testnet Installation complete."
    # Pause
	
	# Insall Signum Testnet if not installed yet
	if (Test-Path $SIGNUM_NODE_TESTNET_STARTER_PS1_PATH) {
		Write-Host "Signum Node Testnet $SIGNUM_NODE_TESTNET_VERSION already installed."
		question-prompt "Reinstall" "Signum Node Testnet" {Install-SignumTestnet}
	} else {
		Write-Host "Signum Node Testnet $SIGNUM_NODE_TESTNET_VERSION is not yet installed."
		question-prompt "Install" "Signum Node Testnet" {Install-SignumTestnet}
		Pause
	}
	
<#	
	if (-not (Test-Path -Path "${SIGNUM_POOL_MAINNET_STARTER_PS1_PATH}")) {
        question-prompt "Install" "Signum Pool Mainnet" Install-SignumPoolMainnet
    }
#>		
}

function Install-SignumExplorerMainnet {
    Write-Host "Installing Signum Exporer Mainnet ..."

	# install-process $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH "Signum Mainnet" {Install-SignumMainnet}

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
		install_chromium_browser
	} else {
		Write-Host "Chromium browser already installed"
	}

    # Create Explorer directory
    if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}")) {
        New-Item -Path "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_EXPLORER_MAINNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_EXPLORER_MAINNET_DIR_PATH}"
    }

    if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_ZIP_PATH}") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_ZIP_PATH} already downloaded."
    } else {
        # Download the Signum Explorer Mainnet zip file
        Write-Host "Downloading Signum Explorer from GitHub ..."
        # Start-BitsTransfer -Source "${SIGNUM_EXPLORER_MAINNET_URL}" -Destination "${SIGNUM_EXPLORER_MAINNET_ZIP_PATH}"
		Invoke-WebRequest -Uri $SIGNUM_EXPLORER_MAINNET_URL -OutFile $SIGNUM_EXPLORER_MAINNET_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum Explorer."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum Explorer to ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_MAINNET_ZIP_PATH}" -DestinationPath "${SIGNUM_EXPLORER_MAINNET_DIR_PATH}" -Force
    }
	<#
	# Create python directory
    if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH}")) {
        New-Item -Path "${JAVA_POOL_MAINNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${JAVA_POOL_MAINNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${JAVA_POOL_MAINNET_DIR_PATH}"
    }
	#>
	
	# download python
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH}") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH} already downloaded."
    } else {
        # Download the python zip file
        Write-Host "Downloading Python ..."
        # Start-BitsTransfer -Source "${SIGNUM_EXPLORER_MAINNET_PYTHON_URL}" -Destination "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH}"
		Invoke-WebRequest -Uri $SIGNUM_EXPLORER_MAINNET_PYTHON_URL -OutFile $SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Python."
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip python
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\python.exe") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH} already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Python to ${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH}" -DestinationPath "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}" -Force
    }
	
	# unzip $SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_ZIP_NAME
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_ZIP_PATH}\$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_ZIP_NAME already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping $SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_ZIP_NAME to ${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_ZIP_NAME" -DestinationPath "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME" -Force
    }
	
	# download get-pip.py from here: https://bootstrap.pypa.io/get-pip.py
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\get-pip.py") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\get-pip.py already downloaded."
    } else {
        # Download the get-pip.py file
        Write-Host "Downloading get-pip.py ..."
        # Start-BitsTransfer -Source "${SIGNUM_EXPLORER_MAINNET_PYTHON_GETPIP_URL}" -Destination "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\get-pip.py"
		Invoke-WebRequest -Uri $SIGNUM_EXPLORER_MAINNET_PYTHON_GETPIP_URL -OutFile ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\get-pip.py

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\get-pip.py")) {
            Write-Host "Error: Failed to download get-pip.py."
            Pause
            # Install-Menu
            return
        }
    }
	
	# download and unzipdownload and unzip to .\static
	# https://github.com/FortAwesome/Font-Awesome/releases/download/6.5.2/fontawesome-free-6.5.2-web.zip
	# https://github.com/FortAwesome/Font-Awesome/releases/download/6.2.1/fontawesome-free-6.2.1-web.zip	
	
	# download fontawesome-free-6.5.2-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip already downloaded."
    } else {
        # Download the fontawesome-free-6.5.2-web.zip file
        Write-Host "Downloading fontawesome-free-6.5.2-web.zip ..."
        # Start-BitsTransfer -Source "https://github.com/FortAwesome/Font-Awesome/releases/download/6.5.2/fontawesome-free-6.5.2-web.zip" -Destination "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip"
		Invoke-WebRequest -Uri "https://github.com/FortAwesome/Font-Awesome/releases/download/6.5.2/fontawesome-free-6.5.2-web.zip" -OutFile ${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip")) {
            Write-Host "Error: Failed to download fontawesome-free-6.5.2-web.zip"
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip fontawesome-free-6.5.2-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping fontawesome-free-6.5.2-web to ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\static ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip" -DestinationPath "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static" -Force
    }
	
		# download fontawesome-free-6.2.1-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip already downloaded."
    } else {
        # Download the fontawesome-free-6.2.1-web.zip file
        Write-Host "Downloading fontawesome-free-6.2.1-web.zip ..."
        # Start-BitsTransfer -Source "https://github.com/FortAwesome/Font-Awesome/releases/download/6.2.1/fontawesome-free-6.2.1-web.zip" -Destination "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip"
		Invoke-WebRequest -Uri "https://github.com/FortAwesome/Font-Awesome/releases/download/6.2.1/fontawesome-free-6.2.1-web.zip" -OutFile ${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip")) {
            Write-Host "Error: Failed to download fontawesome-free-6.2.1-web.zip"
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip fontawesome-free-6.2.1-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping fontawesome-free-6.2.1-web to ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\static ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_MAINNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip" -DestinationPath "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\static" -Force
    }
	
	# run pyton get-pip.py command
	Write-Host "Installing get-pip.py"
	& "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\python.exe" "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\get-pip.py"
	
	# uncomment import site from $SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	Write-Host "Setup $SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth file"
	$content = Get-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	
	$content = $content | ForEach-Object {
		$_ -replace "#import site", "import site"
	}

	# Write the changes back to the file
	$content | Set-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\$SIGNUM_EXPLORER_MAINNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	
	# installation
	& "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\Scripts\pip.exe" install setuptools
	& "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\Scripts\pip.exe" install maturin
	& "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\Scripts\pip.exe" install supervisor-win
	& "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\Scripts\pip.exe" install waitress
	& "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\Scripts\pip.exe" install -r ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\requirements.txt
	
	# create ./tmp/supervisord.pid if not exists
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\tmp\supervisord.pid") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\tmp\supervisord.pid already exists."
    } else {
		Write-Host "Create ./tmp/supervisord.pid file"
		New-Item -ItemType Directory -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\tmp" -Force | Out-Null
		New-Item -ItemType File -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\tmp\supervisord.pid" -Force | Out-Null
    }

	# copy supervisord.conf to supervisord_original.conf
	if (Test-Path -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\supervisord_original.conf") {
        Write-Host "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\supervisord_original.conf already exists."
    } else {
		Write-Host "Copy supervisord.conf to supervisord_original.conf file"
		Copy-Item -Path "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\supervisord.conf" -Destination "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\supervisord_original.conf"
    }
	
	# TODO setup supervisord username and password and change port if testnet is also running

<#
	[inet_http_server]
	port = 9000
	username = dummy
	password = changeme
#>
	
	# change supervisord.conf file
	Write-Host "Setup supervisord.conf file"
	
	$foundExplorer = $false
	$foundPeers = $false
	$foundTasks = $false
	$foundSNR = $false
	
	$content = Get-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\supervisord.conf
	$rowCount = $content.Count
	for ($i = 0; $i -lt $rowCount; $i++) {

		# Get the current line
		$line = $content[$i]
				
		if ($line -match "^\[program:Explorer\]") {
			$foundExplorer = $true
			$foundPeers = $false
			$foundTasks = $false
			$foundSNR = $false
		}
		
		if ($line -match "^\[program:Peers\]") {	
			$foundExplorer = $false
			$foundPeers = $true
			$foundTasks = $false
			$foundSNR = $false
		}
		
		if ($line -match "^\[program:Tasks\]") {
			$foundExplorer = $false
			$foundPeers = $false
			$foundTasks = $true
			$foundSNR = $false
		}
		
		if ($line -match "^\[program:SNR\]") {
			$foundExplorer = $false
			$foundPeers = $false
			$foundTasks = $false
			$foundSNR = $true
			$line = $line -replace "^\[program:SNR\]", ";[program:SNR]"
		}
		
		if ($foundExplorer) {
			if ($line -match "^stdout_logfile = /dev/stdout") {
				$line = ($line -replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout") + "`nstdout_logfile = explorer_stdout.log" + "`n;stdout_logfile = CON"
			}
		} 
		
		if ($foundPeers) {
			if ($line -match "^stdout_logfile = /dev/stdout") {
				$line = ($line -replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout") + "`nstdout_logfile = peers_stdout.log" + "`n;stdout_logfile = CON"
			}
		} 
		
		if ($foundTasks) {
			if ($line -match "^stdout_logfile = /dev/stdout") {
				$line = ($line -replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout") + "`nstdout_logfile = tasks_stdout.log" + "`n;stdout_logfile = CON"
			}
		} 
		
		if ($foundSNR) {
			$line = $line `
				-replace "^command =bash -c ""/path/to/your/snr/runSNR.sh\""", ";command =bash -c ""/path/to/your/snr/runSNR.sh""" `
				-replace "^autostart = true", ";autostart = true" `
				-replace "^autorestart = true", ";autorestart = true" `
				-replace "^startsecs = 1", ";startsecs = 1" `
				-replace "^redirect_stderr = true", ";redirect_stderr = true" `
				-replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout" `
				-replace "^stdout_logfile_maxbytes = 0", ";stdout_logfile_maxbytes = 0"
		
		}

		$line = $line `
			-replace "^\[unix_http_server\]", ";[unix_http_server]" `
			-replace "^port = 9001", "port = $SIGNUM_EXPLORER_MAINNET_SUPERVISOR_SATUS_PORT" `
			-replace "^username = dummy", ";username = dummy" `
			-replace "^password = changeme", ";password = changeme" `
			-replace "^file = /tmp/supervisor.sock", ";file = ./tmp/supervisor.sock" `
			-replace "^pidfile = /tmp/supervisord.pid", "pidfile = ./tmp/supervisord.pid" `
			-replace "^chmod = 0700", ";chmod = 0700" `
			-replace "^serverurl = unix:///tmp/supervisor.sock", "serverurl = ./tmp/supervisor.sock" `
			-replace "^directory=.*", "directory=./" `
			-replace "^command = gunicorn config.wsgi -c gunicorn.conf.py", "command = ./python.exe run_waitress.py" `
			-replace "^command = python3 manage.py peers", "command = ./python.exe manage.py peers" `
			-replace "^command = python3 manage.py tasks", "command = ./python.exe manage.py tasks" `
			-replace "^logfile = /dev/null", ";logfile = /dev/null"

		$content[$i] = $line

	}
	
	# Write the changes back to the file
	$content | Set-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\supervisord.conf
	
	# Create run_waitress.py
	if (-not (Test-Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\run_waitress.py)) {
		# Create run_waitress.py file with the desired content
		$content = 
@"
import os
import multiprocessing
from waitress import serve
from dotenv import load_dotenv
load_dotenv()
from config.wsgi import application  # Adjust this import to point to your WSGI application

# Calculate optimal workers and threads
cpu_count = multiprocessing.cpu_count()
threads = 3 * cpu_count
timeout = 60

# Start waitress server
serve(
	application,
	host="0.0.0.0",
	port=$SIGNUM_EXPLORER_MAINNET_PORT,
	threads=threads,
	connection_limit=1000,  # Equivalent to Gunicorn's max_requests
	asyncore_use_poll=True,
	channel_timeout=timeout,
)
"@

		$content | Out-File -FilePath ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\run_waitress.py -Force

	Write-Host "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\run_waitress.py successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\run_waitress.py"
	}	
	
	# Create .env file
	if (-not (Test-Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env)) {
		# Create .env file with the desired content
		$content = 
@"
#APP_ENV=development
APP_ENV=production

# change secret key!
SECRET_KEY=secret_key

# mysql configuration
## ENGINE=django.db.backends.mysql
## OPTIONS={"init_command": "SET sql_mode='STRICT_TRANS_TABLES'", "charset": "utf8mb4"}
# DB_JAVA_WALLET required read-only access.

COINGECKO_PRICE_ID=SIGNUM

COINGECKO_PRICE_USD=0.000
COINGECKO_PRICE_BTC=0.000
COINGECKO_MKT_USD=0.000

COIN_SYMBOL=SIGNA
ADDRESS_PREFIX=S-

SITE_TITLE=Signum Explorer
#TEST_NET=true

DB_DEFAULT_ENGINE=django.db.backends.mysql
DB_DEFAULT_HOST=127.0.0.1
DB_DEFAULT_PORT=$MARIADB_PORT
DB_DEFAULT_NAME=signum-explorer-mainnet
DB_DEFAULT_USER=signumuser_explorer_mainnet
DB_DEFAULT_PASSWORD=signumpassword
DB_DEFAULT_OPTIONS={"init_command": "SET sql_mode='STRICT_TRANS_TABLES'", "charset": "utf8mb4"}

DB_JAVA_WALLET_ENGINE=django.db.backends.mysql
DB_JAVA_WALLET_HOST=127.0.0.1
DB_JAVA_WALLET_PORT=$MARIADB_PORT
DB_JAVA_WALLET_NAME=signum-node-mainnet
DB_JAVA_WALLET_USER=signumuser_node_mainnet_readonly
DB_JAVA_WALLET_PASSWORD=signumpassword
DB_JAVA_WALLET_OPTIONS={}

CACHE_DEFAULT_HOST=localhost
CACHE_DEFAULT_PORT=6379
CACHE_DEFAULT_DB=0

CELERY_BROKER_HOST=localhost
CELERY_BROKER_PORT=6379
CELERY_BROKER_DB=1

GOOGLE_TRACKING_ID=
SENTRY_DSN=
SIGNUM_NODE=localhost
WALLET_URL=https://signumwallet.ddns.net:8128/
BRS_BOOTSTRAP_PEERS=["signumwallet.ddns.net:8123", "taylorforce.synology.me:8123", "zwurg.feste-ip.net:51940", "zmail.cloudns.ph:8123"]
DEFAULT_P2P_PORT=$SIGNUM_NODE_MAINNET_P2P_PORT
DEFAULT_API_V1_PORT=$SIGNUM_NODE_MAINNET_API_PORT

BRS_P2P_VERSION = $SIGNUM_NODE_MAINNET_VERSION
MIN_PEER_VERSION = 3.8.0

#FEATURED_ASSETS=["12402415494995249540", "13240027460799312630", "11955007191311588286"]
#PHISHING_ASSETS=["SIGNA", "SIGNUM", "BTC", "USDT", "BNB", "BURST", "SIGNAINU"]
#BLOCKED_ASSETS=["NIGGERS", "CHLDPORN", "YWNBAW"]

PEERS_SCAN_DELAY=90
MIN_PEER_VERSION = 1.1.1

# Delay between task.py execution
TASKS_SCAN_DELAY=60
"@

		$content | Out-File -FilePath ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env -Force

		Write-Host "${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env"
	}
	
	# Comment out redis from settings.py
	Write-Host "Setup settings.py"
	
	$content = Get-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\config\settings.py
	
	for ($i = 0; $i -lt $content.Count; $i++) {

		# Get the current line
		$line = $content[$i]

		if ($line -match '^\s*"OPTIONS": \{"CLIENT_CLASS": "django_redis\.client\.DefaultClient"\},') {
			if ($content[$i+2] -match "\}$")
				{
					$content[$i+2] = "$($content[$i + 2])'''"
				}
		}

		# Apply replacements to the line
		$content[$i] = $line `
			-replace "^\s*from sentry_sdk.integrations.redis import RedisIntegration", "#    from sentry_sdk.integrations.redis import RedisIntegration" `
			-replace "^\s*RedisIntegration\(\),", "#            RedisIntegration()," `
			-replace "^CACHES = \{", "'''CACHES = {" 
	}

	# Write the changes back to the file
	$content | Set-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\config\settings.py

	# Create starter ps1
	if (-not (Test-Path $SIGNUM_EXPLORER_MAINNET_STARTER_PS1_PATH)) {
		# Create start-explorer.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Signum Node
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting MariaDB ...'

# Start MariaDB
..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$MARIADB_STARTER_PS1_PATH" "-WindowStyle Minimized"
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-ExecutionPolicy Bypass", "-File", "..\..\..\$MARIADB_STARTER_PS1_PATH" -WindowStyle Minimized

Write-Host 'Starting Signum Node Mainnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$SIGNUM_NODE_MAINNET_STARTER_PS1_PATH" "-WindowStyle Minimized"

Write-Host 'Starting Signum Explorer Mainnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

# Start Signum Explorer
# Start-Process -FilePath ".\${JAVA_POOL_MAINNET_DIR_NAME}\${JAVA_POOL_MAINNET_UNZIP_NAME}\bin\java.exe" -ArgumentList "-jar", "signum-pool.jar" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", ".\Scripts\supervisord.exe -n -c .\supervisord.conf" -WindowStyle Hidden
# Last OK
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'Signum Explorer Mainnet'; .\Scripts\supervisord.exe -n -c .\supervisord.conf" -WindowStyle Minimized
# Start-Process -FilePath ".\Scripts\supervisord.exe -n -c .\supervisord.conf" -WindowStyle Minimized

Write-Host 'Starting Signum Explorer Mainnet ...'
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'Signum Explorer Mainnet'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SIGNUM_EXPLORER_MAINNET_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'Signum Explorer Mainnet is already running.'
			exit
		} else {
			# Start Signum Explorer Mainnet
			# Start-Process "http://localhost:$SIGNUM_EXPLORER_MAINNET_SUPERVISOR_SATUS_PORT"
			Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SIGNUM_EXPLORER_MAINNET_SUPERVISOR_SATUS_PORT"
			# Start-Process "http://localhost:$SIGNUM_EXPLORER_MAINNET_PORT"
			Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SIGNUM_EXPLORER_MAINNET_PORT"
			.\Scripts\supervisord.exe -n -c .\supervisord.conf
		}
    } catch {
        Write-Host 'An error occurred while starting Signum Explorer Mainnet: `$_'
    } finally {
        # Always set the title to 'Signum Explorer Mainnet Stopped' after Signum Explorer Mainnet exits
        ```$host.UI.RawUI.WindowTitle = 'Signum Explorer Mainnet Stopped'
    }
"`@ ``
    -WindowStyle Minimized

# TODO check
# & ..\..\..\$POWERSHELL_EXEC_PATH -NoExit -Command .\jre\bin\java -jar signum-node.jar -WindowStyle Minimized
# "jre\bin\java" "-jar" "signum-node.jar" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "Set-Title 'Signum Mainnet Node'; Start-Process -NoNewWindow -FilePath 'jre\bin\java' -ArgumentList '-jar', 'signum-node.jar'"

exit
"@

		$content | Out-File -FilePath $SIGNUM_EXPLORER_MAINNET_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_EXPLORER_MAINNET_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_EXPLORER_MAINNET_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_EXPLORER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_EXPLORER_STARTER_EXEC_NAME} ${SIGNUM_EXPLORER_MAINNET_STARTER_EXEC_PATH}

    # Install MariaDB
	if (Test-Path $MARIADB_STARTER_PS1_PATH) {
        Write-Host "MariaDB already installed!"
		question-prompt "Reinstall" "MariaDB" {install_mariadb}
    } else {
		Write-Host "MariaDB is not yet installed."
		question-prompt "Install" "MariaDB" {install_mariadb}
	}

    # Setup MariaDB for Signum Pool Mainnet
    question-prompt "Setup" "MariaDB for Signum Explorer Mainnet" {setup_mariadb_explorer "Signum Explorer Mainnet" "signum-explorer-mainnet" "signumuser_explorer_mainnet" "signumpassword"}
	
	if ($global:UserResponse -eq "yes") {
		# Setup .env file with the Signum Explorer database values
		$content = Get-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env
		
		$content = $content | ForEach-Object {
					$_  -replace "^DB_DEFAULT_NAME=.*", "DB_DEFAULT_NAME=$global:DATABASE_NAME" `
						-replace "^DB_DEFAULT_USER=.*", "DB_DEFAULT_USER=$global:DATABASE_USERNAME" `
						-replace "^DB_DEFAULT_PASSWORD=.*", "DB_DEFAULT_PASSWORD=$global:DATABASE_PASSWORD"
				}

		# Write the changes back to the file
		$content | Set-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env
	}
	
	# At this point you have to have Signum Node to install
	if (Test-Path $SIGNUM_NODE_MAINNET_STARTER_PS1_PATH) {
		Write-Host "Signum Node Mainnet $SIGNUM_NODE_MAINNET_VERSION already installed."
		question-prompt "Reinstall" "Signum Node Mainnet" {Install-SignumMainnet}
	} else {
		Write-Host "Signum Node Mainnet $SIGNUM_NODE_MAINNET_VERSION is not yet installed."
		question-prompt "Install" "Signum Node Mainnet" {Install-SignumMainnet}
		# Pause
	}
	
	Write-Host "Populate database informations from installed Signum Node Mainnet properties."

	# Read the node.properties file content
	$content = Get-Content -Path $SIGNUM_NODE_MAINNET_PROPERTIES_PATH
	
	# Initialize variables
	$dbName = $null
	$username = $null
	$password = $null
	
	# Extract the database information fom node.properties
	$content | ForEach-Object {
		if ($_ -match '^DB\.Url=jdbc:mariadb://.+/(.+)') {
			$dbName = $matches[1]
		}
		elseif ($_ -match '^DB\.Username=(.+)') {
			$username = $matches[1]
		}
		elseif ($_ -match '^DB\.Password=(.+)') {
			$password = $matches[1]
		}
	}

	# Display the extracted information
	Write-Output "Signum Mainnet Node Database Name: $dbName"
	# Write-Output "Signum Mainnet Node Database Username: $username"
	# Write-Output "Signum Mainnet Node Database Password: $password"

	# Create Read Only User for Signum Node Mainnet database access for explorer
	Write-Host "Create Read Only User for Signum Node Mainnet database access for explorer"
	question-prompt "Setup" "MariaDB for Signum Explorer Mainnet Read Only Node connection" {setup_mariadb_readonly "Signum Explorer Mainnet Node connection" "$dbName" "signumuser_node_mainnet_readonly" "signumpassword"}

	if ($global:UserResponse -eq "yes") {	
		# Setup .env file with the Signum Explorer database values
		$content = Get-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env
		
		$content = $content | ForEach-Object {
					$_  -replace "^DB_JAVA_WALLET_NAME=.*", "DB_JAVA_WALLET_NAME=$global:DATABASE_NAME" `
						-replace "^DB_JAVA_WALLET_USER=.*", "DB_JAVA_WALLET_USER=$global:DATABASE_USERNAME" `
						-replace "^DB_JAVA_WALLET_PASSWORD=.*", "DB_JAVA_WALLET_PASSWORD=$global:DATABASE_PASSWORD"
				}
			
		# Write the changes back to the file
		$content | Set-Content -Path ${SIGNUM_EXPLORER_MAINNET_UNZIP_PATH}\.env
	}
	
	# TODO further setup of .env and run_waitress.py if want

    Write-Host "Signum Explorer Mainnet Installation complete."
	
}

function Install-SignumExplorerTestnet {
    Write-Host "Installing Signum Exporer Testnet ..."

	# install-process $SIGNUM_NODE_TESTNET_STARTER_PS1_PATH "Signum Testnet" {Install-SignumTestnet}

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }

    # Create Explorer directory
    if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}")) {
        New-Item -Path "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${SIGNUM_EXPLORER_TESTNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_EXPLORER_TESTNET_DIR_PATH}"
    }

    if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_ZIP_PATH}") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_ZIP_PATH} already downloaded."
    } else {
        # Download the Signum Explorer Testnet zip file
        Write-Host "Downloading Signum Explorer from GitHub ..."
        # Start-BitsTransfer -Source "${SIGNUM_EXPLORER_TESTNET_URL}" -Destination "${SIGNUM_EXPLORER_TESTNET_ZIP_PATH}"
		Invoke-WebRequest -Uri ${SIGNUM_EXPLORER_TESTNET_URL} -OutFile ${SIGNUM_EXPLORER_TESTNET_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum Explorer."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum Explorer to ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_TESTNET_ZIP_PATH}" -DestinationPath "${SIGNUM_EXPLORER_TESTNET_DIR_PATH}" -Force
    }
	<#
	# Create python directory
    if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}")) {
        New-Item -Path "${JAVA_POOL_TESTNET_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${JAVA_POOL_TESTNET_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${JAVA_POOL_TESTNET_DIR_PATH}"
    }
	#>
	
	# download python
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH} already downloaded."
    } else {
        # Download the python zip file
        Write-Host "Downloading Python ..."
        # Start-BitsTransfer -Source "${SIGNUM_EXPLORER_TESTNET_PYTHON_URL}" -Destination "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}"
		Invoke-WebRequest -Uri ${SIGNUM_EXPLORER_TESTNET_PYTHON_URL} -OutFile ${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Python."
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip python
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\python.exe") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH} already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Python to ${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}" -DestinationPath "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}" -Force
    }
	
	# unzip $SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_ZIP_NAME
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_ZIP_PATH}\$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_ZIP_NAME already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping $SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_ZIP_NAME to ${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_ZIP_NAME" -DestinationPath "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME" -Force
    }
	
	# download get-pip.py from here: https://bootstrap.pypa.io/get-pip.py
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\get-pip.py") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\get-pip.py already downloaded."
    } else {
        # Download the get-pip.py file
        Write-Host "Downloading get-pip.py ..."
        # Start-BitsTransfer -Source "${SIGNUM_EXPLORER_TESTNET_PYTHON_GETPIP_URL}" -Destination "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\get-pip.py"
		Invoke-WebRequest -Uri ${SIGNUM_EXPLORER_TESTNET_PYTHON_GETPIP_URL} -OutFile ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\get-pip.py

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\get-pip.py")) {
            Write-Host "Error: Failed to download get-pip.py."
            Pause
            # Install-Menu
            return
        }
    }
	
	# download and unzipdownload and unzip to .\static
	# https://github.com/FortAwesome/Font-Awesome/releases/download/6.5.2/fontawesome-free-6.5.2-web.zip
	# https://github.com/FortAwesome/Font-Awesome/releases/download/6.2.1/fontawesome-free-6.2.1-web.zip	
	
	# download fontawesome-free-6.5.2-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip already downloaded."
    } else {
        # Download the fontawesome-free-6.5.2-web.zip file
        Write-Host "Downloading fontawesome-free-6.5.2-web.zip ..."
        # Start-BitsTransfer -Source "https://github.com/FortAwesome/Font-Awesome/releases/download/6.5.2/fontawesome-free-6.5.2-web.zip" -Destination "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip"
		Invoke-WebRequest -Uri "https://github.com/FortAwesome/Font-Awesome/releases/download/6.5.2/fontawesome-free-6.5.2-web.zip" -OutFile ${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip
		
        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip")) {
            Write-Host "Error: Failed to download fontawesome-free-6.5.2-web.zip"
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip fontawesome-free-6.5.2-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping fontawesome-free-6.5.2-web to ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\static ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.5.2-web.zip" -DestinationPath "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static" -Force
    }
	
		# download fontawesome-free-6.2.1-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip already downloaded."
    } else {
        # Download the fontawesome-free-6.2.1-web.zip file
        Write-Host "Downloading fontawesome-free-6.2.1-web.zip ..."
        # Start-BitsTransfer -Source "https://github.com/FortAwesome/Font-Awesome/releases/download/6.2.1/fontawesome-free-6.2.1-web.zip" -Destination "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip"
		Invoke-WebRequest -Uri "https://github.com/FortAwesome/Font-Awesome/releases/download/6.2.1/fontawesome-free-6.2.1-web.zip" -OutFile ${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip
		
        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip")) {
            Write-Host "Error: Failed to download fontawesome-free-6.2.1-web.zip"
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip fontawesome-free-6.2.1-web.zip
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping fontawesome-free-6.2.1-web to ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\static ..."
        Expand-Archive -Path "${SIGNUM_EXPLORER_TESTNET_PYTHON_UNZIP_PATH}\static\fontawesome-free-6.2.1-web.zip" -DestinationPath "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\static" -Force
    }
	
	# run pyton get-pip.py command
	Write-Host "Installing get-pip.py"
	& "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\python.exe" "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\get-pip.py"
	
	# uncomment import site from $SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	Write-Host "Setup $SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth file"
	$content = Get-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	
	$content = $content | ForEach-Object {
		$_ -replace "#import site", "import site"
	}

	# Write the changes back to the file
	$content | Set-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\$SIGNUM_EXPLORER_TESTNET_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	
	# installation
	& "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\Scripts\pip.exe" install setuptools
	& "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\Scripts\pip.exe" install maturin
	& "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\Scripts\pip.exe" install supervisor-win
	& "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\Scripts\pip.exe" install waitress
	& "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\Scripts\pip.exe" install -r ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\requirements.txt
	
	# create ./tmp/supervisord.pid if not exists
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\tmp\supervisord.pid") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\tmp\supervisord.pid already exists."
    } else {
		Write-Host "Create ./tmp/supervisord.pid file"
		New-Item -ItemType Directory -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\tmp" -Force | Out-Null
		New-Item -ItemType File -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\tmp\supervisord.pid" -Force | Out-Null
    }

	# copy supervisord.conf to supervisord_original.conf
	if (Test-Path -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\supervisord_original.conf") {
        Write-Host "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\supervisord_original.conf already exists."
    } else {
		Write-Host "Copy supervisord.conf to supervisord_original.conf file"
		Copy-Item -Path "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\supervisord.conf" -Destination "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\supervisord_original.conf"
    }
	
	# change supervisord.conf file
	Write-Host "Setup supervisord.conf file"
	
	$foundExplorer = $false
	$foundPeers = $false
	$foundTasks = $false
	$foundSNR = $false
	
	$content = Get-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\supervisord.conf
	
	$rowCount = $content.Count
	for ($i = 0; $i -lt $rowCount; $i++) {

		# Get the current line
		$line = $content[$i]

		if ($line -match "^\[program:Explorer\]") {
			$foundExplorer = $true
			$foundPeers = $false
			$foundTasks = $false
			$foundSNR = $false
		}
		
		if ($line -match "^\[program:Peers\]") {	
			$foundExplorer = $false
			$foundPeers = $true
			$foundTasks = $false
			$foundSNR = $false
		}
		
		if ($line -match "^\[program:Tasks\]") {
			$foundExplorer = $false
			$foundPeers = $false
			$foundTasks = $true
			$foundSNR = $false
		}
		
		if ($line -match "^\[program:SNR\]") {
			$foundExplorer = $false
			$foundPeers = $false
			$foundTasks = $false
			$foundSNR = $true
			$line = $line -replace "^\[program:SNR\]", ";[program:SNR]"
		}
		
		if ($foundExplorer) {
			if ($line -match "^stdout_logfile = /dev/stdout") {
				$line = ($line -replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout") + "`nstdout_logfile = explorer_stdout.log" + "`n;stdout_logfile = CON"
			}
		}
		
		if ($foundPeers) {
			if ($line -match "^stdout_logfile = /dev/stdout") {
				$line = ($line -replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout") + "`nstdout_logfile = peers_stdout.log" + "`n;stdout_logfile = CON"
			}
		}
		
		if ($foundTasks) {
			if ($line -match "^stdout_logfile = /dev/stdout") {
				$line = ($line -replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout") + "`nstdout_logfile = tasks_stdout.log" + "`n;stdout_logfile = CON"
			}
		}
		
		if ($foundSNR) {
			
			$line = $line `
				-replace "^command =bash -c ""/path/to/your/snr/runSNR.sh\""", ";command =bash -c ""/path/to/your/snr/runSNR.sh""" `
				-replace "^autostart = true", ";autostart = true" `
				-replace "^autorestart = true", ";autorestart = true" `
				-replace "^startsecs = 1", ";startsecs = 1" `
				-replace "^redirect_stderr = true", ";redirect_stderr = true" `
				-replace "^stdout_logfile = /dev/stdout", ";stdout_logfile = /dev/stdout" `
				-replace "^stdout_logfile_maxbytes = 0", ";stdout_logfile_maxbytes = 0"
		
		}

		$line = $line `
			-replace "^\[unix_http_server\]", ";[unix_http_server]" `
			-replace "^port = 9001", "port = $SIGNUM_EXPLORER_TESTNET_SUPERVISOR_SATUS_PORT" `
			-replace "^username = dummy", ";username = dummy" `
			-replace "^password = changeme", ";password = changeme" `
			-replace "^file = /tmp/supervisor.sock", ";file = ./tmp/supervisor.sock" `
			-replace "^pidfile = /tmp/supervisord.pid", "pidfile = ./tmp/supervisord.pid" `
			-replace "^chmod = 0700", ";chmod = 0700" `
			-replace "^serverurl = unix:///tmp/supervisor.sock", "serverurl = ./tmp/supervisor.sock" `
			-replace "^directory=.*", "directory=./" `
			-replace "^command = gunicorn config.wsgi -c gunicorn.conf.py", "command = ./python.exe run_waitress.py" `
			-replace "^command = python3 manage.py peers", "command = ./python.exe manage.py peers" `
			-replace "^command = python3 manage.py tasks", "command = ./python.exe manage.py tasks" `
			-replace "^logfile = /dev/null", ";logfile = /dev/null"

			$content[$i] = $line

	}
	
	# Write the changes back to the file
	$content | Set-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\supervisord.conf
	
	# Create run_waitress.py
	if (-not (Test-Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\run_waitress.py)) {
		# Create run_waitress.py file with the desired content
		$content = 
@"
import os
import multiprocessing
from waitress import serve
from dotenv import load_dotenv
load_dotenv()
from config.wsgi import application  # Adjust this import to point to your WSGI application

# Calculate optimal workers and threads
cpu_count = multiprocessing.cpu_count()
threads = 3 * cpu_count
timeout = 60

# Start waitress server
serve(
	application,
	host="0.0.0.0",
	port=$SIGNUM_EXPLORER_TESTNET_PORT,
	threads=threads,
	connection_limit=1000,  # Equivalent to Gunicorn's max_requests
	asyncore_use_poll=True,
	channel_timeout=timeout,
)
"@

		$content | Out-File -FilePath ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\run_waitress.py -Force

	Write-Host "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\run_waitress.py successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\run_waitress.py"
	}	
	
	# Create .env file
	if (-not (Test-Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env)) {
		# Create .env file with the desired content
		$content = 
@"
#APP_ENV=development
APP_ENV=production

# change secret key!
SECRET_KEY=secret_key

# mysql configuration
## ENGINE=django.db.backends.mysql
## OPTIONS={"init_command": "SET sql_mode='STRICT_TRANS_TABLES'", "charset": "utf8mb4"}
# DB_JAVA_WALLET required read-only access.

COINGECKO_PRICE_ID=SIGNUM

COINGECKO_PRICE_USD=0.000
COINGECKO_PRICE_BTC=0.000
COINGECKO_MKT_USD=0.000

COIN_SYMBOL=SIGNA
ADDRESS_PREFIX=S-

SITE_TITLE=Signum Explorer
TEST_NET=true

DB_DEFAULT_ENGINE=django.db.backends.mysql
DB_DEFAULT_HOST=127.0.0.1
DB_DEFAULT_PORT=$MARIADB_PORT
DB_DEFAULT_NAME=signum-explorer-testnet
DB_DEFAULT_USER=signumuser_explorer_testnet
DB_DEFAULT_PASSWORD=signumpassword
DB_DEFAULT_OPTIONS={"init_command": "SET sql_mode='STRICT_TRANS_TABLES'", "charset": "utf8mb4"}

DB_JAVA_WALLET_ENGINE=django.db.backends.mysql
DB_JAVA_WALLET_HOST=127.0.0.1
DB_JAVA_WALLET_PORT=$MARIADB_PORT
DB_JAVA_WALLET_NAME=signum-node-testnet
DB_JAVA_WALLET_USER=signumuser_node_testnet_readonly
DB_JAVA_WALLET_PASSWORD=signumpassword
DB_JAVA_WALLET_OPTIONS={}

CACHE_DEFAULT_HOST=localhost
CACHE_DEFAULT_PORT=6379
CACHE_DEFAULT_DB=0

CELERY_BROKER_HOST=localhost
CELERY_BROKER_PORT=6379
CELERY_BROKER_DB=1

GOOGLE_TRACKING_ID=
SENTRY_DSN=
SIGNUM_NODE=localhost
WALLET_URL=https://signumwallettestnet.ddns.net:8138/
BRS_BOOTSTRAP_PEERS=["signumwallettestnet.ddns.net:8138"]
DEFAULT_P2P_PORT=7123
DEFAULT_API_V1_PORT=$SIGNUM_NODE_TESTNET_API_PORT

BRS_P2P_VERSION = $SIGNUM_NODE_TESTNET_VERSION
MIN_PEER_VERSION = 3.8.0

#FEATURED_ASSETS=["12402415494995249540", "13240027460799312630", "11955007191311588286"]
#PHISHING_ASSETS=["SIGNA", "SIGNUM", "BTC", "USDT", "BNB", "BURST", "SIGNAINU"]
#BLOCKED_ASSETS=["NIGGERS", "CHLDPORN", "YWNBAW"]

PEERS_SCAN_DELAY=90
MIN_PEER_VERSION = 1.1.1

# Delay between task.py execution
TASKS_SCAN_DELAY=60
"@

		$content | Out-File -FilePath ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env -Force

		Write-Host "${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env"
	}
	
	# Comment out redis from settings.py
	Write-Host "Setup settings.py"
	
	$content = Get-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\config\settings.py
	
	for ($i = 0; $i -lt $content.Count; $i++) {
		# Get the current line
		$line = $content[$i] 

		if ($line -match '^\s*"OPTIONS": \{"CLIENT_CLASS": "django_redis\.client\.DefaultClient"\},') {
			if ($content[$i+2] -match "\}$")
				{
					$content[$i+2] = "$($content[$i + 2])'''"
				}
		}

		# Apply replacements to the line
		$content[$i] = $line `
			-replace "^\s*from sentry_sdk.integrations.redis import RedisIntegration", "#    from sentry_sdk.integrations.redis import RedisIntegration" `
			-replace "^\s*RedisIntegration\(\),", "#            RedisIntegration()," `
			-replace "^CACHES = \{", "'''CACHES = {" 
	}

	# Write the changes back to the file
	$content | Set-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\config\settings.py

	# Create starter ps1
	if (-not (Test-Path $SIGNUM_EXPLORER_TESTNET_STARTER_PS1_PATH)) {
		# Create start-explorer.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Signum Node
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting MariaDB ...'

# Start MariaDB
..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$MARIADB_STARTER_PS1_PATH" "-WindowStyle Minimized"
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-ExecutionPolicy Bypass", "-File", "..\..\..\$MARIADB_STARTER_PS1_PATH" -WindowStyle Minimized

Write-Host 'Starting Signum Node Testnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$SIGNUM_NODE_TESTNET_STARTER_PS1_PATH" "-WindowStyle Minimized"

Write-Host 'Starting Signum Explorer Testnet ...'

Start-Sleep -Seconds $SLEEP_SECONDS

# Start Signum Explorer
# Start-Process -FilePath ".\${JAVA_POOL_TESTNET_DIR_NAME}\${JAVA_POOL_TESTNET_UNZIP_NAME}\bin\java.exe" -ArgumentList "-jar", "signum-pool.jar" -WindowStyle Minimized
# Last OK
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'Signum Explorer Testnet'; .\Scripts\supervisord.exe -n -c .\supervisord.conf" -WindowStyle Minimized
# & ..\..\..\$POWERSHELL_EXEC_PATH -ArgumentList "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'Signum Explorer Testnet'; .\Scripts\supervisord.exe -n -c .\supervisord.conf" -WindowStyle Minimized
# Start-Process -FilePath ".\Scripts\supervisord.exe -n -c .\supervisord.conf" -WindowStyle Minimized

Write-Host 'Starting Signum Explorer Testnet ...'
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'Signum Explorer Testnet'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SIGNUM_EXPLORER_TESTNET_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'Signum Explorer Testnet is already running.'
			exit
		} else {
			# Start Signum Explorer Testnet
			# Start-Process "http://localhost:$SIGNUM_EXPLORER_TESTNET_SUPERVISOR_SATUS_PORT"
			Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SIGNUM_EXPLORER_TESTNET_SUPERVISOR_SATUS_PORT"
			# Start-Process "http://localhost:$SIGNUM_EXPLORER_TESTNET_PORT"
			Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SIGNUM_EXPLORER_TESTNET_PORT"
			.\Scripts\supervisord.exe -n -c .\supervisord.conf
		}
    } catch {
        Write-Host 'An error occurred while starting Signum Explorer Testnet: `$_'
    } finally {
        # Always set the title to 'Signum Explorer Testnet Stopped' after Signum Explorer Testnet exits
        ```$host.UI.RawUI.WindowTitle = 'Signum Explorer Testnet Stopped'
    }
"`@ ``
    -WindowStyle Minimized

# TODO check
# & ..\..\..\$POWERSHELL_EXEC_PATH -NoExit -Command .\jre\bin\java -jar signum-node.jar -WindowStyle Minimized
# "jre\bin\java" "-jar" "signum-node.jar" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "Set-Title 'Signum Testnet Node'; Start-Process -NoNewWindow -FilePath 'jre\bin\java' -ArgumentList '-jar', 'signum-node.jar'"

exit
"@

		$content | Out-File -FilePath $SIGNUM_EXPLORER_TESTNET_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_EXPLORER_TESTNET_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_EXPLORER_TESTNET_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_EXPLORER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_EXPLORER_STARTER_EXEC_NAME} ${SIGNUM_EXPLORER_TESTNET_STARTER_EXEC_PATH}

    # Install MariaDB
	if (Test-Path $MARIADB_STARTER_PS1_PATH) {
        Write-Host "MariaDB already installed!"
		question-prompt "Reinstall" "MariaDB" {install_mariadb}
    } else {
		Write-Host "MariaDB is not yet installed."
		question-prompt "Install" "MariaDB" {install_mariadb}
	}

    # Setup MariaDB for Signum Pool Testnet
    question-prompt "Setup" "MariaDB for Signum Explorer Testnet" {setup_mariadb_explorer "Signum Explorer Testnet" "signum-explorer-testnet" "signumuser_explorer_testnet" "signumpassword"}
	
	if ($global:UserResponse -eq "yes") {	
		# Setup .env file with the Signum Explorer database values
		$content = Get-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env
		
		$content = $content | ForEach-Object {
					$_  -replace "^DB_DEFAULT_NAME=.*", "DB_DEFAULT_NAME=$global:DATABASE_NAME" `
						-replace "^DB_DEFAULT_USER=.*", "DB_DEFAULT_USER=$global:DATABASE_USERNAME" `
						-replace "^DB_DEFAULT_PASSWORD=.*", "DB_DEFAULT_PASSWORD=$global:DATABASE_PASSWORD"
				}

		# Write the changes back to the file
		$content | Set-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env
	}
	
	# At this point you have to have Signum Node to install
	if (Test-Path $SIGNUM_NODE_TESTNET_STARTER_PS1_PATH) {
		Write-Host "Signum Node Testnet $SIGNUM_NODE_TESTNET_VERSION already installed."
		question-prompt "Reinstall" "Signum Node Testnet" {Install-SignumTestnet}
	} else {
		Write-Host "Signum Node Testnet $SIGNUM_NODE_TESTNET_VERSION is not yet installed."
		question-prompt "Install" "Signum Node Testnet" {Install-SignumTestnet}
		Pause
	}
	
	Write-Host "Populate database informations from installed Signum Node Testnet properties."
	
	# Read the node.properties file content
	$content = Get-Content -Path $SIGNUM_NODE_TESTNET_PROPERTIES_PATH

	# Initialize variables
	$dbName = $null
	$username = $null
	$password = $null
	
	# Extract the database information
	$content | ForEach-Object {
		if ($_ -match '^DB\.Url=jdbc:mariadb://.+/(.+)') {
			$dbName = $matches[1]
		}
		elseif ($_ -match '^DB\.Username=(.+)') {
			$username = $matches[1]
		}
		elseif ($_ -match '^DB\.Password=(.+)') {
			$password = $matches[1]
		}
	}

	# Display the extracted information
	Write-Output "Signum Mainnet Node Database Name: $dbName"
	# Write-Output "Signum Mainnet Node Database Username: $username"
	# Write-Output "Signum Mainnet Node Database Password: $password"
	
	# Create Read Only User for Signum Node Testnet database access for explorer
	Write-Host "Create Read Only User for Signum Node Testnet database access for explorer"
	question-prompt "Setup" "MariaDB for Signum Explorer Testnet Read Only Node connection" {setup_mariadb_readonly "Signum Explorer Testnet Node connection" "$dbName" "signumuser_node_testnet_readonly" "signumpassword"}
	
	if ($global:UserResponse -eq "yes") {	
		# Setup .env file with the Signum Explorer database values
		$content = Get-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env
		
		$content = $content | ForEach-Object {
					$_  -replace "^DB_JAVA_WALLET_NAME=.*", "DB_JAVA_WALLET_NAME=$global:DATABASE_NAME" `
						-replace "^DB_JAVA_WALLET_USER=.*", "DB_JAVA_WALLET_USER=$global:DATABASE_USERNAME" `
						-replace "^DB_JAVA_WALLET_PASSWORD=.*", "DB_JAVA_WALLET_PASSWORD=$global:DATABASE_PASSWORD"
				}
				
		# Write the changes back to the file
		$content | Set-Content -Path ${SIGNUM_EXPLORER_TESTNET_UNZIP_PATH}\.env	
	}
	
	# TODO further setup of .env and run_waitress.py if want

    Write-Host "Signum Explorer Testnet Installation complete."
	
}

function Install_Certbot {
    Write-Host "Installing Certbot ..."

    # Create Certbot directory
    if (-not (Test-Path -Path "${CERTBOT_DIR_PATH}")) {
        New-Item -Path "${CERTBOT_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${CERTBOT_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${CERTBOT_DIR_PATH}"
    }

	# Create CertbotData\config directory
	if (-not (Test-Path -Path "${CERTBOT_DIR_PATH}\CertbotData\config")) {
		New-Item -Path "${CERTBOT_DIR_PATH}\CertbotData\config" -ItemType Directory | Out-Null
		Write-Host "Created directory: ${CERTBOT_DIR_PATH}\CertbotData\config"
	} else {
		Write-Host "Directory already exists: ${CERTBOT_DIR_PATH}\CertbotData\config"
	}

	# Create CertbotData\work directory
	if (-not (Test-Path -Path "${CERTBOT_DIR_PATH}\CertbotData\work")) {
		New-Item -Path "${CERTBOT_DIR_PATH}\CertbotData\work" -ItemType Directory | Out-Null
		Write-Host "Created directory: ${CERTBOT_DIR_PATH}\CertbotData\work"
	} else {
		Write-Host "Directory already exists: ${CERTBOT_DIR_PATH}\CertbotData\work"
	}

	# Create CertbotData\logs directory
	if (-not (Test-Path -Path "${CERTBOT_DIR_PATH}\CertbotData\logs")) {
		New-Item -Path "${CERTBOT_DIR_PATH}\CertbotData\logs" -ItemType Directory | Out-Null
		Write-Host "Created directory: ${CERTBOT_DIR_PATH}\CertbotData\logs"
	} else {
		Write-Host "Directory already exists: ${CERTBOT_DIR_PATH}\CertbotData\logs"
	}
	
	# download python
    if (Test-Path -Path "${CERTBOT_PYTHON_ZIP_PATH}") {
        Write-Host "${CERTBOT_PYTHON_ZIP_PATH} already downloaded."
    } else {
        # Download the python zip file
        Write-Host "Downloading Python ..."
        # Start-BitsTransfer -Source "${CERTBOT_PYTHON_URL}" -Destination "${CERTBOT_PYTHON_ZIP_PATH}"
		Invoke-WebRequest -Uri $CERTBOT_PYTHON_URL -OutFile $CERTBOT_PYTHON_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${CERTBOT_PYTHON_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Python."
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip python
	if (Test-Path -Path "${CERTBOT_PYTHON_UNZIP_PATH}\python.exe") {
        Write-Host "${CERTBOT_PYTHON_UNZIP_PATH} already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Python to ${CERTBOT_PYTHON_UNZIP_PATH} ..."
        Expand-Archive -Path "${CERTBOT_PYTHON_ZIP_PATH}" -DestinationPath "${CERTBOT_PYTHON_UNZIP_PATH}" -Force
    }
	
	# unzip $CERTBOT_PYTHON_STANDARD_LIB_ZIP_NAME
	if (Test-Path -Path "${CERTBOT_PYTHON_UNZIP_PATH}\$CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME") {
        Write-Host "${CERTBOT_PYTHON_UNZIP_PATH}\$CERTBOT_PYTHON_STANDARD_LIB_ZIP_NAME already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping $CERTBOT_PYTHON_STANDARD_LIB_ZIP_NAME to ${CERTBOT_PYTHON_UNZIP_PATH} ..."
        Expand-Archive -Path "${CERTBOT_PYTHON_UNZIP_PATH}\$CERTBOT_PYTHON_STANDARD_LIB_ZIP_NAME" -DestinationPath "${CERTBOT_PYTHON_UNZIP_PATH}\$CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME" -Force
    }
	
	# download get-pip.py from here: https://bootstrap.pypa.io/get-pip.py
	if (Test-Path -Path "${CERTBOT_PYTHON_UNZIP_PATH}\get-pip.py") {
        Write-Host "${CERTBOT_PYTHON_UNZIP_PATH}\get-pip.py already downloaded."
    } else {
        # Download the get-pip.py file
        Write-Host "Downloading get-pip.py ..."
        # Start-BitsTransfer -Source "${CERTBOT_PYTHON_GETPIP_URL}" -Destination "${CERTBOT_UNZIP_PATH}\get-pip.py"
		Invoke-WebRequest -Uri $CERTBOT_PYTHON_GETPIP_URL -OutFile ${CERTBOT_PYTHON_UNZIP_PATH}\get-pip.py

        # Check if download was successful
        if (-not (Test-Path -Path "${CERTBOT_PYTHON_UNZIP_PATH}\get-pip.py")) {
            Write-Host "Error: Failed to download get-pip.py."
            Pause
            # Install-Menu
            return
        }
    }
	
	# run pyton get-pip.py command
	Write-Host "Installing get-pip.py"
	& "${CERTBOT_PYTHON_UNZIP_PATH}\python.exe" "${CERTBOT_PYTHON_UNZIP_PATH}\get-pip.py"
	
	# uncomment import site from $CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	Write-Host "Setup $CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME._pth file"
	$content = Get-Content -Path ${CERTBOT_PYTHON_UNZIP_PATH}\$CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME._pth
	
	$content = $content | ForEach-Object {
		$_ -replace "#import site", "import site"
	}

	# Write the changes back to the file
	$content | Set-Content -Path ${CERTBOT_PYTHON_UNZIP_PATH}\$CERTBOT_PYTHON_STANDARD_LIB_UNZIP_NAME._pth

	# Install Certbot
	Write-Host "Install Certbot"
	& "${CERTBOT_PYTHON_UNZIP_PATH}\Scripts\pip.exe" install certbot
	
	# Create starter ps1
	if (-not (Test-Path $CERTBOT_STARTER_PS1_PATH)) {
		# Create start-explorer.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Certbot
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting Certbot ...'
Start-Process -FilePath "..\..\${POWERSHELL_EXEC_PATH}" -Verb runAs -ArgumentList "-NoExit", "-Command", `@"
```$host.UI.RawUI.WindowTitle = 'Certbot'
.\${CERTBOT_PYTHON_UNZIP_NAME}\Scripts\certbot.exe certonly ````
	--manual ````
	--config-dir "./$CERTBOT_CONFIGURATION_RELATIVE_PATH" ````
	--work-dir "./$CERTBOT_WORKING_DIR_RELATIVE_PATH" ````
	--logs-dir "./$CERTBOT_LOGS_DIR_RELATIVE_PATH"
"`@ ``


"@

		$content | Out-File -FilePath $CERTBOT_STARTER_PS1_PATH -Force

		Write-Host "${CERTBOT_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${CERTBOT_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${CERTBOT_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${CERTBOT_STARTER_EXEC_NAME} ${CERTBOT_STARTER_EXEC_PATH}

    Write-Host "Certbot Installation complete."
	
}



function install-smartc-web-ui {
    Write-Host "Installing SmartC WEB UI Smart Contract Compiler ..."

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }
	
	# Create SmartContract directory
    if (-not (Test-Path "${SMART_CONTRACT_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${SMART_CONTRACT_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${SMART_CONTRACT_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${SMART_CONTRACT_DIR_NAME}"
    }

    if (Test-Path -Path "${SMARTC_WEB_UI_ZIP_PATH}") {
        Write-Host "${SMARTC_WEB_UI_ZIP_PATH} already downloaded."
    } else {
        # Download SmartC zip file
        Write-Host "Downloading SmartC WEB UI from GitHub ..."
        # Start-BitsTransfer -Source "${SMARTC_WEB_UI_URL}" -Destination "${SMARTC_WEB_UI_ZIP_PATH}"
		Invoke-WebRequest -Uri $SMARTC_WEB_UI_URL -OutFile $SMARTC_WEB_UI_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SMARTC_WEB_UI_ZIP_PATH}")) {
            Write-Host "Error: Failed to download SMARTC WEB UI."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SMARTC_WEB_UI_UNZIP_PATH}") {
        Write-Host "${SMARTC_WEB_UI_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SMARTC_WEB_UI_UNZIP_PATH} ..."
        Expand-Archive -Path "${SMARTC_WEB_UI_ZIP_PATH}" -DestinationPath "${SMART_CONTRACT_DIR_NAME}" -Force
		Rename-Item -Path $SMARTC_WEB_UI_ZIP_DOWNLOAD_PATH -NewName $SMARTC_WEB_UI_UNZIP_NAME
    }

	# Store original package.json
	Write-Host "Store original package.json to package-original.json"
	Copy-Item -Path "$SMARTC_WEB_UI_UNZIP_PATH\package.json" -Destination "$SMARTC_WEB_UI_UNZIP_PATH\package-original.json"
	
	# Initialize package.json
	Write-Host "Initialize package.json"
	$content = Get-Content -Path $SMARTC_WEB_UI_UNZIP_PATH\package.json

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace "npm run dev", "npm run build" `
				-replace '"dev": "TARGET=dev', '"dev": "set TARGET=dev'
		}

		# Write the changes back to the file
		$content | Set-Content -Path $SMARTC_WEB_UI_UNZIP_PATH\package.json
			
	Write-Host "package.json configuration initialized"
	
	# Install node.js portable with npm
	install_nodejs
	
	Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
	# $NODEJS_UNZIP_PATH\npm config set prefix ./npm-global
	# $NODEJS_UNZIP_PATH\npm config set cache ./npm-cache
	
	# npm istall smarc web ui
	Write-Host "Install SmarC packages"

	Set-Location .\$SMARTC_WEB_UI_UNZIP_PATH
	& ..\..\${NODEJS_UNZIP_PATH}\npm.cmd install
	
	Set-Location -Path $PSScriptRoot

	# Create starter ps1
	if (-not (Test-Path $SMARTC_WEB_UI_STARTER_PS1_PATH)) {
		# Create start-smartc.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start SmartC WEB UI
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting SmartC WEB UI ...'

Start-Process -FilePath "..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'SmartC WEB UI'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SMARTC_WEB_UI_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'SmartC WEB UI is already running.'
			exit
		} else {
			Write-Host 'Stop SmartC WEB UI: ctrl + c'
			# Start SmartC WEB UI
			# Start-Process "http://localhost:$SMARTC_WEB_UI_PORT"
			Start-Process -FilePath "..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SMARTC_WEB_UI_PORT"
			Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
			..\..\$NODEJS_UNZIP_PATH\npm.cmd run start
		}
    } catch {
        Write-Host 'An error occurred while starting SmartC WEB UI: `$_'
    } finally {
        # Always set the title to 'SmartC WEB UI Stopped' after SmartC WEB UI exits
        ```$host.UI.RawUI.WindowTitle = 'SmartC WEB UI Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $SMARTC_WEB_UI_STARTER_PS1_PATH -Force

		Write-Host "${SMARTC_WEB_UI_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SMARTC_WEB_UI_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SMARTC_WEB_UI_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${SMARTC_WEB_UI_STARTER_EXEC_NAME} ${SMARTC_WEB_UI_STARTER_EXEC_PATH}

}

function install-smartc-retro-ui {
    Write-Host "Installing SmartC RETRO UI Smart Contract Compiler ..."

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }
	
	# Create SmartContract directory
    if (-not (Test-Path "${SMART_CONTRACT_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${SMART_CONTRACT_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${SMART_CONTRACT_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${SMART_CONTRACT_DIR_NAME}"
    }

    if (Test-Path -Path "${SMARTC_RETRO_UI_ZIP_PATH}") {
        Write-Host "${SMARTC_RETRO_UI_ZIP_PATH} already downloaded."
    } else {
        # Download SmartC zip file
        Write-Host "Downloading SmartC RETRO UI from GitHub ..."
        # Start-BitsTransfer -Source "${SMARTC_RETRO_UI_URL}" -Destination "${SMARTC_RETRO_UI_ZIP_PATH}"
		Invoke-WebRequest -Uri $SMARTC_RETRO_UI_URL -OutFile $SMARTC_RETRO_UI_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SMARTC_RETRO_UI_ZIP_PATH}")) {
            Write-Host "Error: Failed to download SMARTC RETRO UI."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SMARTC_RETRO_UI_UNZIP_PATH}") {
        Write-Host "${SMARTC_RETRO_UI_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SMARTC_RETRO_UI_UNZIP_PATH} ..."
        Expand-Archive -Path "${SMARTC_RETRO_UI_ZIP_PATH}" -DestinationPath "${SMART_CONTRACT_DIR_NAME}" -Force
		Rename-Item -Path $SMARTC_RETRO_UI_ZIP_DOWNLOAD_PATH -NewName $SMARTC_RETRO_UI_UNZIP_NAME
    }
	
	# Store original package.json
	Write-Host "Store original package.json to package-original.json"
	Copy-Item -Path "$SMARTC_RETRO_UI_UNZIP_PATH\package.json" -Destination "$SMARTC_RETRO_UI_UNZIP_PATH\package-original.json"

	# Chanage port from 7000 to $SMARTC_RETRO_UI_PORT
	Write-Host "Initialize package.json"
	$content = Get-Content -Path "$SMARTC_RETRO_UI_UNZIP_PATH\package.json"

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace "-p 7000", "-p $SMARTC_RETRO_UI_PORT" `
				-replace "npm run dev", "npm run build" `
				-replace '"dev": "TARGET=dev', '"dev": "set TARGET=dev'
		}

		# Write the changes back to the file
		$content | Set-Content -Path "$SMARTC_RETRO_UI_UNZIP_PATH\package.json"
			
	Write-Host "package.json configuration initialized"
	
	# Install node.js portable
	install_nodejs
	
	Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
	# $NODEJS_UNZIP_PATH\npm config set prefix ./npm-global
	# $NODEJS_UNZIP_PATH\npm config set cache ./npm-cache
	
	# Istall smarc web ui with npm
	Write-Host "Install SmarC packages"

	Set-Location .\$SMARTC_RETRO_UI_UNZIP_PATH
	& ..\..\${NODEJS_UNZIP_PATH}\npm.cmd install
	
	Set-Location -Path $PSScriptRoot

	# Create starter ps1
	if (-not (Test-Path $SMARTC_RETRO_UI_STARTER_PS1_PATH)) {
		# Create start-smartc.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start SmartC RETRO UI
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting SmartC RETRO UI ...'

Start-Process -FilePath "..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'SmartC RETRO UI'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SMARTC_RETRO_UI_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'SmartC RETRO UI is already running.'
			exit
		} else {
			Write-Host 'Stop SmartC RETRO UI: ctrl + c'
			# Start SmartC RETRO UI
			# Start-Process "http://localhost:$SMARTC_RETRO_UI_PORT"
			Start-Process -FilePath "..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SMARTC_RETRO_UI_PORT"
			Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
			..\..\$NODEJS_UNZIP_PATH\npm.cmd run start
		}
    } catch {
        Write-Host 'An error occurred while starting SmartC RETRO UI: `$_'
    } finally {
        # Always set the title to 'SmartC RETRO UI Stopped' after SmartC RETRO UI exits
        ```$host.UI.RawUI.WindowTitle = 'SmartC RETRO UI Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $SMARTC_RETRO_UI_STARTER_PS1_PATH -Force

		Write-Host "${SMARTC_RETRO_UI_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SMARTC_RETRO_UI_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SMARTC_RETRO_UI_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${SMARTC_RETRO_UI_STARTER_EXEC_NAME} ${SMARTC_RETRO_UI_STARTER_EXEC_PATH}

}

function install-smartc-signum-decompiler {
    Write-Host "Installing SmartC SIGNUM Smart Contract Decompiler ..."

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }
	
	# Create SmartContract directory
    if (-not (Test-Path "${SMART_CONTRACT_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${SMART_CONTRACT_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${SMART_CONTRACT_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${SMART_CONTRACT_DIR_NAME}"
    }

    if (Test-Path -Path "${SMARTC_SIGNUM_DECOMPILER_ZIP_PATH}") {
        Write-Host "${SMARTC_SIGNUM_DECOMPILER_ZIP_PATH} already downloaded."
    } else {
        # Download SmartC zip file
        Write-Host "Downloading SmartC SIGNUM DECOMPILER from GitHub ..."
        # Start-BitsTransfer -Source "${SMARTC_SIGNUM_DECOMPILER_URL}" -Destination "${SMARTC_SIGNUM_DECOMPILER_ZIP_PATH}"
		Invoke-WebRequest -Uri $SMARTC_SIGNUM_DECOMPILER_URL -OutFile $SMARTC_SIGNUM_DECOMPILER_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SMARTC_SIGNUM_DECOMPILER_ZIP_PATH}")) {
            Write-Host "Error: Failed to download SMARTC SIGNUM DECOMPILER."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH}") {
        Write-Host "${SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH} ..."
        Expand-Archive -Path "${SMARTC_SIGNUM_DECOMPILER_ZIP_PATH}" -DestinationPath "${SMART_CONTRACT_DIR_NAME}" -Force
		Rename-Item -Path $SMARTC_SIGNUM_DECOMPILER_ZIP_ORIGINAL_PATH -NewName $SMARTC_SIGNUM_DECOMPILER_UNZIP_NAME
    }
	
	# Store original package.json
	Write-Host "Store original package.json to package-original.json"
	Copy-Item -Path "$SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH\package.json" -Destination "$SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH\package-original.json"

	# Initialize package.json
	Write-Host "Initialize package.json"	
	$content = Get-Content -Path "$SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH\package.json"

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace "-p 7001", "-p $SMARTC_SIGNUM_DECOMPILER_PORT" `
				-replace "npm run dev", "npm run build" `
				-replace '"dev": "TARGET=dev', '"dev": "set TARGET=dev'
		}

		# Write the changes back to the file
		$content | Set-Content -Path $SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH\package.json
			
	Write-Host "package.json configuration initialized"
	
	# Install node.js portable
	install_nodejs
	
	Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
	# $NODEJS_UNZIP_PATH\npm config set prefix ./npm-global
	# $NODEJS_UNZIP_PATH\npm config set cache ./npm-cache
	
	# Istall smarc web ui with npm
	Write-Host "Install SmarC decompiler packages"

	Set-Location .\$SMARTC_SIGNUM_DECOMPILER_UNZIP_PATH
	& ..\..\${NODEJS_UNZIP_PATH}\npm.cmd install
	
	Set-Location -Path $PSScriptRoot

	# Create starter ps1
	if (-not (Test-Path $SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_PATH)) {
		# Create start-smartc-decompiler.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start SmartC SIGNUM DECOMPILER
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting SmartC SIGNUM DECOMPILER ...'

Start-Process -FilePath "..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'Signum Pool Mainnet'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SMARTC_SIGNUM_DECOMPILER_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'SmartC SIGNUM DECOMPILER is already running.'
			exit
		} else {
			Write-Host 'Stop SmartC SIGNUM DECOMPILER: ctrl + c'
			# Start SmartC SIGNUM DECOMPILER
			# Start-Process "http://localhost:$SMARTC_SIGNUM_DECOMPILER_PORT/tester.html"
			Start-Process -FilePath "..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SMARTC_SIGNUM_DECOMPILER_PORT/tester.html"
			Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
			..\..\$NODEJS_UNZIP_PATH\npm.cmd run webpage
		}
    } catch {
        Write-Host 'An error occurred while starting SmartC SIGNUM DECOMPILER: `$_'
    } finally {
        # Always set the title to 'Signum SmartC Decompiler Stopped' after SmartC SIGNUM DECOMPILER exits
        ```$host.UI.RawUI.WindowTitle = 'SmartC SIGNUM DECOMPILER Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_PATH -Force

		Write-Host "${SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SMARTC_SIGNUM_DECOMPILER_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${SMARTC_SIGNUM_DECOMPILER_STARTER_EXEC_NAME} ${SMARTC_SIGNUM_DECOMPILER_STARTER_EXEC_PATH}

}

function install-sc-simulator {
    Write-Host "Installing SC Simulator ..."

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }
	
	# Create SmartContract directory
    if (-not (Test-Path "${SMART_CONTRACT_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${SMART_CONTRACT_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${SMART_CONTRACT_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${SMART_CONTRACT_DIR_NAME}"
    }

    if (Test-Path -Path "${SC_SIMULATOR_ZIP_PATH}") {
        Write-Host "${SC_SIMULATOR_ZIP_PATH} already downloaded."
    } else {
        # Download SC Simulator zip file
        Write-Host "Downloading SC Simulator from GitHub ..."
        # Start-BitsTransfer -Source "${SC_SIMULATOR_URL}" -Destination "${SC_SIMULATOR_ZIP_PATH}"
		Invoke-WebRequest -Uri $SC_SIMULATOR_URL -OutFile $SC_SIMULATOR_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SC_SIMULATOR_ZIP_PATH}")) {
            Write-Host "Error: Failed to download SC Simulator."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SC_SIMULATOR_UNZIP_PATH}") {
        Write-Host "${SC_SIMULATOR_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SC_SIMULATOR_UNZIP_PATH} ..."
        Expand-Archive -Path "${SC_SIMULATOR_ZIP_PATH}" -DestinationPath "${SMART_CONTRACT_DIR_NAME}" -Force
		Rename-Item -Path $SC_SIMULATOR_ZIP_ORIGINAL_PATH -NewName $SC_SIMULATOR_UNZIP_NAME
    }
	
	# Store original package.json
	Write-Host "Store original package.json to package-original.json"
	Copy-Item -Path "$SC_SIMULATOR_UNZIP_PATH\package.json" -Destination "$SC_SIMULATOR_UNZIP_PATH\package-original.json"

	# Initialize package.json
	Write-Host "Initialize package.json"
	$content = Get-Content -Path "$SC_SIMULATOR_UNZIP_PATH\package.json"

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace "-p 7000", "-p $SC_SIMULATOR_PORT" `
				-replace '"dev": "TARGET=dev', '"dev": "set TARGET=dev' `
				-replace '9999\.9\.4', $SMARTC_SIGNUM_COMPILER_VERSION
		}

		# Write the changes back to the file
		$content | Set-Content -Path "$SC_SIMULATOR_UNZIP_PATH\package.json"
			
	Write-Host "package.json configuration initialized"

	# Store original try.html
	Write-Host "Store original try.html to try-original.html"
	Copy-Item -Path "$SC_SIMULATOR_UNZIP_PATH\try.html" -Destination "$SC_SIMULATOR_UNZIP_PATH\try-original.html"
	
	# Initialize try.html
	Write-Host "Initialize try.html"
	$content = Get-Content -Path "$SC_SIMULATOR_UNZIP_PATH\try.html"

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace '9999\.9\.4', $SMARTC_SIGNUM_COMPILER_VERSION
		}

		# Write the changes back to the file
		$content | Set-Content -Path "$SC_SIMULATOR_UNZIP_PATH\try.html"
			
	Write-Host "try.html initialized"
	
	# Install node.js portable
	install_nodejs
	
	Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
	# $NODEJS_UNZIP_PATH\npm config set prefix ./npm-global
	# $NODEJS_UNZIP_PATH\npm config set cache ./npm-cache
	
	# Istall smarc web ui with npm
	Write-Host "Install SmarC packages"

	Set-Location .\$SC_SIMULATOR_UNZIP_PATH
	& ..\..\${NODEJS_UNZIP_PATH}\npm.cmd install
	& ..\..\${NODEJS_UNZIP_PATH}\npm.cmd run build
	
	Set-Location -Path $PSScriptRoot

	# Create starter ps1
	if (-not (Test-Path $SC_SIMULATOR_STARTER_PS1_PATH)) {
		# Create start-smartc.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start SC Simulator
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting SC Simulator ...'

Start-Process -FilePath "..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'SC Simulator'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $SC_SIMULATOR_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'SC Simulator is already running.'
			exit
		} else {
			Write-Host 'Stop SC Simulator: ctrl + c'
			# Start SC Simulator
			# Start-Process "http://localhost:$SC_SIMULATOR_PORT/try.html"
			Start-Process -FilePath "..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$SC_SIMULATOR_PORT/try.html"
			Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
			..\..\$NODEJS_UNZIP_PATH\npm.cmd run start
		}
    } catch {
        Write-Host 'An error occurred while starting SC Simulator: `$_'
    } finally {
        # Always set the title to 'SC Simulator Stopped' after SC Simulator exits
        ```$host.UI.RawUI.WindowTitle = 'SC Simulator Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $SC_SIMULATOR_STARTER_PS1_PATH -Force

		Write-Host "${SC_SIMULATOR_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SC_SIMULATOR_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SC_SIMULATOR_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${SC_SIMULATOR_STARTER_EXEC_NAME} ${SC_SIMULATOR_STARTER_EXEC_PATH}

}

function install-signum-d-or {
    Write-Host "Installing Signum-D-OR ..."
	
	# Create SmartContract directory
    if (-not (Test-Path "${SMART_CONTRACT_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${SMART_CONTRACT_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${SMART_CONTRACT_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${SMART_CONTRACT_DIR_NAME}"
    }

    if (Test-Path -Path "${SIGNUM_D_OR_ZIP_PATH}") {
        Write-Host "${SIGNUM_D_OR_ZIP_PATH} already downloaded."
    } else {
        # Download Signum-D-OR zip file
        Write-Host "Downloading Signum-D-OR from GitHub ..."
        # Start-BitsTransfer -Source "${SIGNUM_D_OR_URL}" -Destination "${SIGNUM_D_OR_ZIP_PATH}"
		Invoke-WebRequest -Uri $SIGNUM_D_OR_URL -OutFile $SIGNUM_D_OR_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SIGNUM_D_OR_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Signum-D-OR."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SIGNUM_D_OR_UNZIP_PATH}") {
        Write-Host "${SIGNUM_D_OR_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SIGNUM_D_OR_UNZIP_PATH} ..."
        Expand-Archive -Path "${SIGNUM_D_OR_ZIP_PATH}" -DestinationPath "${SMART_CONTRACT_DIR_NAME}" -Force
		Rename-Item -Path $SIGNUM_D_OR_ZIP_ORIGINAL_PATH -NewName $SIGNUM_D_OR_UNZIP_NAME
    }	

	# Create starter ps1
	if (-not (Test-Path $SIGNUM_D_OR_STARTER_PS1_PATH)) {
		# Create start-smartc.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start SC Simulator
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting Signum-D-OR ...'

Start-Process ./signum-d-or.html

exit
"@

		$content | Out-File -FilePath $SIGNUM_D_OR_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_D_OR_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_D_OR_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_D_OR_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_D_OR_STARTER_EXEC_NAME} ${SIGNUM_D_OR_STARTER_EXEC_PATH}

}

function install-smartj-compiler {
    Write-Host "Installing SmartJ SIGNUM Smart Contract Compiler ..."
	
	# Create SmartContract directory
    if (-not (Test-Path "${SMART_CONTRACT_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${SMART_CONTRACT_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${SMART_CONTRACT_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${SMART_CONTRACT_DIR_NAME}"
    }

    if (Test-Path -Path "${SMARTJ_ZIP_PATH}") {
        Write-Host "${SMARTJ_ZIP_PATH} already downloaded."
    } else {
        # Download SmartC zip file
        Write-Host "Downloading SmartJ SIGNUM COMPILER from GitHub ..."
        # Start-BitsTransfer -Source "${SMARTJ_URL}" -Destination "${SMARTJ_ZIP_PATH}"
		Invoke-WebRequest -Uri $SMARTJ_URL -OutFile $SMARTJ_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${SMARTJ_ZIP_PATH}")) {
            Write-Host "Error: Failed to download SMARTC SIGNUM DECOMPILER."
            Pause
            # Install-Menu
            return
        }
    }

    if (Test-Path -Path "${SMARTJ_UNZIP_PATH}") {
        Write-Host "${SMARTJ_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Signum to ${SMARTJ_UNZIP_PATH} ..."
        Expand-Archive -Path "${SMARTJ_ZIP_PATH}" -DestinationPath "${SMART_CONTRACT_DIR_NAME}" -Force
		Rename-Item -Path $SMARTJ_ZIP_ORIGINAL_PATH -NewName $SMARTJ_UNZIP_NAME
    }
	
	# Rename build.gradle to build-original.gradle
	if (Test-Path -Path "$SMARTJ_UNZIP_PATH\build-original.gradle") {
        Write-Host "build-original.gradle already installed."
    } else {
        # Rename build.gradle to build-original.gradle
        Write-Host "Rename build.gradle to build-original.gradle"
        Rename-Item -Path $SMARTJ_UNZIP_PATH\build.gradle -NewName "build-original.gradle"
    }
	
	# Initialize build.gradle
	Write-Host "Initialize build.gradle"	
		$content = 
@"
plugins {
    id 'java'
    id 'maven'
    id 'com.github.johnrengelman.shadow' version '6.1.0'
}
// Publishing stuff
group = 'com.github.jjos2372'
sourceCompatibility = 1.8
targetCompatibility = 1.8
repositories {
    jcenter()
    mavenCentral()
    maven { url 'https://jitpack.io' }
}
dependencies {
    implementation 'org.ow2.asm:asm-tree:7.1'
    implementation 'com.github.signum-network:signumj:f2522b5480'
    implementation 'io.reactivex.rxjava2:rxjava:2.2.15'
    implementation 'com.github.jiconfont:jiconfont-swing:1.0.0'
    implementation 'com.github.jiconfont:jiconfont-font_awesome:4.7.0.1'
    implementation 'org.apache.logging.log4j:log4j-api:2.15.0'
    implementation 'org.apache.logging.log4j:log4j-core:2.15.0'
    testImplementation 'junit:junit:4.12'
    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.0'
}
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}
task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}
artifacts {
    archives sourcesJar
    archives javadocJar
}
shadowJar {
    archiveClassifier.set('')
    manifest {
        attributes 'Main-Class': 'bt.sample.Auction'
        attributes 'Multi-Release': 'true'
    }
}
build.dependsOn shadowJar
"@

	$content | Out-File -FilePath $SMARTJ_UNZIP_PATH\build.gradle -Force
	Write-Host "build.gradle successfully initialized."
	
	# Create jre directory
    if (-not (Test-Path -Path "${JAVA_SMARTJ_DIR_PATH}")) {
        New-Item -Path "${JAVA_SMARTJ_DIR_PATH}" -ItemType Directory | Out-Null
        Write-Host "Created directory: ${JAVA_SMARTJ_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${JAVA_SMARTJ_DIR_PATH}"
    }
	
	# download java
	if (Test-Path -Path "${JAVA_SMARTJ_ZIP_PATH}") {
        Write-Host "${JAVA_SMARTJ_ZIP_PATH} already downloaded."
    } else {
        # Download Java zip file
        Write-Host "Downloading Java ..."
        # Start-BitsTransfer -Source "${JAVA_SMARTJ_URL}" -Destination "${JAVA_SMARTJ_ZIP_PATH}"
		Invoke-WebRequest -Uri $JAVA_SMARTJ_URL -OutFile $JAVA_SMARTJ_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path -Path "${JAVA_SMARTJ_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Java."
            Pause
            # Install-Menu
            return
        }
    }
	
	# unzip java
	if (Test-Path -Path "${JAVA_SMARTJ_UNZIP_PATH}") {
        Write-Host "${JAVA_SMARTJ_ZIP_PATH} already unzipped."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Java to ${JAVA_SMARTJ_UNZIP_PATH} ..."
        Expand-Archive -Path "${JAVA_SMARTJ_ZIP_PATH}" -DestinationPath "${JAVA_SMARTJ_DIR_PATH}" -Force
    }
	
	# Copy gradlew.bat to gradlew-original.bat
	if (Test-Path -Path "$SMARTJ_UNZIP_PATH\gradlew-original.bat") {
        Write-Host "gradlew-original.bat already installed."
    } else {
        # Copy build.gradle to build-original.gradle
        Write-Host "Copy gradlew.bat to gradlew-original.bat"
        Copy-Item -Path $SMARTJ_UNZIP_PATH\gradlew.bat -Destination $SMARTJ_UNZIP_PATH\gradlew-original.bat
    }

	# Initialize gradlew.bat
	
	# Load the content of the file
	$content = Get-Content -Path $SMARTJ_UNZIP_PATH\gradlew.bat
	
	# Process each line using regex to add '#' only if there's no '#' before the target
	$content = $content | ForEach-Object {
		$_ -replace "^\s*if defined JAVA_HOME goto findJavaFromJavaHome", "@rem if defined JAVA_HOME goto findJavaFromJavaHome" `
		   -replace "^\s*set JAVA_EXE=java.exe", "set JAVA_EXE=.\${JAVA_SMARTJ_DIR_NAME}\${JAVA_SMARTJ_UNZIP_NAME}\bin\java.exe"
	}

	# Write the changes back to the file
	$content | Set-Content -Path $SMARTJ_UNZIP_PATH\gradlew.bat
	
	Write-Host "gradlew.bat initialized"

	Set-Location .\$SMARTJ_UNZIP_PATH
	.\gradlew.bat clean shadowJar
	
	Set-Location -Path $PSScriptRoot

	# Create starter ps1
	if (-not (Test-Path $SMARTJ_STARTER_PS1_PATH)) {
		# Create start-smartc-decompiler.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start SmartJ SIGNUM COMPILER
Set-Location -Path `$PSScriptRoot

Write-Host 'Instructions in case You want to run a different java Smart Contract:'
Write-Host '1. If You want to run a different java Smart Contract You should update the line:'
Write-Host '`tattributes ''Main-Class'': ''bt.sample.Auction'' with the proper java file within build.grandle'
Write-Host '2. Run .\gradlew.bat clean shadowJar command from CMD to build java application, or select "yes" for the question:'
Write-Host '`t"Do you want to build java application? (yes/no)"'
Write-Host '3. Run application from CMD, Start SmartJ from installer, run $SMARTJ_STARTER_EXEC_NAME, or run $SMARTJ_STARTER_PS1_NAME'
Write-Host ''

`$userChoice = Read-Host 'Do you want to build java application? (yes/no)'
if (`$userChoice -match '^(yes|y|Y)$') {
	.\gradlew.bat clean shadowJar
}

Write-Host 'Starting SmartJ SIGNUM Smart Contract Compiler ...'

.\${JAVA_SMARTJ_DIR_NAME}\${JAVA_SMARTJ_UNZIP_NAME}\bin\java.exe -jar .\build\libs\blocktalk.jar

"@

		$content | Out-File -FilePath $SMARTJ_STARTER_PS1_PATH -Force

		Write-Host "${SMARTJ_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SMARTJ_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SMARTJ_STARTER_PS1_NAME} ..\..\${POWERSHELL_EXEC_PATH} ${SMARTJ_STARTER_EXEC_NAME} ${SMARTJ_STARTER_EXEC_PATH}

}

function signum-starter-ps1 ($name, $file, $port) {

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }

    if (-not (Test-Path $file)) {

        # Create start-node.ps1 file with the desired content
        $content = 
@"
# PowerShell script to start Signum Node
Set-Location -Path `$PSScriptRoot

# Start MariaDB
Write-Host 'Starting MariaDB ...'
..\..\..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "..\..\..\$MARIADB_STARTER_PS1_PATH" "-WindowStyle Minimized"
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-ExecutionPolicy Bypass", "-File", "..\..\..\$MARIADB_STARTER_PS1_PATH" -WindowStyle Minimized

Start-Sleep -Seconds $SLEEP_SECONDS

# Start Signum Node
# Start-Process -FilePath "jre\bin\java" -ArgumentList "-jar", "signum-node.jar" -WindowStyle Minimized
# Last OK
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'Signum Node $name'; jre\bin\java -jar signum-node.jar"

# TODO check
# & ..\..\..\$POWERSHELL_EXEC_PATH -NoExit -Command .\jre\bin\java -jar signum-node.jar -WindowStyle Minimized
# "jre\bin\java" "-jar" "signum-node.jar" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\$POWERSHELL_EXEC_PATH" -ArgumentList "-NoExit", "-Command", "Set-Title 'Signum Mainnet Node'; Start-Process -NoNewWindow -FilePath 'jre\bin\java' -ArgumentList '-jar', 'signum-node.jar'"

Write-Host 'Starting Signum Node $name ...'
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'Signum Node $name'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $port -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'Signum Node $name is already running.'
			exit
		} else {
			# Start Signum Node $name
			# Start-Process "http://localhost:$port"
			try {
				Start-Process -FilePath "..\..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$port"
			} catch {
        		Write-Host 'An error occurred while starting Browser' -ForegroundColor Red
    		}
			.\jre\bin\java -jar signum-node.jar
		}
    } catch {
        Write-Host 'An error occurred while starting Signum Node ${name}' -ForegroundColor Red
    } finally {
        # Always set the title to 'Signum Node $name Stopped' after Signum Node $name exits
        ```$host.UI.RawUI.WindowTitle = 'Signum Node $name Stopped'
    }
"`@ ``
    -WindowStyle Minimized
exit
"@

        $content | Out-File -FilePath $file -Force

        Write-Host "${file} successfully created."
    } else {
        Write-Host "File already exists: ${file}"
    }
}

function create-starter-ps1-exec (${file-ps1}, ${powershell_exec_path}, ${file-exec}, ${file-exec-path}) {

    if (-not (Test-Path ${file-exec-path})) {
        # Create starter batch file with the desired content
        $content = 
@"
cd %~dp0
${powershell_exec_path} -ExecutionPolicy Bypass -File ".\${file-ps1}"
"@
        $content | Out-File -FilePath ${file-exec-path} -Force

        Write-Host "${file-exec-path} successfully created."
    } else {
        Write-Host "File already exists: ${file-exec-path}"
    }
}

function install_IPFS_CLIENT {

	# Install Chromium browser
	if (-not (Test-Path -Path "$BROWSER_CHROMIUM_EXEC_PATH")) {
        install_chromium_browser
    } else {
        Write-Host "Chromium browser already installed"
    }

	# Create IPFS directory
	if (-not (Test-Path "${IPFS_DIR_NAME}")) {
		New-Item -ItemType Directory -Path "${IPFS_DIR_NAME}" | Out-Null
		Write-Host "Created directory: ${IPFS_DIR_NAME}"
	} else {
		Write-Host "Directory already exists: ${IPFS_DIR_NAME}"
	}

	# Create IPFS_CLIENT directory
	if (-not (Test-Path "${IPFS_CLIENT_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLIENT_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLIENT_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLIENT_DIR_PATH}"
	}

	# Create IPFS Repository directory
	if (-not (Test-Path "${IPFS_CLIENT_REPOSITORY_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLIENT_REPOSITORY_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLIENT_REPOSITORY_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLIENT_REPOSITORY_DIR_PATH}"
	}

	if (Test-Path "${IPFS_CLIENT_ZIP_PATH}") {
		Write-Host "${IPFS_CLIENT_ZIP_PATH} already downloaded."
	} else {
		# Download HeidiSQL
		Write-Host "Downloading IPFS_CLIENT ..."
		# Start-BitsTransfer -Source "${IPFS_CLIENT_URL}" -Destination "${IPFS_CLIENT_ZIP_PATH}"
		Invoke-WebRequest -Uri ${IPFS_CLIENT_URL} -OutFile ${IPFS_CLIENT_ZIP_PATH}

		# Check if download was successful
		if (-not (Test-Path "${IPFS_CLIENT_ZIP_PATH}")) {
			Write-Host "Error: Failed to download IPFS_CLIENT."
			Pause
			return
		}
	}

	if (Test-Path "${IPFS_CLIENT_UNZIP_PATH}") {
		Write-Host "${IPFS_CLIENT_UNZIP_PATH} already installed."
	} else {
		# Unzip the downloaded file to the installation directory
		Write-Host "Unzipping IPFS_CLIENT to $IPFS_CLIENT_UNZIP_PATH ..."
		Expand-Archive -Path "$IPFS_CLIENT_ZIP_PATH" -DestinationPath "$IPFS_CLIENT_DIR_PATH" -Force
		# Rename the folder
		Rename-Item -Path $IPFS_CLIENT_DIR_PATH\kubo -NewName "$IPFS_CLIENT_UNZIP_NAME"
	}

	if (Test-Path "${IPFS_CLIENT_CONFIG_DIR_PATH}") {
		Write-Host "IPFS client already configured."
	} else {
		# IPFS init
		$env:IPFS_PATH = $IPFS_CLIENT_REPOSITORY_DIR_PATH
		& ".\$IPFS_CLIENT_EXEC_PATH" init

		# Replace ports to defined ones
		<#
		$content = Get-Content -Path $IPFS_CLIENT_CONFIG_DIR_PATH

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace "4001", "$IPFS_CLIENT_SWARN_PORT" `
				-replace "5001", "$IPFS_CLIENT_API_PORT" `
				-replace "8080", "$IPFS_CLIENT_GATEWAY_PORT"
		}

		# Write the changes back to the file
		$content | Set-Content -Path $IPFS_CLIENT_CONFIG_DIR_PATH
		#>

		Write-Host "Configuration initialized"
	}

	# Create starter ps1
	if (-not (Test-Path $IPFS_CLIENT_STARTER_PS1_PATH)) {
		# Create start-ipfs-client.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start IPFS_CLIENT
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting IPFS_CLIENT ...'

Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'IPFS_CLIENT'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $IPFS_CLIENT_API_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'IPFS_CLIENT is already running.'
			exit
		} else {
		 	# Start-Process "http://localhost:$IPFS_CLIENT_API_PORT/webui"
			Start-Process -FilePath "..\..\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}", "http://localhost:$IPFS_CLIENT_API_PORT/webui"
			Write-Host 'Stop IPFS_CLIENT: ctrl + c'
			# Start IPFS_CLIENT
			```$env:IPFS_PATH = '..\..\$IPFS_CLIENT_REPOSITORY_DIR_NAME'
			.\$IPFS_CLIENT_EXEC_NAME config Datastore.StorageMax "$IPFS_CLIENT_STORAGEMAX"
			.\$IPFS_CLIENT_EXEC_NAME daemon --enable-gc
		}
    } catch {
        Write-Host 'An error occurred while starting IPFS_CLIENT: `$_'
    } finally {
        # Always set the title to 'IPFS_CLIENT Stopped' after IPFS_CLIENT exits
        ```$host.UI.RawUI.WindowTitle = 'IPFS_CLIENT Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $IPFS_CLIENT_STARTER_PS1_PATH -Force

		Write-Host "${IPFS_CLIENT_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${IPFS_CLIENT_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${IPFS_CLIENT_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${IPFS_CLIENT_STARTER_EXEC_NAME} ${IPFS_CLIENT_STARTER_EXEC_PATH}

	Write-Host "IPFS_CLIENT installed successfully."

}

function install_IPFS_CLUSTER_FOLLOW {
	# Create IPFS directory
	if (-not (Test-Path "${IPFS_DIR_NAME}")) {
		New-Item -ItemType Directory -Path "${IPFS_DIR_NAME}" | Out-Null
		Write-Host "Created directory: ${IPFS_DIR_NAME}"
	} else {
		Write-Host "Directory already exists: ${IPFS_DIR_NAME}"
	}

	# Create IPFS_CLUSTER_FOLLOW directory
	if (-not (Test-Path "${IPFS_CLUSTER_FOLLOW_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLUSTER_FOLLOW_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLUSTER_FOLLOW_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLUSTER_FOLLOW_DIR_PATH}"
	}

	if (Test-Path "${IPFS_CLUSTER_FOLLOW_ZIP_PATH}") {
		Write-Host "${IPFS_CLUSTER_FOLLOW_ZIP_PATH} already downloaded."
	} else {
		# Download IPFS_CLUSTER_FOLLOW
		Write-Host "Downloading IPFS_CLUSTER_FOLLOW ..."
		# Start-BitsTransfer -Source "${IPFS_CLUSTER_FOLLOW_URL}" -Destination "${IPFS_CLUSTER_FOLLOW_ZIP_PATH}"
		Invoke-WebRequest -Uri ${IPFS_CLUSTER_FOLLOW_URL} -OutFile ${IPFS_CLUSTER_FOLLOW_ZIP_PATH}

		# Check if download was successful
		if (-not (Test-Path "${IPFS_CLUSTER_FOLLOW_ZIP_PATH}")) {
			Write-Host "Error: Failed to download IPFS_CLUSTER_FOLLOW."
			Pause
			return
		}
	}

	if (Test-Path "${IPFS_CLUSTER_FOLLOW_UNZIP_PATH}") {
		Write-Host "${IPFS_CLUSTER_FOLLOW_UNZIP_PATH} already installed."
	} else {
		# Unzip the downloaded file to the installation directory
		Write-Host "Unzipping IPFS_CLUSTER_FOLLOW to $IPFS_CLUSTER_FOLLOW_UNZIP_PATH ..."
		Expand-Archive -Path "$IPFS_CLUSTER_FOLLOW_ZIP_PATH" -DestinationPath "$IPFS_CLUSTER_FOLLOW_DIR_PATH" -Force
		# Rename the folder
		Rename-Item -Path $IPFS_CLUSTER_FOLLOW_DIR_PATH\ipfs-cluster-follow -NewName "$IPFS_CLUSTER_FOLLOW_UNZIP_NAME"
	}

	# Create Data directory
	if (-not (Test-Path "${IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH}"
	}

	# Create Signumart directory
	<#
	if (-not (Test-Path "${IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH}"
	}
	#>

	if (Test-Path "${IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH}") {
		Write-Host "${IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH} already downloaded."
	} else {
		# Download IPFS_CLUSTER_FOLLOW
		Write-Host "Downloading IPFS_CLUSTER_FOLLOW ..."
		# Start-BitsTransfer -Source "${IPFS_CLUSTER_FOLLOW_URL}" -Destination "${IPFS_CLUSTER_FOLLOW_ZIP_PATH}"
		Invoke-WebRequest -Uri ${IPFS_CLUSTER_FOLLOW_SIGNUMART_CONFIG_URL} -OutFile ${IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH}

		# Replace ports to defined ones
		<#
		$content = Get-Content -Path $IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH

		# Process each line using regex to add '#' only if there's no '#' before the target
		$content = $content | ForEach-Object {
			$_ 	-replace "4001", "$IPFS_CLIENT_SWARN_PORT" `
				-replace "5001", "$IPFS_CLIENT_API_PORT" `
				-replace "8080", "$IPFS_CLIENT_GATEWAY_PORT"
		}

		# Write the changes back to the file
		$content | Set-Content -Path $IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH
		#>
		
		$env:IPFS_CLUSTER_PATH = ".\$IPFS_CLUSTER_FOLLOW_DATA_DIR_PATH"
		$env:CLUSTER_RESTAPI_HTTPLISTENMULTIADDRESS = "/ip4/127.0.0.1/tcp/$IPFS_CLUSTER_FOLLOW_PORT"
		# & ".\$IPFS_CLUSTER_FOLLOW_EXEC_PATH" "$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_NAME" init ".\$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH" --config ".\$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH"
		& ".\$IPFS_CLUSTER_FOLLOW_EXEC_PATH" "$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_NAME" init "$IPFS_CLUSTER_FOLLOW_SIGNUMART_CONFIG_URL"

		# Rename-Item -Path ".\$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH\$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_NAME" -NewName "original_${IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_NAME}"
		# Copy-Item -Path ".\$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH" -Destination ".\$IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_PATH\$IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_NAME"

		Write-Host "Configuration initialized"

		# Check if download was successful
		if (-not (Test-Path "${IPFS_CLUSTER_FOLLOW_SIGNUMART_SERVICE_JSON_PATH}")) {
			Write-Host "Error: Failed to download IPFS_CLUSTER_FOLLOW SignumART service.json file."
			Pause
			return
		}
	}

	# Create starter ps1
	if (-not (Test-Path $IPFS_CLUSTER_FOLLOW_STARTER_PS1_PATH)) {
		# Create start-ipfs-cluster-follow.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start IPFS_CLUSTER_FOLLOW
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting IPFS_CLUSTER_FOLLOW ...'

Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'SignumArt IPFS_CLUSTER_FOLLOW'
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $IPFS_CLUSTER_FOLLOW_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
			Write-Host 'SignumArt IPFS_CLUSTER_FOLLOW is already running.'
			exit
		} else {
			Write-Host 'Stop SignumArt IPFS_CLUSTER_FOLLOW: ctrl + c'
			# Start SignumArt IPFS_CLUSTER_FOLLOW-Cluster
			```$env:IPFS_PATH = '..\..\$IPFS_CLIENT_REPOSITORY_DIR_NAME'
			```$env:IPFS_CLUSTER_PATH = '.\$IPFS_CLUSTER_FOLLOW_DATA_DIR_NAME'
			```$env:CLUSTER_RESTAPI_HTTPLISTENMULTIADDRESS = '/ip4/127.0.0.1/tcp/$IPFS_CLUSTER_FOLLOW_PORT'
			.\$IPFS_CLUSTER_FOLLOW_EXEC_NAME $IPFS_CLUSTER_FOLLOW_SIGNUMART_DIR_NAME run
		}
    } catch {
        Write-Host 'An error occurred while starting SignumArt IPFS_CLUSTER_FOLLOW: `$_'
    } finally {
        # Always set the title to 'SignumArt IPFS_CLUSTER_FOLLOW Stopped' after SignumArt IPFS_CLUSTER_FOLLOW exits
        ```$host.UI.RawUI.WindowTitle = 'SignumArt IPFS_CLUSTER_FOLLOW Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $IPFS_CLUSTER_FOLLOW_STARTER_PS1_PATH -Force

		Write-Host "${IPFS_CLUSTER_FOLLOW_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${IPFS_CLUSTER_FOLLOW_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${IPFS_CLUSTER_FOLLOW_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${IPFS_CLUSTER_FOLLOW_STARTER_EXEC_NAME} ${IPFS_CLUSTER_FOLLOW_STARTER_EXEC_PATH}

	Write-Host "IPFS_CLUSTER_FOLLOW installed successfully."

}

function install_IPFS_CLUSTER_CTL {
	# Create IPFS directory
	if (-not (Test-Path "${IPFS_DIR_NAME}")) {
		New-Item -ItemType Directory -Path "${IPFS_DIR_NAME}" | Out-Null
		Write-Host "Created directory: ${IPFS_DIR_NAME}"
	} else {
		Write-Host "Directory already exists: ${IPFS_DIR_NAME}"
	}

	# Create IPFS_CLUSTER_CTL directory
	if (-not (Test-Path "${IPFS_CLUSTER_CTL_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLUSTER_CTL_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLUSTER_CTL_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLUSTER_CTL_DIR_PATH}"
	}

	if (Test-Path "${IPFS_CLUSTER_CTL_ZIP_PATH}") {
		Write-Host "${IPFS_CLUSTER_CTL_ZIP_PATH} already downloaded."
	} else {
		# Download IPFS_CLUSTER_CTL
		Write-Host "Downloading IPFS_CLUSTER_CTL ..."
		# Start-BitsTransfer -Source "${IPFS_CLUSTER_CTL_URL}" -Destination "${IPFS_CLUSTER_CTL_ZIP_PATH}"
		Invoke-WebRequest -Uri ${IPFS_CLUSTER_CTL_URL} -OutFile ${IPFS_CLUSTER_CTL_ZIP_PATH}

		# Check if download was successful
		if (-not (Test-Path "${IPFS_CLUSTER_CTL_ZIP_PATH}")) {
			Write-Host "Error: Failed to download IPFS_CLUSTER_CTL."
			Pause
			return
		}
	}

	if (Test-Path "${IPFS_CLUSTER_CTL_UNZIP_PATH}") {
		Write-Host "${IPFS_CLUSTER_CTL_UNZIP_PATH} already installed."
	} else {
		# Unzip the downloaded file to the installation directory
		Write-Host "Unzipping IPFS_CLUSTER_CTL to $IPFS_CLUSTER_CTL_UNZIP_PATH ..."
		Expand-Archive -Path "$IPFS_CLUSTER_CTL_ZIP_PATH" -DestinationPath "$IPFS_CLUSTER_CTL_DIR_PATH" -Force
		# Rename the folder
		Rename-Item -Path $IPFS_CLUSTER_CTL_DIR_PATH\ipfs-cluster-ctl -NewName "$IPFS_CLUSTER_CTL_UNZIP_NAME"
	}

	# Create starter ps1
	if (-not (Test-Path $IPFS_CLUSTER_CTL_STARTER_PS1_PATH)) {
		# Create start-ipfs-cluster-ctl.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start IPFS_CLUSTER_CTL
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting IPFS_CLUSTER_CTL ...'

Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'SignumArt IPFS_CLUSTER_CTL'
		```$env:IPFS_PATH = '..\..\$IPFS_CLIENT_REPOSITORY_DIR_NAME'
		.\$IPFS_CLUSTER_CTL_EXEC_NAME peers ls
    } catch {
        Write-Host 'An error occurred while starting SignumArt IPFS_CLUSTER_CTL: `$_'
    } finally {
        # Always set the title to 'SignumArt IPFS_CLUSTER_CTL Stopped' after SignumArt IPFS_CLUSTER_CTL exits
        ```$host.UI.RawUI.WindowTitle = 'SignumArt IPFS_CLUSTER_CTL Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $IPFS_CLUSTER_CTL_STARTER_PS1_PATH -Force

		Write-Host "${IPFS_CLUSTER_CTL_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${IPFS_CLUSTER_CTL_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${IPFS_CLUSTER_CTL_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${IPFS_CLUSTER_CTL_STARTER_EXEC_NAME} ${IPFS_CLUSTER_CTL_STARTER_EXEC_PATH}

	Write-Host "IPFS_CLUSTER_CTL installed successfully."

}

function install_IPFS_CLUSTER_SERVICE {
	# Create IPFS directory
	if (-not (Test-Path "${IPFS_DIR_NAME}")) {
		New-Item -ItemType Directory -Path "${IPFS_DIR_NAME}" | Out-Null
		Write-Host "Created directory: ${IPFS_DIR_NAME}"
	} else {
		Write-Host "Directory already exists: ${IPFS_DIR_NAME}"
	}

	# Create IPFS_CLUSTER_SERVICE directory
	if (-not (Test-Path "${IPFS_CLUSTER_SERVICE_DIR_PATH}")) {
		New-Item -ItemType Directory -Path "${IPFS_CLUSTER_SERVICE_DIR_PATH}" | Out-Null
		Write-Host "Created directory: ${IPFS_CLUSTER_SERVICE_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${IPFS_CLUSTER_SERVICE_DIR_PATH}"
	}

	if (Test-Path "${IPFS_CLUSTER_SERVICE_ZIP_PATH}") {
		Write-Host "${IPFS_CLUSTER_SERVICE_ZIP_PATH} already downloaded."
	} else {
		# Download IPFS_CLUSTER_SERVICE
		Write-Host "Downloading IPFS_CLUSTER_SERVICE ..."
		# Start-BitsTransfer -Source "${IPFS_CLUSTER_SERVICE_URL}" -Destination "${IPFS_CLUSTER_SERVICE_ZIP_PATH}"
		Invoke-WebRequest -Uri ${IPFS_CLUSTER_SERVICE_URL} -OutFile ${IPFS_CLUSTER_SERVICE_ZIP_PATH}

		# Check if download was successful
		if (-not (Test-Path "${IPFS_CLUSTER_SERVICE_ZIP_PATH}")) {
			Write-Host "Error: Failed to download IPFS_CLUSTER_SERVICE."
			Pause
			return
		}
	}

	if (Test-Path "${IPFS_CLUSTER_SERVICE_UNZIP_PATH}") {
		Write-Host "${IPFS_CLUSTER_SERVICE_UNZIP_PATH} already installed."
	} else {
		# Unzip the downloaded file to the installation directory
		Write-Host "Unzipping IPFS_CLUSTER_SERVICE to $IPFS_CLUSTER_SERVICE_UNZIP_PATH ..."
		Expand-Archive -Path "$IPFS_CLUSTER_SERVICE_ZIP_PATH" -DestinationPath "$IPFS_CLUSTER_SERVICE_DIR_PATH" -Force
		# Rename the folder
		Rename-Item -Path $IPFS_CLUSTER_SERVICE_DIR_PATH\ipfs-cluster-service -NewName "$IPFS_CLUSTER_SERVICE_UNZIP_NAME"
	}

	# Create starter ps1
	if (-not (Test-Path $IPFS_CLUSTER_SERVICE_STARTER_PS1_PATH)) {
		# Create start-ipfs-cluster-service.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start IPFS_CLUSTER_SERVICE
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting IPFS_CLUSTER_SERVICE ...'

Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'SignumArt IPFS_CLUSTER_SERVICE'
		.\$IPFS_CLUSTER_SERVICE_EXEC_NAME
    } catch {
        Write-Host 'An error occurred while starting SignumArt IPFS_CLUSTER_SERVICE: `$_'
    } finally {
        # Always set the title to 'SignumArt IPFS_CLUSTER_SERVICE Stopped' after SignumArt IPFS_CLUSTER_SERVICE exits
        ```$host.UI.RawUI.WindowTitle = 'SignumArt IPFS_CLUSTER_SERVICE Stopped'
    }
"`@ ``
    -WindowStyle Minimized

exit
"@

		$content | Out-File -FilePath $IPFS_CLUSTER_SERVICE_STARTER_PS1_PATH -Force

		Write-Host "${IPFS_CLUSTER_SERVICE_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${IPFS_CLUSTER_SERVICE_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${IPFS_CLUSTER_SERVICE_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${IPFS_CLUSTER_SERVICE_STARTER_EXEC_NAME} ${IPFS_CLUSTER_SERVICE_STARTER_EXEC_PATH}

	Write-Host "IPFS_CLUSTER_SERVICE installed successfully."

}

function install_SignumArt_IPFS_CLIENT-Cluster {
	install_IPFS_CLIENT
	install_IPFS_CLUSTER_FOLLOW
	install_IPFS_CLUSTER_CTL
	install_IPFS_CLUSTER_SERVICE
	
	# Create .bat and .ps1 to start IPFS Client and Cluster Follow
	# Create starter ps1
	if (-not (Test-Path $IPFS_SIGNUMART_STARTER_PS1_PATH)) {
		# Create start-ipfs-signumart.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start IPFS_CLUSTER_FOLLOW
Set-Location -Path `$PSScriptRoot

Write-Host 'Starting SignumArt IPFS ...'

# Start-Process -FilePath ".\$IPFS_CLIENT_DIR_NAME\$IPFS_CLIENT_STARTER_PS1_NAME" "-WindowStyle Minimized"
..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\$IPFS_CLIENT_DIR_NAME\$IPFS_CLIENT_UNZIP_NAME\$IPFS_CLIENT_STARTER_PS1_NAME" "-WindowStyle Minimized"

Start-Sleep -Seconds $SLEEP_SECONDS

# Start-Process -FilePath ".\$IPFS_CLUSTER_FOLLOW_DIR_NAME\$IPFS_CLUSTER_FOLLOW_STARTER_PS1_NAME" "-WindowStyle Minimized"
..\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\$IPFS_CLUSTER_FOLLOW_DIR_NAME\$IPFS_CLUSTER_FOLLOW_UNZIP_NAME\$IPFS_CLUSTER_FOLLOW_STARTER_PS1_NAME" "-WindowStyle Minimized"

exit
"@

		$content | Out-File -FilePath $IPFS_SIGNUMART_STARTER_PS1_PATH -Force

		Write-Host "${IPFS_SIGNUMART_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${IPFS_SIGNUMART_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${IPFS_SIGNUMART_STARTER_PS1_NAME} ..\${POWERSHELL_EXEC_PATH} ${IPFS_SIGNUMART_STARTER_EXEC_NAME} ${IPFS_SIGNUMART_STARTER_EXEC_PATH}

}

function install_heidisql {
    # Create HeidiSQL directory
    if (-not (Test-Path "${HEIDISQL_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${HEIDISQL_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${HEIDISQL_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${HEIDISQL_DIR_NAME}"
    }

    if (Test-Path "${HEIDISQL_ZIP_PATH}") {
        Write-Host "${HEIDISQL_ZIP_NAME} already downloaded."
    } else {
        # Download HeidiSQL
        Write-Host "Downloading HeidiSQL ..."
        # Start-BitsTransfer -Source "${HEIDISQL_URL}" -Destination "${HEIDISQL_ZIP_PATH}"
		Invoke-WebRequest -Uri ${HEIDISQL_URL} -OutFile ${HEIDISQL_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path "${HEIDISQL_ZIP_PATH}")) {
            Write-Host "Error: Failed to download HeidiSQL."
            Pause
            return
        }
    }

    if (Test-Path "${HEIDISQL_UNZIP_PATH}") {
        Write-Host "${HEIDISQL_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping HeidiSQL to $TOOLS_DIR_NAME\$HEIDISQL_DIR_NAME\$HEIDISQL_UNZIP_NAME ..."
        Expand-Archive -Path "$TOOLS_DIR_NAME\$HEIDISQL_DIR_NAME\$HEIDISQL_ZIP_NAME" -DestinationPath "$TOOLS_DIR_NAME\$HEIDISQL_DIR_NAME\$HEIDISQL_UNZIP_NAME" -Force
	}
		
	# Create starter ps1
	if (-not (Test-Path $HEIDISQL_STARTER_PS1_PATH)) {
		# Create start-heidisql.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start HeidiSQL
Set-Location -Path `$PSScriptRoot

# Start HeidiSQL
Start-Process -FilePath ".\$HEIDISQL_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $HEIDISQL_STARTER_PS1_PATH -Force

		Write-Host "${HEIDISQL_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${HEIDISQL_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${HEIDISQL_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${HEIDISQL_STARTER_EXEC_NAME} ${HEIDISQL_STARTER_EXEC_PATH}

	Write-Host "HeidiSQL installed successfully."
		
}

function install_DBeaver {
    # Create DBeaver directory
    if (-not (Test-Path "${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}")) {
        New-Item -ItemType Directory -Path "${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}" | Out-Null
        Write-Host "Created directory: ${DBEAVER_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${DBEAVER_DIR_NAME}"
    }

    if (Test-Path "${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}\${DBEAVER_ZIP_NAME}") {
        Write-Host "${DBEAVER_ZIP_NAME} already downloaded."
    } else {
        # Download DBeaver
        Write-Host "Downloading DBeaver ..."
        # Start-BitsTransfer -Source "${DBEAVER_URL}" -Destination "${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}\${DBEAVER_ZIP_NAME}"
		Invoke-WebRequest -Uri ${DBEAVER_URL} -OutFile ${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}\${DBEAVER_ZIP_NAME}

        # Check if download was successful
        if (-not (Test-Path "${TOOLS_DIR_NAME}\${DBEAVER_DIR_NAME}\${DBEAVER_ZIP_NAME}")) {
            Write-Host "Error: Failed to download DBeaver."
            Pause
            return
        }
    }

    if (Test-Path "${DBEAVER_UNZIP_PATH}") {
        Write-Host "${DBEAVER_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping DBeaver to ${DBEAVER_UNZIP_PATH} ..."
        Expand-Archive -Path "${DBEAVER_ZIP_PATH}" -DestinationPath "${DBEAVER_DIR_PATH}" -Force
		# Rename the folder
		Rename-Item -Path "${DBEAVER_DIR_PATH}\dbeaver" -NewName "$DBEAVER_UNZIP_NAME"
	}
		
	# Create starter ps1
	if (-not (Test-Path $DBEAVER_STARTER_PS1_PATH)) {
		# Create start-dbeaver.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start DBeaver
Set-Location -Path `$PSScriptRoot

# Start DBeaver
Start-Process -FilePath ".\$DBEAVER_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $DBEAVER_STARTER_PS1_PATH -Force

		Write-Host "${DBEAVER_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${DBEAVER_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${DBEAVER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${DBEAVER_STARTER_EXEC_NAME} ${DBEAVER_STARTER_EXEC_PATH}

	Write-Host "DBeaver installed successfully."
		
}

function install_notepad {
    # Create NOTEPAD++ directory
    if (-not (Test-Path "${NOTEPAD_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${NOTEPAD_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${NOTEPAD_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${NOTEPAD_DIR_NAME}"
    }

    if (Test-Path "${NOTEPAD_ZIP_PATH}") {
        Write-Host "${NOTEPAD_ZIP_NAME} already downloaded."
    } else {
        # Download Notepad
        Write-Host "Downloading Notepad ..."
        # Start-BitsTransfer -Source "${NOTEPAD_URL}" -Destination "${NOTEPAD_ZIP_PATH}"
		Invoke-WebRequest -Uri ${NOTEPAD_URL} -OutFile ${NOTEPAD_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path "${NOTEPAD_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Notepad."
            Pause
            return
        }
    }

    if (Test-Path "${NOTEPAD_UNZIP_PATH}") {
        Write-Host "${NOTEPAD_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Notepad to ${NOTEPAD_UNZIP_PATH} ..."
        Expand-Archive -Path "${NOTEPAD_ZIP_PATH}" -DestinationPath "${NOTEPAD_UNZIP_PATH}" -Force
    }
	
	# Create starter ps1
	if (-not (Test-Path $NOTEPAD_STARTER_PS1_PATH)) {
		# Create start-notepad.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Notepad
Set-Location -Path `$PSScriptRoot

# Start Notepad
Start-Process -FilePath ".\$NOTEPAD_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $NOTEPAD_STARTER_PS1_PATH -Force

		Write-Host "${NOTEPAD_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${NOTEPAD_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${NOTEPAD_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${NOTEPAD_STARTER_EXEC_NAME} ${NOTEPAD_STARTER_EXEC_PATH}

	Write-Host "Notepad installed successfully."
	
}

function install_chromium_browser {
	Write-Host "Installing Chromium Browser ..."

    # Create Browser directory
    if (-not (Test-Path "$BROWSER_CHROMIUM_DIR_PATH")) {
        New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_DIR_PATH" | Out-Null
        Write-Host "Created directory: ${BROWSER_CHROMIUM_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${BROWSER_CHROMIUM_DIR_PATH}"
    }

    if (Test-Path "$BROWSER_CHROMIUM_ZIP_PATH") {
        Write-Host "${BROWSER_CHROMIUM_ZIP_PATH} already downloaded."
    } else {
        # Download Chromium Browser
        Write-Host "Downloading Chromium Browser ..."
        # Start-BitsTransfer -Source "${BROWSER_CHROMIUM_URL}" -Destination "${BROWSER_CHROMIUM_ZIP_PATH}"
		Invoke-WebRequest -Uri $BROWSER_CHROMIUM_URL -OutFile $BROWSER_CHROMIUM_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path "$BROWSER_CHROMIUM_ZIP_PATH")) {
            Write-Host "Error: Failed to download Notepad."
            Pause
            return
        }
    }

	# Unzip files
    if (Test-Path "$BROWSER_CHROMIUM_UNZIP_PATH") {
        Write-Host "$BROWSER_CHROMIUM_UNZIP_PATH already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Chromium Browser to $BROWSER_CHROMIUM_UNZIP_PATH ..."
        Expand-Archive -Path "$BROWSER_CHROMIUM_ZIP_PATH" -DestinationPath "$BROWSER_CHROMIUM_DIR_PATH" -Force
    }

	# Create starter ps1
	if (-not (Test-Path $BROWSER_CHROMIUM_STARTER_PS1_PATH)) {
		# Create start-notepad.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Chromium Browser
Set-Location -Path `$PSScriptRoot

# Start Chromium Browser
Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_NAME" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}"

exit
"@

		$content | Out-File -FilePath $BROWSER_CHROMIUM_STARTER_PS1_PATH -Force

		Write-Host "${BROWSER_CHROMIUM_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${BROWSER_CHROMIUM_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${BROWSER_CHROMIUM_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${BROWSER_CHROMIUM_STARTER_EXEC_NAME} ${BROWSER_CHROMIUM_STARTER_EXEC_PATH}

	# Create Extensins directory
	if (-not (Test-Path "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH")) {
		New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH" | Out-Null
		Write-Host "Created directory: ${BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH}"
	}

	# In case true installation of released version
	if ($BROWSER_CHROMIUM_SIGNUM_XT_VERSION_INSTALL) {
		# Install SignumXT Extension from github release
		# Check if given SignumXT Extention is installed
		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH\fullpage.html") {
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH already installed."
		} else {
			# Create SignumXT directory from github release version
			if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH")) {
				New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH" | Out-Null
				Write-Host "Created directory: ${BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH}"
			} else {
				Write-Host "Directory already exists: ${BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH}"
			}

			if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH") {
				Write-Host "${BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH} already downloaded."
			} else {
				# Download SignumXT Extension
				Write-Host "Downloading SignumXT Extension ..."
				# Start-BitsTransfer -Source "${BROWSER_CHROMIUM_URL}" -Destination "${BROWSER_CHROMIUM_ZIP_PATH}"
				Invoke-WebRequest -Uri $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_URL -OutFile $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH

				# Check if download was successful
				if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH")) {
					Write-Host "Error: Failed to download Notepad."
					Pause
					return
				}
			}
			# Unzip the downloaded file to the installation directory
			Write-Host "Unzipping SignumXT to $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH ..."
			Expand-Archive -Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH" -DestinationPath "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH" -Force
		}

		Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}",`
			"--load-extension=.\$BROWSER_CHROMIUM_EXTENSIONS_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_VERSION"

	} else {

		# TODO BUG Extension is not loading
		# Create SignumXT directory from github main branch
		if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH")) {
			New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH" | Out-Null
			Write-Host "Created directory: ${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH}"
		} else {
			Write-Host "Directory already exists: ${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH}"
		}

		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH") {
			Write-Host "${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH} already downloaded."
		} else {
			# Download SignumXT Extension
			Write-Host "Downloading SignumXT Extension ..."
			Write-Host "From URL: $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_URL"
			Write-Host "To: $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH"
			# Start-BitsTransfer -Source "${BROWSER_CHROMIUM_URL}" -Destination "${BROWSER_CHROMIUM_ZIP_PATH}"
			Invoke-WebRequest -Uri $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_URL -OutFile $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH

			# Check if download was successful
			if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH")) {
				Write-Host "Error: Failed to download Notepad."
				Pause
				return
			}
		}

		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH") {
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH already unzipped."
		} else {
			# Unzip the downloaded file to the installation directory
			Write-Host "Unzipping original main to $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH ..."
			Expand-Archive -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH" -DestinationPath "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH" -Force
		}

		# Install nodejs
		install_nodejs

		Set-Location ".\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH"

		# Build SignumXT from github main branch
		Write-Host "Build SignumXT from github main branch"
		& "..\..\..\..\..\${NODEJS_UNZIP_PATH}\node_modules\corepack\shims\yarn.cmd" install
		& "..\..\..\..\..\${NODEJS_UNZIP_PATH}\node_modules\corepack\shims\yarn.cmd" build:chrome
		
		Set-Location -Path $PSScriptRoot

		# Install SignumXT Extension from github main branch
		# Unzip files
		# TODO Questionprompt for reinstall
		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH\fullpage.html") {
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH already installed."
		} else {
			# Unzip the SignumXT to the installation directory
			Write-Host "Unzipping SignumXT original main to $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH ..."
			Expand-Archive -Path "${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH}\dist\${BROWSER_CHROMIUM_SIGNUM_XT_ZIP_NAME}" -DestinationPath "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH" -Force
	
		}

		Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}",`
			"--load-extension=.\$BROWSER_CHROMIUM_EXTENSIONS_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_NAME"

		# Delete files
		Write-Host "Cleaning $BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH directory."
		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH") {
			Write-Host "Delete $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH file."
			Remove-Item -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH" -Force
		} else {
			# Delete the downloaded file
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH already deleted"
		}

		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH") {
			Write-Host "Delete $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH file."
			Remove-Item -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH" -Recurse -Force
		} else {
			# Delete the downloaded file
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH already deleted"
		}

	}

	Write-Host "Chromium Browser installed successfully."
	
}

function install_nodejs {
    # Create NodeJS directory
    if (-not (Test-Path "${NODEJS_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${NODEJS_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${NODEJS_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${NODEJS_DIR_NAME}"
    }

    if (Test-Path "${NODEJS_ZIP_PATH}") {
        Write-Host "${NODEJS_ZIP_PATH} already downloaded."
    } else {
        # Download NodeJs
        Write-Host "Downloading NodeJS ..."
        # Start-BitsTransfer -Source "${NODEJS_URL}" -Destination "${NODEJS_ZIP_PATH}"
		Invoke-WebRequest -Uri ${NODEJS_URL} -OutFile ${NODEJS_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path "${NODEJS_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Notepad."
            Pause
            return
        }
    }

    if (Test-Path "${NODEJS_UNZIP_PATH}") {
        Write-Host "${NODEJS_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Notepad to $NODEJS_UNZIP_PATH ..."
        Expand-Archive -Path "$NODEJS_ZIP_PATH" -DestinationPath "$NODEJS_DIR_PATH" -Force
    }

	# Create starter ps1
	if (-not (Test-Path $NODEJS_STARTER_PS1_PATH)) {
		# Create start-nodejs.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start NodeJS
Set-Location -Path `$PSScriptRoot

# Start NodeJS
Start-Process -FilePath ".\$NODEJS_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $NODEJS_STARTER_PS1_PATH -Force

		Write-Host "${NODEJS_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${NODEJS_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${NODEJS_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${NODEJS_STARTER_EXEC_NAME} ${NODEJS_STARTER_EXEC_PATH}

	Write-Host "NodeJS installed successfully."
	
}

function install_nginx_and_certbot {

	# Certbot Install
	# install-process $CERTBOT_STARTER_EXEC_PATH "Certbot" {Install_Certbot}
	<#
	# TODO check Certbot installation
	Write-Host "Checking Certbot installation as precondition"

	if (-not (Test-Path -Path "$CERTBOT_STARTER_PS1_PATH")) {
		Write-Host "Certbot is alredy installed"
		Write-Host "Certbot is alredy installed"

	} else {
		Install_Certbot
	}
	#>

	Install_Certbot

    # Create NGINX directory
    if (-not (Test-Path $NGINX_DIR_PATH)) {
        New-Item -ItemType Directory -Path $NGINX_DIR_PATH | Out-Null
        Write-Host "Created directory: ${NGINX_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${NGINX_DIR_NAME}"
    }

    if (Test-Path $NGINX_ZIP_PATH) {
        Write-Host "${NGINX_ZIP_NAME} already downloaded."
    } else {
        # Download NGINX
        Write-Host "Downloading NGINX ..."
        # Start-BitsTransfer -Source "${NGINX_URL}" -Destination "$NGINX_ZIP_PATH"
		Invoke-WebRequest -Uri ${NGINX_URL} -OutFile $NGINX_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path $NGINX_ZIP_PATH)) {
            Write-Host "Error: Failed to download NGINX."
            Pause
            return
        }
    }

    if (Test-Path "${NGINX_UNZIP_PATH}") {
        Write-Host "${NGINX_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping NGINX to ${NGINX_UNZIP_PATH} ..."
        Expand-Archive -Path "${NGINX_ZIP_PATH}" -DestinationPath "${NGINX_DIR_PATH}" -Force
    }

	# Create directories for SSL
	if (-not (Test-Path "${NGINX_UNZIP_PATH}\html\ssl\letsencrypt")) {
		New-Item -ItemType Directory -Path "${NGINX_UNZIP_PATH}\html\ssl\letsencrypt" | Out-Null
		Write-Host "Created directory: ${NGINX_UNZIP_PATH}\html\ssl\letsencrypt"
	} else {
		Write-Host "Directory already exists: ${NGINX_UNZIP_PATH}\html\ssl\letsencrypt"
	}

	if (-not (Test-Path "${NGINX_UNZIP_PATH}\ssl\certificates")) {
		New-Item -ItemType Directory -Path "${NGINX_UNZIP_PATH}\ssl\certificates" | Out-Null
		Write-Host "Created directory: ${NGINX_UNZIP_PATH}\ssl\certificates"
	} else {
		Write-Host "Directory already exists: ${NGINX_UNZIP_PATH}\ssl\certificates"
	}

	# Create nginx-original.conf from nginx.conf
	if (-not (Test-Path $NGINX_ORIGINAL_CONFIG_FILE_PATH)) {
		Write-Host "Copying ${NGINX_CONFIG_FILE_PATH} to ${NGINX_ORIGINAL_CONFIG_FILE_PATH} ..."
    	Copy-Item -Path "${NGINX_CONFIG_FILE_PATH}" -Destination "${NGINX_ORIGINAL_CONFIG_FILE_PATH}"
	} else {
		Write-Host "File already exists: ${NGINX_ORIGINAL_CONFIG_FILE_PATH}"
	}
	
	# Create starter ps1
	if (-not (Test-Path $NGINX_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start NGINX
Set-Location -Path `$PSScriptRoot

# Start NGINX
Start-Process -FilePath ".\$NGINX_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $NGINX_STARTER_PS1_PATH -Force

		Write-Host "${NGINX_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${NGINX_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${NGINX_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${NGINX_STARTER_EXEC_NAME} ${NGINX_STARTER_EXEC_PATH}

	Write-Host "NGINX installed successfully."

	# Open Nginx Setup menu
	question-prompt "open" "NginX Setup Menu" {nginx_and_certbot_setup_menu $NGINX_CONFIG_FILE_PATH $NGINX_ORIGINAL_CONFIG_FILE_PATH}

}

# It makes one certificate for all domains
function nginx_and_certbot_setup_menu ($config_path, $config_original_path) {
	
	# TODO make option to select setup menus from the main window
	Clear-Host
    Write-Host "====================================================="
    Write-Host "              Nginx/Certbot Setup Menu               "
    Write-Host "====================================================="
    Write-Host "Please select an option:"
    Write-Host "[1] `tEdit Nginx Configuration file"
    Write-Host "[2] `tStep by Step Nginx/Certbot Configuration"
	Write-Host "[3] `tRestore Configuration"
	Write-Host "====================================================="
	Write-Host "[4] `tExit Setup"
    Write-Host "====================================================="
	
	
    $choice = Read-Host "Enter your choice (1-4)"
	$serverNames_ssl = @()

	$serverNamesString_ssl = $null

	$overwrite_ssl = $false

	$commentServerBlockStart = "# BEGIN INITIAL CERTBOT CONFIG"
    $commentServerBlockEnd = "# END INITIAL CERTBOT CONFIG"
	$commentServerNames_ssl ="# SSL Server Names:"

	switch ($choice) {
        "1" {
			# Install notepad++
			install_notepad
			# Open Configuration with notepad++
			# Start-Process -FilePath "$NOTEPAD_EXEC_PATH"
			& $NOTEPAD_EXEC_PATH $config_path
			Return
        }
        "2" {

			# Would You like to add Let's Encrypt certificate handler to Nginx configuration?
			do {

				# Check if nginx.conf exists
				if (!(Test-Path "$config_path")) {
					Write-Host "nginx.conf not found at $config_path..."
					Pause
					return
				}

				# Read the current nginx.conf
				$nginxConfContent = Get-Content -Path $config_path -Raw

				# Remove old Certbot config if it exists
				if ($nginxConfContent -match [regex]::Escape($commentServerBlockStart)) {
					Write-Host "Let's Encrypt certificate handler configuration is already exist on Nginx configuration file!"

					# Read out the $CERTBOT_FIRST_SSL_SERVER_NAME and $serverNames_ssl from nginx.conf
					$pattern_serverNameFirst_ssl = "ssl_certificate\s+$CERTBOT_CONFIGURATION_RELATIVE_PATH/live/([^/]+)/cert.pem;"
					$pattern_serverNames_ssl = "$commentServerNames_ssl\s+(.+)"

					# Search for the matching line
					foreach ($line in $nginxConfContent) {
						if ($line -match $pattern_serverNameFirst_ssl) {
							$CERTBOT_FIRST_SSL_SERVER_NAME = $matches[1]
							Write-Host "Extracted Certbot certification folder name: $CERTBOT_FIRST_SSL_SERVER_NAME"
						}
						if ($line -match $pattern_serverNames_ssl) {
							$serverNames_ssl = $matches[1] -split '\s+'
							Write-Host "Extracted SSL Server names: $serverNames_ssl"
						}
					}
					do {
						$userChoice = Read-Host "Do You want to overwrite the existing SSL configuration? (yes/no)"
						if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {
							# Collect server names (domains, IPv4, IPv6)
							$serverNames_ssl = @()
							do {
								$serverName = Read-Host "Enter a server DNS name, IPv4, or IPv6 address for SSL support (or type 'no' to stop adding)"
								
								if ($serverName -match '^(no|NO|No|n|N)$') {
									break
								} elseif (
									$serverName -match '^(localhost)(:\d+)?$' -or  # Localhost with optional port
									$serverName -match '^[a-zA-Z0-9.-]+(:\d+)?$' -or  # Domain with optional port
									$serverName -match '^\d{1,3}(\.\d{1,3}){3}(:\d+)?$' -or  # IPv4 with optional port
									$serverName -match '^\[?([a-fA-F0-9:]+:+)+[a-fA-F0-9]+\]?(?::\d+)?$'  # IPv6 with optional port
								) {
									# Ensure IPv6 addresses are wrapped in []
									if ($serverName -match '^([a-fA-F0-9:]+:+)+[a-fA-F0-9]+(:\d+)?$') {
										$serverName = "[$serverName]"  # Add brackets for IPv6
									}
									$serverNames_ssl += $serverName
								} else {
									Write-Host "Invalid input. Please enter a valid domain name, IPv4, or IPv6 address."
								}
							} while ($true)

							Write-Host "Server Names: $serverNames_ssl"
					
							if ($serverNames_ssl.Count -eq 0) {
								Write-Host "No server names added. Exiting..."
								Pause
								break
							}
					
							# Convert server names to a space-separated string
							$serverNamesString_ssl = $serverNames_ssl -join " "

							# Regex pattern to find the block where "listen 80;" is followed by "server_name" with any IP or domain
							$pattern = "(?<=listen\s+80;\s+server_name\s+)([^;]+);"

							# Replace the server_name value with $serverNamesString_ssl
							$nginxConfContent = $nginxConfContent -replace $pattern, "$serverNamesString_ssl;"

							# Regex pattern to find "listen 443 ssl;" followed by "server_name" with any IP or domain
							$pattern = "(?<=listen\s+443\s+ssl;\s+server_name\s+)([^;]+);"

							# Replace the server_name value with $serverNamesString_ssl
							$nginxConfContent = $nginxConfContent -replace $pattern, "$serverNamesString_ssl;"

							# Overwrite the nginx.conf file with the updated content
							$nginxConfContent | Set-Content -Path $config_path -Encoding UTF8
							$overwrite_ssl = $true

							Write-Host "Existing Certbot configuration updated."
							break
						} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
							Write-Host "Adding Let's encript certificate handler to Nginx configuration is canceled."
							break
						} else {
							Write-Host "Wrong choice, please try again"
							Pause
						}
						Write-Host "Server Names: $serverNames_ssl"
					} while ($true)
					break
				} else {
					$userChoice = Read-Host "Would You like to add Let's Encrypt certificate handler to Nginx configuration? (yes/no)"
					if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {
						# Collect server names (domains, IPv4, IPv6)
						$serverNames_ssl = @()
						do {
							$serverName = Read-Host "Enter a server DNS name, IPv4, or IPv6 address for SSL support (or type 'no' to stop adding)"
							
							if ($serverName -match '^(no|NO|No|n|N)$') {
								break
							} elseif (
								$serverName -match '^(localhost)(:\d+)?$' -or  # Localhost with optional port
								$serverName -match '^[a-zA-Z0-9.-]+(:\d+)?$' -or  # Domain with optional port
								$serverName -match '^\d{1,3}(\.\d{1,3}){3}(:\d+)?$' -or  # IPv4 with optional port
								$serverName -match '^\[?([a-fA-F0-9:]+:+)+[a-fA-F0-9]+\]?(?::\d+)?$'  # IPv6 with optional port
							) {
								# Ensure IPv6 addresses are wrapped in []
								if ($serverName -match '^([a-fA-F0-9:]+:+)+[a-fA-F0-9]+(:\d+)?$') {
									$serverName = "[$serverName]"  # Add brackets for IPv6
								}
								$serverNames_ssl += $serverName
							} else {
								Write-Host "Invalid input. Please enter a valid domain name, IPv4, or IPv6 address."
							}
						} while ($true)			
				
						if ($serverNames_ssl.Count -eq 0) {
							Write-Host "No server names added. Exiting..."
							Pause
							break
						}
				
						# Convert server names to a space-separated string
						$CERTBOT_FIRST_SSL_SERVER_NAME = $serverNames_ssl[0]
						$serverNamesString_ssl = $serverNames_ssl -join " "
						$newConfig_ssl = 
@"

#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
	worker_connections  1024;
}


http {
	include       mime.types;
	default_type  application/octet-stream;

	#log_format  main  '`$remote_addr - `$remote_user [`$time_local] "`$request" '
	#                  '`$status `$body_bytes_sent "`$http_referer" '
	#                  '"`$http_user_agent" "`$http_x_forwarded_for"';

	#access_log  logs/access.log  main;

	sendfile        on;
	#tcp_nopush     on;

	#keepalive_timeout  0;
	keepalive_timeout  65;

	#gzip  on;

	$commentServerBlockStart
	server {
		listen       80;
		server_name  $serverNamesString_ssl;

		#charset koi8-r;

		#access_log  logs/host.access.log  main;

		# Allow Let's Encrypt ACME challenge
		location ^~ /.well-known/acme-challenge/ {
			default_type "text/plain";
			root $CERTBOT_WEBROOT_MAP;
			autoindex on;
			allow all;
		}

		location / {
			root   html;
			index  index.html index.htm;
			
			# Redirect all other traffic to HTTPS
			return 301 https://`$host`$request_uri;
		}

		#error_page  404              /404.html;

		# redirect server error pages to the static page /50x.html
		error_page   500 502 503 504  /50x.html;
		location = /50x.html {
			root   html;
		}

		# proxy the PHP scripts to Apache listening on 127.0.0.1:80
		#
		#location ~ \.php$ {
		#    proxy_pass   http://127.0.0.1;
		#}

		# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
		#
		#location ~ \.php$ {
		#    root           html;
		#    fastcgi_pass   127.0.0.1:9000;
		#    fastcgi_index  index.php;
		#    fastcgi_param  SCRIPT_FILENAME  /scripts`$fastcgi_script_name;
		#    include        fastcgi_params;
		#}

		# deny access to .htaccess files, if Apache's document root
		# concurs with nginx's one
		#
		#location ~ /\.ht {
		#    deny  all;
		#}
	}

	# another virtual host using mix of IP-, name-, and port-based configuration
	#
	#server {
	#    listen       8000;
	#    listen       somename:8080;
	#    server_name  somename  alias  another.alias;
	#
	#    location / {
	#        root   html;
	#        index  index.html index.htm;
	#    }
	#}

	# HTTPS server
	#
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

	server {
		listen       443 ssl;
		server_name  $serverNamesString_ssl;

		# Use relative paths for SSL certificates
		ssl_certificate      $CERTBOT_CONFIGURATION_RELATIVE_PATH/live/${CERTBOT_FIRST_SSL_SERVER_NAME}/cert.pem;
		ssl_certificate_key  $CERTBOT_CONFIGURATION_RELATIVE_PATH/live/${CERTBOT_FIRST_SSL_SERVER_NAME}/privkey.pem;

		ssl_session_cache    shared:SSL:1m;
		ssl_session_timeout  5m;
		ssl_ciphers  HIGH:!aNULL:!MD5;
		ssl_prefer_server_ciphers  on;

		location / {
			root   html;
			index  index.html index.htm;
		}
	}
	$commentServerNames_ssl $serverNamesString_ssl
	$commentServerBlockEnd
}

"@

					# Overwrite nginx.conf with new content
					$newConfig_ssl | Set-Content -Path $config_path -Encoding UTF8

					# Confirm overwrite
					Write-Host "nginx.conf has been successfully updated!" -ForegroundColor Green
					# You should open port 80
					Write-Host "You should open port 80 and 443"
				} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
					Write-Host "Adding Let's encript certificate handler to Nginx configuration is canceled."
					break
				} else {
					Write-Host "Wrong choice, please try again"
					Pause
				}
				break
			}

		} while ($true)

		# Add proxy passes and servers
		do {
			$userChoice = Read-Host "Would You like to add new server configurtion with proxy_pass? (yes/no)"
			if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {

				# Set input port
				$port = Read-Host "Enter input port (8125)"

				# SSL settings
				do {
					$userChoice = Read-Host "Would you like to use SSL/HTTPS? (yes/no)"
					if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {
						$ssl = "ssl"
						$ssl_config =
@"

		# Certbot SSL
		ssl_certificate      $CERTBOT_CONFIGURATION_RELATIVE_PATH/live/${CERTBOT_FIRST_SSL_SERVER_NAME}/cert.pem;
		ssl_certificate_key  $CERTBOT_CONFIGURATION_RELATIVE_PATH/live/${CERTBOT_FIRST_SSL_SERVER_NAME}/privkey.pem;

		ssl_session_cache    shared:SSL:1m;
		ssl_session_timeout  5m;
		ssl_ciphers  HIGH:!aNULL:!MD5;
		ssl_prefer_server_ciphers  on;

"@
						break
					} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
						$ssl = ""
						$ssl_config = ""
						break
					} else {
						Write-Host "Invalid input. Please enter (yes/no)."
					}
				# Repeat the question in case answer is invalid
				} while($true)

				# Collect server names (domains, IPv4, IPv6)
				$serverNames = @()

				do {
					$serverName = Read-Host "Enter input server DNS name, IPv4, or IPv6 address for port: $port (or type 'no' to stop adding)"	
					if ($serverName -match '^(no|NO|No|n|N)$') {
						break
					} elseif (
						$serverName -match '^(localhost)(:\d+)?$' -or  # Localhost with optional port
						$serverName -match '^[a-zA-Z0-9.-]+(:\d+)?$' -or  # Domain with optional port
						$serverName -match '^\d{1,3}(\.\d{1,3}){3}(:\d+)?$' -or  # IPv4 with optional port
						$serverName -match '^\[?([a-fA-F0-9:]+:+)+[a-fA-F0-9]+\]?(?::\d+)?$'  # IPv6 with optional port
					) {
						# Ensure IPv6 addresses are wrapped in []
						if ($serverName -match '^([a-fA-F0-9:]+:+)+[a-fA-F0-9]+(:\d+)?$') {
							$serverName = "[$serverName]"  # Add brackets for IPv6
						}
						$serverNames += $serverName
					} else {
						Write-Host "Invalid input. Please enter a valid domain name, IPv4, or IPv6 address."
					}
				} while ($true)					
		
				if ($serverNames.Count -eq 0) {
					Write-Host "No server names added. Exiting..."
					Pause
					break
				}

				# Convert server names to a space-separated string
				$serverNamesString = $serverNames -join " "

				# Set proxi_pass
				$proxi_pass = Read-Host "Enter proxi_pass (http://localhost:7125)"

				$newServerConfig = 
@"


	server {
		listen       $port $ssl;
		server_name  $serverNamesString;

		error_page 301 307 400 497 https://`$host`$request_uri;
		$ssl_config
		location / {
			limit_req zone=speedbump burst=20;
			proxy_pass              $proxi_pass;
			proxy_ssl_session_reuse off;
			proxy_redirect          off;
			proxy_set_header        Host              `$http_host;
			proxy_set_header        X-Real-IP         `$remote_addr;
			proxy_set_header        X-Forwarded-For   `$proxy_add_x_forwarded_for;
		}
	}


"@

				# Read the current nginx.conf
				$nginxConfContent = Get-Content -Path $config_path -Raw

				# Ensures it only matches closing } of html{}
				# $pattern = "(?<=\bhtml\s*\{[^}]*\n)^\}"
				$pattern = "\s*}\s*$"

				# Replace the server_name value with $serverNamesString
				$updatedConf = $nginxConfContent -replace $pattern, "${newServerConfig}}"

				# Add newServerConfig to nginx.conf
				$updatedConf | Set-Content -Path $config_path -Encoding UTF8

				# Confirm overwrite
				Write-Host "New server added to Nginx configuration." -ForegroundColor Green

			} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
				Write-Host "Adding new server to Nginx configuration is canceled."
				break
			} else {
				Write-Host "Wrong choice, please try again"
				Pause
			}
		} while ($true)

		if ($serverNames_ssl.Count -eq 0) {
			Write-Host "No server names added. Exiting..."
			Pause
			return
		} else {
			# TODO on GUI option to: --register-unsafely-without-email
			$email_address = Read-Host "Enter e-mail address for certification"

			# Create Certbot create-certification.ps1 and create_certification.bat file
			$serverNamesString_ssl = $serverNames_ssl -join " `````n`t-d "

				$content = 

@"
# PowerShell script to Create Certbot certification
Set-Location -Path `$PSScriptRoot

# Run Certbot inside the portable Python environment
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -Verb runAs -ArgumentList "-NoExit", "-Command", `@"
	```$host.UI.RawUI.WindowTitle = 'Certbot certification'
	..\..\..\${CERTBOT_PYTHON_UNZIP_PATH}\Scripts\certbot.exe certonly ````
	--config-dir "./$CERTBOT_CONFIGURATION_RELATIVE_PATH" ````
	--work-dir "./$CERTBOT_WORKING_DIR_RELATIVE_PATH" ````
	--logs-dir "./$CERTBOT_LOGS_DIR_RELATIVE_PATH" ````
	--webroot ````
	-w ./$CERTBOT_WEBROOT_MAP ````
	--agree-tos ````
	--email $email_address ````
	-d $serverNamesString_ssl
"`@ ``

# Restart nginx after first certification creation
Start-Sleep -Seconds 300

.\nginx.exe -s reload

# Run certbot renewal
& ..\..\..\${POWERSHELL_EXEC_PATH} $NGINX_RENEW_CERTIFICATE_PS1_NAME

exit
"@


				if (-not (Test-Path $NGINX_CREATE_CERTIFICATE_PS1_PATH)) {
					$content | Out-File -FilePath $NGINX_CREATE_CERTIFICATE_PS1_PATH -Force
					Write-Host "${NGINX_CREATE_CERTIFICATE_PS1_PATH} successfully created."
				} else {
					Write-Host "$NGINX_CREATE_CERTIFICATE_PS1_PATH file already exists"
					if ($overwrite_ssl) {
						Write-Host "SSL configuration changed!"
						$content | Out-File -FilePath $NGINX_CREATE_CERTIFICATE_PS1_PATH -Force
						Write-Host "SSL configuration updated!"
					}
				}

				# Create create_certification.bat file
				create-starter-ps1-exec ${NGINX_CREATE_CERTIFICATE_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${NGINX_CREATE_CERTIFICATE_EXEC_NAME} ${NGINX_CREATE_CERTIFICATE_EXEC_PATH}

				# Create certbot renewal script
				$content = 

@"
# Set working directory to script location
Set-Location -Path $PSScriptRoot

# Run Certbot renewal
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -Verb runAs -ArgumentList "-NoExit", "-Command", `@"
	```$host.UI.RawUI.WindowTitle = 'Certbot certification'

	# Replace / to \
	$certbotConfigDirPath = "$CERTBOT_CONFIGURATION_RELATIVE_PATH" -replace '/', '\'

	# Path to the Certbot Configuration directory
	$certbotRenewalDirPath = ".\$certbotConfigDirPath\renewal"

	# Function to check and update paths
	function Update-CertbotRenewalPaths {

		# Check if the Certbot config directory exists
		if (!(Test-Path -Path $certbotConfigDirPath)) {
			Write-Error "Certbot configuration directory not found: $certbotConfigDirPath"
			return
		}

		# Check if the Certbot renewal directory exists
		if (!(Test-Path -Path $certbotRenewalDirPath)) {
			Write-Error "Certbot renewal directory not found: $certbotRenewalDirPath"
			return
		}
		Write-Host "Certbot renewal directory: $certbotRenewalDirPath"

		# Get all files in the renewal directory
		$renewalFiles = Get-ChildItem -Path $certbotRenewalDirPath -File

		# Replace \ to /
		$currentDirPath = "$PSScriptRoot" -replace '\\', '/'

		# Loop through each renewal file
		foreach ($renewalFile in $renewalFiles) {
			Write-Host "Checking renewal file: $($renewalFile.FullName)"

			# Read the content of the file
			$fileContent = Get-Content -Path $renewalFile.FullName
			$originalContent = $fileContent

			# Loop through each line in the file
			for ($i = 0; $i -lt $fileContent.Count; $i++) {
				$line = $fileContent[$i]
				$line 	-replace "\s*=\s*.+$CERTBOT_WEBROOT_MAP", " = $currentDirPath/$CERTBOT_WEBROOT_MAP" `
						-replace "\s*=\s*.+archive", " = $currentDirPath/archive" `
						-replace "\s*=\s*.+live", " = $currentDirPath/live"
				}
			}
			# Compare the content
			if ($fileContent.TrimEnd() -eq $originalContent.TrimEnd()) {
				Write-Output "The contents are the same."
			} else {
				# Write the modified content back to the file
				Write-Output "The contents are different."
				Write-Output "Update $renewalFile.FullName"
				$fileContent | Out-File -FilePath $renewalFile.FullName -Force
			}
		}

		Write-Host "All Certbot renewal files checked."
	}

	function Check-And-Renew-Cert {

		# Call the function to check and update paths
		Update-CertbotRenewalPaths

		Write-Host "Checking certificate expiration and renewing if necessary..."
		& "..\..\..\${CERTBOT_PYTHON_UNZIP_PATH}\Scripts\certbot.exe" renew ````
		--config-dir "./$CERTBOT_CONFIGURATION_RELATIVE_PATH" ````
		--work-dir "./$CERTBOT_WORKING_DIR_RELATIVE_PATH" ````
		--logs-dir "./$CERTBOT_LOGS_DIR_RELATIVE_PATH" ````
		--deploy-hook "./nginx.exe -s reload"
		# Check the result of the renew process:
		if ($LASTEXITCODE -eq 0) {
			Write-Host "Certificates renewed successfully."
		} else {
			Write-Error "Certificates renewal failed."
		}
	}
	
	# Main loop to check renewal every 24 hours
	while ($true) {
		Check-And-Renew-Cert
		Start-Sleep -Seconds 86400  # Wait for 24 hours (86400 seconds)
	}
"`@ ``

exit
"@

				if (-not (Test-Path $NGINX_RENEW_CERTIFICATE_PS1_PATH)) {
					$content | Out-File -FilePath $NGINX_RENEW_CERTIFICATE_PS1_PATH -Force
					Write-Host "${NGINX_RENEW_CERTIFICATE_PS1_PATH} successfully created."
				} else {
					Write-Host "$NGINX_RENEW_CERTIFICATE_PS1_PATH file already exists"
				}
				
				# Create renew-certificte.bat file
				create-starter-ps1-exec ${NGINX_RENEW_CERTIFICATE_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${NGINX_RENEW_CERTIFICATE_EXEC_NAME} ${NGINX_RENEW_CERTIFICATE_EXEC_PATH}

				# Run certbot create-certification.ps1
				do {
					$userChoice = Read-Host "Would You like to create certification? (yes/no)"
					if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {
						# TODO Run certbot create-certification.ps1
						& $POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "${NGINX_CREATE_CERTIFICATE_PS1_PATH}"
						break
					} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
						break
					} else {
						Write-Host "Invalid input. Please enter a valid domain name, IPv4, or IPv6 address."
					}
				} while ($true)

			}

			Write-Host "NginX Setup Complete"

		}
		"3" {
			# Restore Configuration
			Write-Host "Restore Configuration file ..."
			
			# Create nginx-backup.conf from nginx.conf
			Write-Host "Create backup from ${config_path} to ${config_path}\nginx-backup.conf ..."
			Copy-Item -Path "${config_path}" -Destination "${config_path}\nginx-backup.conf"

			# Copy nginx-original.conf to nginx.conf and 
			Write-Host "Copying ${config_original_path} to ${config_path} ..."
			Copy-Item -Path "${config_original_path}" -Destination "${config_path}"

			Write-Host "Configuration restored"
			Pause
            nginx_and_certbot_setup_menu $config_path $config_original_path
			Return
		}
		"4" {
			# Exit Setup
			Return
		}
		default {
            Write-Host "Invalid choice! Please try again."
            Pause
            nginx_and_certbot_setup_menu $config_path
        }
	}

}

function install_signumminer_mainnet {
    # Create Signum Miner Mainnet directory
    if (-not (Test-Path "${SIGNUM_MINER_MAINNET_VERSION_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${SIGNUM_MINER_MAINNET_VERSION_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${SIGNUM_MINER_MAINNET_VERSION_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_MINER_MAINNET_VERSION_DIR_PATH}"
    }

    if (Test-Path $SIGNUM_MINER_MAINNET_EXEC_PATH) {
        Write-Host "${SIGNUM_MINER_MAINNET_EXEC_NAME} already installed."
    } else {
        Write-Host "Downloading Signum Miner Mainnet ..."
        # Start-BitsTransfer -Source $SIGNUM_MINER_MAINNET_URL -Destination $SIGNUM_MINER_MAINNET_EXEC_PATH
		Invoke-WebRequest -Uri ${SIGNUM_MINER_MAINNET_URL} -OutFile ${SIGNUM_MINER_MAINNET_EXEC_PATH}

        if (-not (Test-Path $SIGNUM_MINER_MAINNET_EXEC_PATH)) {
            Write-Host "Error: Failed to download Signum Miner Mainnet."
            Read-Host "Press Enter to continue"
            return
        }
	}
	
	if (Test-Path $SIGNUM_MINER_MAINNET_VERSION_DIR_PATH\config.yaml) {
        Write-Host "Configuration file already downloaded."
    } else {
        Write-Host "Downloading Configuration file ..."
        # Start-BitsTransfer -Source $SIGNUM_MINER_MAINNET_CONF_URL -Destination $SIGNUM_MINER_MAINNET_CONF_PATH
		Invoke-WebRequest -Uri ${SIGNUM_MINER_MAINNET_CONF_URL} -OutFile ${SIGNUM_MINER_MAINNET_CONF_PATH}

        if (-not (Test-Path $SIGNUM_MINER_MAINNET_CONF_PATH)) {
            Write-Host "Error: Failed to download Configuration file."
            Read-Host "Press Enter to continue"
            return
        }
		Write-Host "Configuration file downloaded ..."
	}
			
	# Create starter ps1
	if (-not (Test-Path $SIGNUM_MINER_MAINNET_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
	
@"
# PowerShell script to start Signum Miner Mainnet
Set-Location -Path `$PSScriptRoot

# Start Signum Miner Mainnet
# Start-Process -FilePath "$SIGNUM_MINER_MAINNET_EXEC_NAME"
Start-Process -FilePath "..\..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-NoExit", "-Command", ".\$SIGNUM_MINER_MAINNET_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $SIGNUM_MINER_MAINNET_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_MINER_MAINNET_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_MINER_MAINNET_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_MINER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_MINER_MAINNET_EXEC_NAME} ${SIGNUM_MINER_MAINNET_STARTER_EXEC_PATH}
		
    Write-Host "Signum Miner Mainnet installed successfully."
	
	setup_signumminer "$SIGNUM_MINER_MAINNET_VERSION_DIR_PATH\config.yaml" $SIGNUM_MINER_MAINNET_CONF_URL "mainnet"
	
}

function setup_signumminer($config_path, $config_url, $net_type) {
	
	Clear-Host
    Write-Host "====================================================="
    Write-Host "                 Setup Signum Miner                   "
    Write-Host "====================================================="
    Write-Host "Please select an option:"
    Write-Host "[1] `tEdit Configuration file"
    Write-Host "[2] `tSetup Miner Configuration"
	Write-Host "[3] `tRestore Configuration"
	Write-Host "====================================================="
	Write-Host "[4] `tExit Setup"
    Write-Host "====================================================="
	
	
    $choice = Read-Host "Enter your choice (1-4)"

    switch ($choice) {
        "1" {
			# Download notepad++
			# Open Configuration with notepad++
			install_notepad
			# Start-Process -FilePath "$NOTEPAD_EXEC_PATH"
			& $NOTEPAD_EXEC_PATH $config_path
			Return
        }
        "2" {
			# init configuration.yaml with commenting out lines
			# Load the content of the file
			$content = Get-Content -Path $config_path

			# Process each line using regex to add '#' only if there's no '#' before the target
			$content = $content | ForEach-Object {
				$_ -replace "^\s*10282355196851764065:", "# 10282355196851764065:" `
				   -replace "^\s*1796535821016683299:", "# 1796535821016683299:" `
				   -replace "^\s*- 'D:\\plot\\dir'", "# - 'D:\plot\dir'" `
				   -replace "^\s*- 'E:\\plot\\dir'", "# - 'E:\plot\dir'" `
				   -replace "^\s*- '/mnt/hd1/plot/dir'", "# - '/mnt/hd1/plot/dir'" `
				   -replace "^\s*url: 'https://pool.burstcoin.ro'", "#url: 'https://pool.burstcoin.ro'"
			}

			# Write the changes back to the file
			$content | Set-Content -Path $config_path
			
			Write-Host "Configuration initialized"
			
			# add user inputs
			Write-Host "Please select an option:"
			# Would you like to [1] solo mine or [1] pool mine?
			Write-Host "[1] Setup Solo Miner"
			Write-Host "[2] Setup Pool Miner"
			
			$choice_mining = Read-Host "Enter your choice (1-2)"
			
			switch ($choice_mining) {
				"1" {
					Write-Host "Solo miner config"
					$choice_account_id = Read-Host "Enter Account Id"
					$choice_passphrase = Read-Host "Enter Passphrase"
					if ($net_type -eq "mainnet") {
						$choice_node_url = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
					} else {
						$choice_node_url = "http://localhost:$SIGNUM_NODE_TESTNET_API_PORT"
					}
					$choice_node_url = Read-Host "Enter Signum node url (default: $choice_node_url)"
					if ($choice_node_url -eq "")
					{
						if ($net_type -eq "mainnet") {
							$choice_node_url = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
						} else {
							$choice_node_url = "http://localhost:$SIGNUM_NODE_TESTNET_API_PORT"
						}
							
					}
					if ($choice_account_id -ne "") {
						$lines = Get-Content -Path $config_path

						# Loop through each line and add a new line after the target line
						for ($i = 0; $i -lt $lines.Count; $i++) {
							if ($lines[$i] -match "^account_id_to_secret_phrase:") {
								# Insert a new empty line after the detected line
								$lines = $lines[0..$i] + "$choice_account_id`: $choice_passphrase" + $lines[($i + 1)..($lines.Count - 1)]
								break
							}
						}
						
						# Loop through each line and add a new line after the target line
						for ($i = 0; $i -lt $lines.Count; $i++) {
							if ($lines[$i] -match "url:") {
								# Insert a new empty line after the detected line
								$lines = $lines[0..$i] + "url`: $choice_node_url" + $lines[($i + 1)..($lines.Count - 1)]
								break
							}
						}
						
						$choice_plot_path = Read-Host "Enter Plot path (D:\plot\dir)"
						while ($choice_plot_path -ne "") {		
							# Loop through each line and add a new line after the target line
							for ($i = 0; $i -lt $lines.Count; $i++) {
								if ($lines[$i] -match "^plot_dirs:") {
									# Insert a new empty line after the detected line
									$lines = $lines[0..$i] + "  - '$choice_plot_path'" + $lines[($i + 1)..($lines.Count - 1)]
									break
								}
							}
							$choice_plot_path = Read-Host "Enter Plot path (empty path exit)"
						}
						
						# Write the modified lines back to the file
						$lines | Set-Content -Path $config_path
						Pause
						setup_signumminer $config_path $config_url $net_type
					}
				}
				"2" {
					Write-Host "Pool miner config"
					# Enter pool URL
					$choice_pool_url = Read-Host "Enter Signum pool url (default: https://opensignumpool.ddns.net:8129)"
					if ($choice_pool_url -eq "")
					{
						$choice_pool_url = "https://opensignumpool.ddns.net:8129"
					}
					
					$lines = Get-Content -Path $config_path
					# Loop through each line and add a new line after the target line
					for ($i = 0; $i -lt $lines.Count; $i++) {
						if ($lines[$i] -match "url:") {
							# Insert a new empty line after the detected line
							$lines = $lines[0..$i] + "url: $choice_pool_url" + $lines[($i + 1)..($lines.Count - 1)]
							break
						}
					}
					
					$choice_plot_path = Read-Host "Enter Plot path (empty path: exit)"
					while ($choice_plot_path -ne "") {
						# Loop through each line and add a new line after the target line
						for ($i = 0; $i -lt $lines.Count; $i++) {
							if ($lines[$i] -match "^plot_dirs:") {
								# Insert a new empty line after the detected line
								$lines = $lines[0..$i] + "  - '$choice_plot_path'" + $lines[($i + 1)..($lines.Count - 1)]
								break
							}
						}
						$choice_plot_path = Read-Host "Enter Plot path (empty path: exit)"
					}
					
					# Write the modified lines back to the file
					$lines | Set-Content -Path $config_path
					Pause
					setup_signumminer $config_path $config_url $net_type
				}
				default {
					Write-Host "Invalid choice! Please try again."
					Pause
					setup_signumminer $config_path $config_url $net_type
				}
			}
        }
		"3" {
			# Restore Configuration

			# Create config-backup.yaml from config.yaml
			Write-Host "Create backup from ${config_path}\config.yaml to ${config_path}\config-backup.yaml ..."
			Copy-Item -Path "${config_path}\config.yaml" -Destination "${config_path}\config-backup.yaml"

			Write-Host "Downloading Configuration file ..."
			# Start-BitsTransfer -Source $config_url -Destination $config_path
			Invoke-WebRequest -Uri ${config_url} -OutFile ${config_path}

			if (-not (Test-Path $config_path)) {
				Write-Host "Error: Failed to download Configuration file."
				Read-Host "Press Enter to continue"
				Pause
				setup_signumminer $config_path $config_url $net_type
				return
			}
			Write-Host "Configuration restored"
			Pause
            setup_signumminer $config_path $config_url $net_type
			Return
        }
		"4" {
			# Exit Setup
			Return
        }
        default {
            Write-Host "Invalid choice! Please try again."
            Pause
            setup_signumminer $config_path $config_url $net_type
        }
    }
}

# TODO make a setup menu entry from main menu to open setup menu
# TODO after installation ask for start the installed application
function setup_signumpool($config_path, $config_original_path, $net_type) {
	
	Clear-Host
    Write-Host "====================================================="

	if ($net_type -eq "mainnet") {
	Write-Host "            Setup Signum Pool Mainnet                "
	} else {
	Write-Host "            Setup Signum Pool Testnet                "
	}

    Write-Host "====================================================="
    Write-Host "Please select an option:"
    Write-Host "[1] `tEdit Configuration file"
    Write-Host "[2] `tSetup Pool Configuration"
	Write-Host "[3] `tRestore Configuration"
	Write-Host "====================================================="
	Write-Host "[4] `tExit Setup"
    Write-Host "====================================================="
	
	
    $choice = Read-Host "Enter your choice (1-4)"

    switch ($choice) {
        "1" {
			# Download notepad++
			# Open Configuration with notepad++
			install_notepad
			# Start-Process -FilePath "$NOTEPAD_EXEC_PATH"
			& $NOTEPAD_EXEC_PATH $config_path
			Return
        }
        "2" {
			# init configuration.yaml with commenting out lines
			# Load the content of the file
			<#$content = Get-Content -Path $config_path

			# Process each line using regex to add '#' only if there's no '#' before the target
			$content = $content | ForEach-Object {
				$_ -replace "^\s*10282355196851764065:", "# 10282355196851764065:" `
				   -replace "^\s*1796535821016683299:", "# 1796535821016683299:" `
				   -replace "^\s*- 'D:\\plot\\dir'", "# - 'D:\plot\dir'" `
				   -replace "^\s*- 'E:\\plot\\dir'", "# - 'E:\plot\dir'" `
				   -replace "^\s*- '/mnt/hd1/plot/dir'", "# - '/mnt/hd1/plot/dir'" `
				   -replace "^\s*url: 'https://pool.burstcoin.ro'", "#url: 'https://pool.burstcoin.ro'"
			}

			# Write the changes back to the file
			$content | Set-Content -Path $config_path
			
			Write-Host "Configuration initialized"
			
			# add user inputs
			Write-Host "Please select an option:"
			# Would you like to [1] solo mine or [1] pool mine?
			Write-Host "[1] Setup Solo Miner"
			Write-Host "[2] Setup Pool Miner"
			
			$choice_mining = Read-Host "Enter your choice (1-2)"
			
			switch ($choice_mining) {
				"1" {
					Write-Host "Solo miner config"
					$choice_account_id = Read-Host "Enter Account Id"
					$choice_passphrase = Read-Host "Enter Passphrase"
					if ($net_type -eq "mainnet") {
						$choice_node_url = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
					} else {
						$choice_node_url = "http://localhost:$SIGNUM_NODE_TESTNET_API_PORT"
					}
					$choice_node_url = Read-Host "Enter Signum node url (default: $choice_node_url)"
					if ($choice_node_url -eq "")
					{
						if ($net_type -eq "mainnet") {
							$choice_node_url = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
						} else {
							$choice_node_url = "http://localhost:$SIGNUM_NODE_TESTNET_API_PORT"
						}
							
					}
					if ($choice_account_id -ne "") {
						$lines = Get-Content -Path $config_path

						# Loop through each line and add a new line after the target line
						for ($i = 0; $i -lt $lines.Count; $i++) {
							if ($lines[$i] -match "^account_id_to_secret_phrase:") {
								# Insert a new empty line after the detected line
								$lines = $lines[0..$i] + "$choice_account_id`: $choice_passphrase" + $lines[($i + 1)..($lines.Count - 1)]
								break
							}
						}
						
						# Loop through each line and add a new line after the target line
						for ($i = 0; $i -lt $lines.Count; $i++) {
							if ($lines[$i] -match "url:") {
								# Insert a new empty line after the detected line
								$lines = $lines[0..$i] + "url`: $choice_node_url" + $lines[($i + 1)..($lines.Count - 1)]
								break
							}
						}
						
						$choice_plot_path = Read-Host "Enter Plot path (D:\plot\dir)"
						while ($choice_plot_path -ne "") {		
							# Loop through each line and add a new line after the target line
							for ($i = 0; $i -lt $lines.Count; $i++) {
								if ($lines[$i] -match "^plot_dirs:") {
									# Insert a new empty line after the detected line
									$lines = $lines[0..$i] + "  - '$choice_plot_path'" + $lines[($i + 1)..($lines.Count - 1)]
									break
								}
							}
							$choice_plot_path = Read-Host "Enter Plot path (empty path exit)"
						}
						
						# Write the modified lines back to the file
						$lines | Set-Content -Path $config_path
						Pause
						setup_signumpool $config_path $config_original_path $net_type
					}
				}
				"2" {
					Write-Host "Pool miner config"
					# Enter pool URL
					$choice_pool_url = Read-Host "Enter Signum pool url (default: https://opensignumpool.ddns.net:8129)"
					if ($choice_pool_url -eq "")
					{
						$choice_pool_url = "https://opensignumpool.ddns.net:8129"
					}
					
					$lines = Get-Content -Path $config_path
					# Loop through each line and add a new line after the target line
					for ($i = 0; $i -lt $lines.Count; $i++) {
						if ($lines[$i] -match "url:") {
							# Insert a new empty line after the detected line
							$lines = $lines[0..$i] + "url: $choice_pool_url" + $lines[($i + 1)..($lines.Count - 1)]
							break
						}
					}
					
					$choice_plot_path = Read-Host "Enter Plot path (empty path: exit)"
					while ($choice_plot_path -ne "") {
						# Loop through each line and add a new line after the target line
						for ($i = 0; $i -lt $lines.Count; $i++) {
							if ($lines[$i] -match "^plot_dirs:") {
								# Insert a new empty line after the detected line
								$lines = $lines[0..$i] + "  - '$choice_plot_path'" + $lines[($i + 1)..($lines.Count - 1)]
								break
							}
						}
						$choice_plot_path = Read-Host "Enter Plot path (empty path: exit)"
					}
					
					# Write the modified lines back to the file
					$lines | Set-Content -Path $config_path
					Pause
					setup_signumpool $config_path $config_original_path $net_type
				}
				default {
					Write-Host "Invalid choice! Please try again."
					Pause
					setup_signumpool $config_path $config_original_path $net_type
				}
			}#>
			# The port to run the server on, use 443 if you enalbe the letsencrypt thing (see below)
			$serverPort = "$SIGNUM_POOL_MAINET_PORT"
			$nodeAddresses = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
			$poolName = "SIGNUM POOL"
			$miningURL = "http://localhost:$SIGNUM_POOL_MAINET_PORT"
			$passphrase = "YOUR POOL PASSPHRASE GOES HERE"
			$feeRecipient = "S-W5YR-ZZQC-KUBJ-G78KB"
			$donationRecipient = "S-JJQS-MMA4-GHB4-4ZNZU"
			
			if ($net_type -eq "mainnet") {
				$serverPort = "$SIGNUM_POOL_MAINET_PORT" 
			} else {
				$serverPort = "$SIGNUM_POOL_TESTNET_PORT" 
			}
			
			$serverPort = Read-Host "Enter Signum Pool Server Port to run the server (or press Enter for default ${serverPort})"
			if (-not $serverPort) { 
				if ($net_type -eq "mainnet") {
					$serverPort = "$SIGNUM_POOL_MAINET_PORT" 
				} else {
					$serverPort = "$SIGNUM_POOL_TESTNET_PORT" 
				}
			}
			Write-Host "serverPort = $serverPort"

			if ($net_type -eq "mainnet") {
				$nodeAddresses = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
			} else {
				$nodeAddresses = "http://localhost:$SIGNUM_NODE_TESTNET_API_PORT"
			}
			
			$nodeAddresses = Read-Host "Enter Signum Node Address (or press Enter for default $nodeAddresses)"
			if (-not $nodeAddresses) { 
				if ($net_type -eq "mainnet") {
					$nodeAddresses = "http://localhost:$SIGNUM_NODE_MAINNET_API_PORT"
				} else {
					$nodeAddresses = "http://localhost:$SIGNUM_NODE_TESTNET_API_PORT"
				}
			}
			Write-Host "Signum Node Address: $nodeAddresses"

			# The name of the pool
			$poolName = Read-Host "Enter the name of the pool (or press Enter for default $poolName)"
			if (-not $poolName) { $poolName = "SIGNUM POOL" }
			Write-Host "The name of the pool: ${poolName}"

			if ($net_type -eq "mainnet") {
				$miningURL = "http://localhost:$SIGNUM_POOL_MAINET_PORT"
			} else {
				$miningURL = "http://localhost:$SIGNUM_POOL_TESTNET_PORT"
			}

			# The URL miners should point their miner to
			$miningURL = Read-Host "Enter URL miners should point their miner to (or press Enter for skip)"
			if (-not $miningURL) { 
				if ($net_type -eq "mainnet") {
					$miningURL = "http://localhost:$SIGNUM_POOL_MAINET_PORT"
				} else {
					$miningURL = "http://localhost:$SIGNUM_POOL_TESTNET_PORT"
				}
			}
			Write-Host "The URL miners should point their miner to: ${miningURL}"

			# The passphrase of the pool account
			$passphrase = Read-Host "Enter the passphrase of the pool account (or press Enter for skip)"
			if (-not $passphrase) { $passphrase = "YOUR POOL PASSPHRASE GOES HERE" }
			Write-Host "Passphrase of the pool account: ${passphrase}"
			
			# Recipient of pool fees
			$feeRecipient = Read-Host "Enter the recipient of pool fees (or press Enter for skip)"
			if (-not $feeRecipient) { $feeRecipient = "S-W5YR-ZZQC-KUBJ-G78KB" }
			Write-Host "Recipient of pool fees: ${feeRecipient}"
			
			# Recipient of donations
			$donationRecipient = Read-Host "Enter the recipient of donations (or press Enter for skip)"
			if (-not $donationRecipient) { $donationRecipient = "S-JJQS-MMA4-GHB4-4ZNZU" }
			Write-Host "Recipient of donations: ${donationRecipient}"
			
			Write-Host "Updating pool.properties with new configurations ..."
			(Get-Content -Path $config_path) -replace '^serverPort = 8000', "serverPort = $serverPort" `
				-replace '^nodeAddresses = http://localhost:8125;', "nodeAddresses = $nodeAddresses;" `
				-replace '^poolName = SIGNUM POOL', "poolName = $poolName" `
				-replace '^miningURL = http://testnet.btfg.space:9000', "miningURL = $miningURL" `
				-replace '^passphrase = YOUR POOL PASSPHRASE GOES HERE', "passphrase = $passphrase" `
				-replace '^feeRecipient=S-W5YR-ZZQC-KUBJ-G78KB', "feeRecipient=$feeRecipient" `
				-replace '^donationRecipient=S-JJQS-MMA4-GHB4-4ZNZU', "donationRecipient=$donationRecipient" | Set-Content -Path $config_path

			if ($net_type -eq "mainnet") {
				
			} else {
				"testnet = true" | Out-File -FilePath $config_path -Append
			}
			Write-Host "Update complete."
        }
		"3" {
			# Restore Configuration
			Write-Host "Restore Configuration file ..."
			
			# Create pool.properties from pool-backup.properties
			Write-Host "Create backup from ${config_path} to ${config_path}\pool-backup.properties ..."
			Copy-Item -Path "${config_path}" -Destination "${config_path}\pool-backup.properties"

			# Copy poopl.properties to pool-original.properties
			Write-Host "Copying ${config_original_path} to ${config_path} ..."
			Copy-Item -Path "${config_original_path}" -Destination "${config_path}"

			Write-Host "Configuration restored"
			Pause
            setup_signumpool $config_path $config_original_path $net_type
			Return
        }
		"4" {
			# Exit Setup
			Return
        }
        default {
            Write-Host "Invalid choice! Please try again."
            Pause
            setup_signumpool $config_path $config_original_path $net_type
        }
    }
}

function install_signumminer_testnet {
    # Create Signum Miner Testnet directory
    if (-not (Test-Path "${SIGNUM_MINER_TESTNET_VERSION_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${SIGNUM_MINER_TESTNET_VERSION_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${SIGNUM_MINER_TESTNET_VERSION_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${SIGNUM_MINER_TESTNET_VERSION_DIR_PATH}"
    }

    if (Test-Path $SIGNUM_MINER_TESTNET_EXEC_PATH) {
        Write-Host "${SIGNUM_MINER_TESTNET_EXEC} already installed."
    } else {
        Write-Host "Downloading Signum Miner Testnet ..."
        # Start-BitsTransfer -Source $SIGNUM_MINER_TESTNET_URL -Destination $SIGNUM_MINER_TESTNET_EXEC_PATH
		Invoke-WebRequest -Uri ${SIGNUM_MINER_TESTNET_URL} -OutFile ${SIGNUM_MINER_TESTNET_EXEC_PATH}

        if (-not (Test-Path $SIGNUM_MINER_TESTNET_EXEC_PATH)) {
            Write-Host "Error: Failed to download Signum Miner Testnet."
            Read-Host "Press Enter to continue"
            return
        }
	}
	
	if (Test-Path $SIGNUM_MINER_TESTNET_VERSION_DIR_PATH\config.yaml) {
        Write-Host "Configuration file already downloaded."
    } else {
        Write-Host "Downloading Configuration file ..."
        # Start-BitsTransfer -Source $SIGNUM_MINER_TESTNET_CONF_URL -Destination $SIGNUM_MINER_TESTNET_CONF_PATH
		Invoke-WebRequest -Uri ${SIGNUM_MINER_TESTNET_CONF_URL} -OutFile ${SIGNUM_MINER_TESTNET_CONF_PATH}

        if (-not (Test-Path $SIGNUM_MINER_TESTNET_CONF_PATH)) {
            Write-Host "Error: Failed to download Configuration file."
            Read-Host "Press Enter to continue"
            return
        }
		Write-Host "Configuration file downloaded ..."
	}
			
	# Create starter ps1
	if (-not (Test-Path $SIGNUM_MINER_TESTNET_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
	
@"
# PowerShell script to start Signum Miner Testnet
Set-Location -Path `$PSScriptRoot

# Start PHOENIX
# Start-Process -FilePath "$SIGNUM_MINER_TESTNET_EXEC"
Start-Process -FilePath "..\..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-NoExit", "-Command", ".\$SIGNUM_MINER_TESTNET_EXEC"

exit
"@

		$content | Out-File -FilePath $SIGNUM_MINER_TESTNET_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUM_MINER_TESTNET_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUM_MINER_TESTNET_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUM_MINER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUM_MINER_TESTNET_EXEC} ${SIGNUM_MINER_TESTNET_STARTER_EXEC_PATH}
		
    Write-Host "Signum Miner Testnet installed successfully."
	
	setup_signumminer "$SIGNUM_MINER_TESTNET_VERSION_DIR_PATH\config.yaml" $SIGNUM_MINER_TESTNET_CONF_URL "testnet"
	
}

function install_btdex {
    # Create btdex directory
    if (-not (Test-Path $BTDEX_DIR_NAME)) {
        New-Item -ItemType Directory -Path $BTDEX_DIR_NAME | Out-Null
        Write-Host "Created directory: ${BTDEX_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${BTDEX_DIR_NAME}"
    }

    if (Test-Path $BTDEX_EXEC_PATH) {
        Write-Host "BTDEX already installed."
    } else {
        # Download BTDEX exe file
        Write-Host "Downloading BTDEX ..."
        # Start-BitsTransfer -Source $BTDEX_URL -Destination $BTDEX_EXEC_PATH
		Invoke-WebRequest -Uri ${BTDEX_URL} -OutFile ${BTDEX_EXEC_PATH}

        # Check if download was successful
        if (-not (Test-Path $BTDEX_EXEC_PATH)) {
            Write-Host "Error: Failed to download BTDEX."
            Pause
            return
        } 
	}
		
	# Create starter ps1
	if (-not (Test-Path $BTDEX_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start BTDEX
Set-Location -Path `$PSScriptRoot

# Start BTDEX
Start-Process -FilePath ".\$BTDEX_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $BTDEX_STARTER_PS1_PATH -Force

		Write-Host "${BTDEX_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${BTDEX_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${BTDEX_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${BTDEX_STARTER_EXEC_NAME} ${BTDEX_STARTER_EXEC_PATH}
	
	Write-Host "BTDEX installed successfully."

}

function install_phoenix {
    if (-not (Test-Path $PHOENIX_DIR_NAME)) {
        New-Item -ItemType Directory -Force -Path $PHOENIX_DIR_NAME | Out-Null
        Write-Host "Created directory: ${PHOENIX_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${PHOENIX_DIR_NAME}"
    }

    if (Test-Path $PHOENIX_EXEC_PATH) {
        Write-Host "${PHOENIX_EXEC_NAME} already installed."
    } else {
        Write-Host "Downloading Phoenix ..."
        # Start-BitsTransfer -Source $PHOENIX_URL -Destination $PHOENIX_EXEC_PATH
		Invoke-WebRequest -Uri ${PHOENIX_URL} -OutFile ${PHOENIX_EXEC_PATH}

        if (-not (Test-Path $PHOENIX_EXEC_PATH)) {
            Write-Host "Error: Failed to download Phoenix."
            Read-Host "Press Enter to continue"
            return
        }
	}
			
	# Create starter ps1
	if (-not (Test-Path $PHOENIX_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
	
@"
# PowerShell script to start PHOENIX
Set-Location -Path `$PSScriptRoot

# Start PHOENIX
Start-Process -FilePath ".\$PHOENIX_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $PHOENIX_STARTER_PS1_PATH -Force

		Write-Host "${PHOENIX_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${PHOENIX_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${PHOENIX_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${PHOENIX_STARTER_EXEC_NAME} ${PHOENIX_STARTER_EXEC_PATH}
		
    Write-Host "Phoenix installed successfully."
        
}

function install_signumplotter {
    if (-not (Test-Path $SIGNUMPLOTTER_DIR_PATH)) {
        New-Item -ItemType Directory -Force -Path $SIGNUMPLOTTER_DIR_PATH | Out-Null
        Write-Host "Created directory: $SIGNUMPLOTTER_DIR_PATH"
    } else {
        Write-Host "Directory already exists: $SIGNUMPLOTTER_DIR_PATH"
    }

    if (Test-Path $SIGNUMPLOTTER_EXEC_PATH) {
        Write-Host "${SIGNUMPLOTTER_EXEC} already installed."
    } else {
        Write-Host "Downloading SignumPlotter ..."
        # Start-BitsTransfer -Source $SIGNUMPLOTTER_URL -Destination $SIGNUMPLOTTER_EXEC_PATH
		Invoke-WebRequest -Uri ${SIGNUMPLOTTER_URL} -OutFile ${SIGNUMPLOTTER_EXEC_PATH}

        if (-not (Test-Path $SIGNUMPLOTTER_EXEC_PATH)) {
            Write-Host "Error: Failed to download SignumPlotter."
            Read-Host "Press Enter to continue"
            return
        }
	}
			
	# Create starter ps1
	if (-not (Test-Path $SIGNUMPLOTTER_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
	
@"
# PowerShell script to start SignumPlotter
Set-Location -Path `$PSScriptRoot

# Start SignumPlotter
Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" -ArgumentList "-NoExit", "-Command", .\SIGNUMPLOTTER_EXEC_NAME --help"
# "..\..\..\${POWERSHELL_EXEC_PATH}" "$SIGNUMPLOTTER_EXEC_NAME"
# & ..\..\..\$POWERSHELL_EXEC_PATH -NoExit -Command .\$SIGNUMPLOTTER_EXEC_NAME

exit
"@

		$content | Out-File -FilePath $SIGNUMPLOTTER_STARTER_PS1_PATH -Force

		Write-Host "${SIGNUMPLOTTER_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${SIGNUMPLOTTER_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${SIGNUMPLOTTER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${SIGNUMPLOTTER_STARTER_EXEC_NAME} ${SIGNUMPLOTTER_STARTER_EXEC_PATH}
		
    Write-Host "SignumPlotter installed successfully."
        
	# TODO Signum-Plotter configuration
}

function install_turboplotter {
	
    if (-not (Test-Path $TURBOPLOTTER_DIR_PATH)) {
        New-Item -ItemType Directory -Force -Path $TURBOPLOTTER_DIR_PATH | Out-Null
        Write-Host "Created directory: $TURBOPLOTTER_DIR_PATH"
    } else {
        Write-Host "Directory already exists: $TURBOPLOTTER_DIR_PATH"
    }
	
	if (Test-Path -Path "${TURBOPLOTTER_ZIP_PATH}") {
        Write-Host "${TURBOPLOTTER_ZIP_PATH} already downloaded."
    } else {
        # Download the TurboPlotter testnet zip file
        Write-Host "Downloading TurboPlotter ..."
		# TODO try out Invoke-WebRequest or System.Net.Http.HttpClient
        # Start-BitsTransfer -Source "${TURBOPLOTTER_URL}" -Destination "${TURBOPLOTTER_ZIP_PATH}"
		Invoke-WebRequest -Uri ${TURBOPLOTTER_URL} -OutFile ${TURBOPLOTTER_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path -Path "${TURBOPLOTTER_ZIP_PATH}")) {
            Write-Host "Error: Failed to download TurboPlotter."
            Exit
        }
    }

    if (Test-Path -Path "${TURBOPLOTTER_UNZIP_PATH}") {
        Write-Host "${TURBOPLOTTER_UNZIP_PATH} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping TurboPlotter to ${TURBOPLOTTER_UNZIP_PATH} ..."
        Expand-Archive -Path "${TURBOPLOTTER_ZIP_PATH}" -DestinationPath "${TURBOPLOTTER_UNZIP_PATH}" -Force
    }
			
	# Create starter ps1
	if (-not (Test-Path $TURBOPLOTTER_STARTER_PS1_PATH)) {
		# Create start-nginx.ps1 file with the desired content
		$content = 
	
@"
# PowerShell script to start TurboPlotter
Set-Location -Path `$PSScriptRoot

# Start TurboPlotter
Start-Process -FilePath ".\$TURBOPLOTTER_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $TURBOPLOTTER_STARTER_PS1_PATH -Force

		Write-Host "${TURBOPLOTTER_STARTER_PS1_PATH} successfully created."
	} else {
		Write-Host "File already exists: ${TURBOPLOTTER_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${TURBOPLOTTER_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${TURBOPLOTTER_STARTER_EXEC_NAME} ${TURBOPLOTTER_STARTER_EXEC_PATH}
		
    Write-Host "TurboPlotter installed successfully."
        
}

function install_mariadb {
    install_heidisql

    if (-not (Test-Path "$MARIADB_DIR_PATH")) {
        New-Item -ItemType Directory -Force -Path "$MARIADB_DIR_PATH" | Out-Null
    } else {
        Write-Host "Directory already exists: $MARIADB_DIR_PATH"
    }

    if (Test-Path "$MARIADB_ZIP_PATH") {
        Write-Host "${MARIADB_ZIP_NAME} already downloaded."
    } else {
        Write-Host "Downloading MariaDB version ${MARIADB_VERSION} ..."
        # Start-BitsTransfer -Source $MARIADB_URL -Destination "$MARIADB_ZIP_PATH"
		Invoke-WebRequest -Uri ${MARIADB_URL} -OutFile $MARIADB_ZIP_PATH

        if (-not (Test-Path "$MARIADB_ZIP_PATH")) {
            Write-Host "Error: Failed to download MariaDB version ${MARIADB_VERSION}."
            Read-Host "Press Enter to continue"
            return
        }
    }

    if (-not (Test-Path "$MARIADB_UNZIP_PATH")) {
        Write-Host "Unzipping MariaDB to $MARIADB_UNZIP_PATH ..."
        Expand-Archive -Path "$MARIADB_ZIP_PATH" -DestinationPath "$MARIADB_DIR_PATH" -Force
    }

    if (-not (Test-Path "${MARIADB_UNZIP_PATH}\data")) {
        New-Item -ItemType Directory -Force -Path "${MARIADB_UNZIP_PATH}\data" | Out-Null
        Write-Host "Initializing MariaDB data directory ..."
        & "${MARIADB_BIN_PATH}\${MARIADB_INSTALL_EXEC_NAME}"
    } else {
        Write-Host "MariaDB data directory already initialized."
    }

    if (-not (Test-Path $MARIADB_STARTER_PS1_PATH)) {
        $content = 
@"
# PowerShell script to start MariaDB
Set-Location -Path `$PSScriptRoot

# TODO find out how to run mariadb 1 within a powershell window, or 2 without powershell within mariadb own terminal window. Use the chosen soluton for 
# mariadb setup as well currently mariadb within powershell is used in mariadb setup
# 1:
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-Command", ".\bin\${MARIADBD_EXEC_NAME} --no-defaults" -WindowStyle Hidden
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-Command", ".\bin\${MARIADBD_EXEC_NAME} --no-defaults --console --port=$MARIADB_PORT" -WindowStyle Hidden
# Last OK
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'MariaDB'; .\bin\${MARIADBD_EXEC_NAME} --no-defaults --console --port=$MARIADB_PORT" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-Command", ".\bin\${MARIADBD_EXEC_NAME} --no-defaults"
# 2: If I can set powershell window title it is ok as well
# Start-Process -FilePath ".\bin\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized

# & .\bin\${MARIADBD_EXEC_NAME} --no-defaults --console --port=$MARIADB_PORT

Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'MariaDB'
        # Check if MariaDB is already running
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $MARIADB_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
            Write-Host 'MariaDB is already running.'
			exit
        } else {
			# Start MariaDB
			.\bin\mariadbd.exe --no-defaults --console --port=$MARIADB_PORT
		}
    } catch {
        Write-Host 'An error occurred while starting MariaDB: ```$_'
    } finally {
        # Always set the title to 'MariaDB Stopped' after MariaDB exits
        ```$host.UI.RawUI.WindowTitle = 'MariaDB Stopped'
    }
"`@ ``
    -WindowStyle Minimized
exit
"@
        $content | Out-File -FilePath $MARIADB_STARTER_PS1_PATH -Force
        Write-Host "${MARIADB_STARTER_PS1_PATH} successfully created."
    } else {
        Write-Host "File already exists: ${MARIADB_STARTER_PS1_PATH}"
    }
	
	# Create OS specific starter
	create-starter-ps1-exec ${MARIADB_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${MARIADB_STARTER_EXEC_NAME} ${MARIADB_STARTER_EXEC_PATH}
	
	Write-Host "MariaDB installed successfully."
}

function setup_mariadb ($name, $database, $user, $password) {
	
	$DATABASE_NAME = ""
	$DATABASE_USERNAME = ""
	$DATABASE_PASSWORD = ""
	
	$global:DATABASE_NAME = $null
	$global:DATABASE_USERNAME = $null
	$global:DATABASE_PASSWORD = $null
	
    $DATABASE_NAME = Read-Host "Enter Signum ${name} database name (or press Enter for default ${database})"
    if (-not $DATABASE_NAME) { $DATABASE_NAME = $database }
    Write-Host "Database name: ${DATABASE_NAME}"

    $DATABASE_USERNAME = Read-Host "Enter the username (or press Enter for default ${user})"
    if (-not $DATABASE_USERNAME) { $DATABASE_USERNAME = $user }
    Write-Host "Username: ${DATABASE_USERNAME}"

    $DATABASE_PASSWORD = Read-Host "Enter the password (or press Enter for default ${password})"
    if (-not $DATABASE_PASSWORD) { $DATABASE_PASSWORD = $password }
    Write-Host "Password: ${DATABASE_PASSWORD}"

    Write-Host "Starting MariaDB server ..."
	# Last OK
    # Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Hidden
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	
	& .\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\Database\MariaDB\mariadb-10.6.20-winx64\start-mariadb.ps1" "-WindowStyle Minimized"

    Start-Sleep -Seconds $SLEEP_SECONDS

    Write-Host "Creating database: ${DATABASE_NAME}"
	$createDatabaseQuery = "CREATE DATABASE IF NOT EXISTS ``${DATABASE_NAME}``;"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createDatabaseQuery

    Write-Host "Creating user: ${DATABASE_USERNAME}"
	$createUserQuery = "CREATE USER IF NOT EXISTS '${DATABASE_USERNAME}'@'localhost' IDENTIFIED BY '${DATABASE_PASSWORD}';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createUserQuery

    Write-Host "Granting permissions to user ${DATABASE_USERNAME} on database ${DATABASE_NAME} ..."
	$grantPermissionsQuery = "GRANT ALL PRIVILEGES ON ``${DATABASE_NAME}``.* TO '${DATABASE_USERNAME}'@'localhost';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $grantPermissionsQuery
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e "FLUSH PRIVILEGES;"

	$global:DATABASE_NAME = $DATABASE_NAME
	$global:DATABASE_USERNAME = $DATABASE_USERNAME
	$global:DATABASE_PASSWORD = $DATABASE_PASSWORD

    Write-Host "MariaDB setup complete."
}

function setup_mariadb_readonly ($name, $database, $user, $password) {
	
	$DATABASE_NAME = ""
	$DATABASE_USERNAME = ""
	$DATABASE_PASSWORD = ""
	
	$global:DATABASE_NAME = $null
	$global:DATABASE_USERNAME = $null
	$global:DATABASE_PASSWORD = $null
	
	$DATABASE_NAME = $database
    Write-Host "Database name: ${DATABASE_NAME}"

    $DATABASE_USERNAME = Read-Host "Enter the username (or press Enter for default ${user})"
    if (-not $DATABASE_USERNAME) { $DATABASE_USERNAME = $user }
    Write-Host "Username: ${DATABASE_USERNAME}"

    $DATABASE_PASSWORD = Read-Host "Enter the password (or press Enter for default ${password})"
    if (-not $DATABASE_PASSWORD) { $DATABASE_PASSWORD = $password }
    Write-Host "Password: ${DATABASE_PASSWORD}"

    Write-Host "Starting MariaDB server ..."
	# Last OK
    # Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Hidden
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	
	& .\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\Database\MariaDB\mariadb-10.6.20-winx64\start-mariadb.ps1" "-WindowStyle Minimized"

    Start-Sleep -Seconds $SLEEP_SECONDS

    Write-Host "Creating user: ${DATABASE_USERNAME}"
	$createUserQuery = "CREATE USER IF NOT EXISTS '${DATABASE_USERNAME}'@'localhost' IDENTIFIED BY '${DATABASE_PASSWORD}';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createUserQuery

    Write-Host "Granting permissions to user ${DATABASE_USERNAME} on database ${DATABASE_NAME} ..."
	$grantPermissionsQuery = "GRANT SELECT, SHOW VIEW ON ``${DATABASE_NAME}``.* TO '${DATABASE_USERNAME}'@'localhost';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $grantPermissionsQuery

<#
	# Indexing
	# SQL commands to execute
	$sqlCommands = 
@"
USE ``${DATABASE_NAME}``;
CREATE INDEX transaction_height_timestamp ON transaction(height, timestamp);
CREATE INDEX asset_height ON asset(height);
CREATE INDEX account_latest ON account(latest);
"@
	
	# Execute each SQL command
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $sqlCommands
#>	
	
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e "FLUSH PRIVILEGES;"

	$global:DATABASE_NAME = $DATABASE_NAME
	$global:DATABASE_USERNAME = $DATABASE_USERNAME
	$global:DATABASE_PASSWORD = $DATABASE_PASSWORD

    Write-Host "MariaDB setup complete."
}


function setup_mariadb_explorer ($name, $database, $user, $password) {
	
	$DATABASE_NAME = ""
	$DATABASE_USERNAME = ""
	$DATABASE_PASSWORD = ""
	
	$global:DATABASE_NAME = $null
	$global:DATABASE_USERNAME = $null
	$global:DATABASE_PASSWORD = $null
	
    $DATABASE_NAME = Read-Host "Enter Signum ${name} database name (or press Enter for default ${database})"
    if (-not $DATABASE_NAME) { $DATABASE_NAME = $database }
    Write-Host "Database name: ${DATABASE_NAME}"

    $DATABASE_USERNAME = Read-Host "Enter the username (or press Enter for default ${user})"
    if (-not $DATABASE_USERNAME) { $DATABASE_USERNAME = $user }
    Write-Host "Username: ${DATABASE_USERNAME}"

    $DATABASE_PASSWORD = Read-Host "Enter the password (or press Enter for default ${password})"
    if (-not $DATABASE_PASSWORD) { $DATABASE_PASSWORD = $password }
    Write-Host "Password: ${DATABASE_PASSWORD}"

    Write-Host "Starting MariaDB server ..."
	# Last OK
    # Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Hidden
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	
	& .\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\Database\MariaDB\mariadb-10.6.20-winx64\start-mariadb.ps1" "-WindowStyle Minimized"

    Start-Sleep -Seconds $SLEEP_SECONDS

    Write-Host "Creating database: ${DATABASE_NAME}"
	$createDatabaseQuery = "CREATE DATABASE IF NOT EXISTS ``${DATABASE_NAME}``;"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createDatabaseQuery

    Write-Host "Creating user: ${DATABASE_USERNAME}"
	$createUserQuery = "CREATE USER IF NOT EXISTS '${DATABASE_USERNAME}'@'localhost' IDENTIFIED BY '${DATABASE_PASSWORD}';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createUserQuery

    Write-Host "Granting permissions to user ${DATABASE_USERNAME} on database ${DATABASE_NAME} ..."
	$grantPermissionsQuery = "GRANT ALL PRIVILEGES ON ``${DATABASE_NAME}``.* TO '${DATABASE_USERNAME}'@'localhost';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $grantPermissionsQuery

	# Define the SQL queries
	$sqlQueryGetUser = "SELECT '$DATABASE_USERNAME' FROM mysql.user;"

	$sqlQueryCreateTable = 
@"
USE $DATABASE_NAME;

CREATE TABLE scan_peermonitor (
	announced_address VARCHAR(255) PRIMARY KEY,
	real_ip VARCHAR(255),
	platform VARCHAR(255),
	application VARCHAR(255),
	version VARCHAR(255),
	height INTEGER,
	cumulative_difficulty VARCHAR(255),
	country_code CHAR(2),
	state SMALLINT,
	downtime INTEGER DEFAULT 0,
	lifetime INTEGER DEFAULT 0,
	availability FLOAT DEFAULT 0,
	last_online_at TIMESTAMP,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	reward_state VARCHAR(255) DEFAULT 'none',
	reward_time TIMESTAMP
);
"@

	# Run the queries
	Write-Host "Executing query to retrieve user details..."
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $sqlQueryGetUser

	Write-Host "Creating table in the Signum ${name} database..."
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $sqlQueryCreateTable
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e "FLUSH PRIVILEGES;"
	
	$global:DATABASE_NAME = $DATABASE_NAME
	$global:DATABASE_USERNAME = $DATABASE_USERNAME
	$global:DATABASE_PASSWORD = $DATABASE_PASSWORD

    Write-Host "MariaDB setup complete."
}

function setup_db_node_properties($file) {
	
	Write-Host "Updating node.properties with new database configurations ..."
	$content = Get-Content -Path $file
	
		for ($i = 0; $i -lt $content.Count; $i++) {

			# Get the current line
			$line = $content[$i]

			if ($content[$i] -match '# DB.Url=jdbc:mariadb:.*') {
				$content[$i] = "DB.Url=jdbc:mariadb://localhost:$MARIADB_PORT/${DATABASE_NAME}"
				$content[$i+1] = "DB.Username=${DATABASE_USERNAME}"
				$content[$i+2] = "DB.Password=${DATABASE_PASSWORD}"
				break
			}
		}

	# Write the changes back to the file
	$content | Set-Content -Path ${file}

	<#
    (Get-Content -Path $file) -replace '# DB.Url=jdbc:mariadb:.*', "DB.Url=jdbc:mariadb://localhost:$MARIADB_PORT/${DATABASE_NAME}" `
        -replace '# DB.Username=.*', "DB.Username=${DATABASE_USERNAME}" `
        -replace '# DB.Password=.*', "DB.Password=${DATABASE_PASSWORD}" | Set-Content -Path $file
	#>
    Write-Host "Update complete."
	
}

function setup_db_pool_properties($file) {
	
	Write-Host "Updating pool.properties with new database configurations ..."
    (Get-Content -Path $file) -replace 'dbUrl=jdbc:h2:file*', "# dbUrl=jdbc:h2:file:./db/pooldb.h2;DB_CLOSE_ON_EXIT=FALSE" `
        -replace '^dbUsername=', "# dbUsername=" `
        -replace '^dbPassword=', "# dbPassword=" `
		-replace '^#dbUrl=jdbc:mariadb://localhost:3306/pooldb*', "dbUrl=jdbc:mariadb://localhost:$MARIADB_PORT/${DATABASE_NAME}" `
        -replace '^#dbUsername=root', "dbUsername=${DATABASE_USERNAME}" `
        -replace '^#dbPassword=passw', "dbPassword=${DATABASE_PASSWORD}" | Set-Content -Path $file

    Write-Host "Update complete."
	
}

function question-prompt($process, $name, $installFunction) {
	# Initialize the global variable
	$global:UserResponse = $null
    $userChoice = Read-Host "Do you want to ${process} ${name} (yes/no)"
    if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {
		$global:UserResponse = "yes"
        &$installFunction
	} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
		$global:UserResponse = "no"
		Write-Host "${name} ${process} canceled."
	} else {
		$global:UserResponse = $null
		Write-Host "Wrong choice, please try again"
		Pause
		question-prompt $process $name $installFunction
	}
}

function download-prompt($name, $url, $target_path, $file) {
	# Initialize the global variable
	$global:UserResponse = $null
    $userChoice = Read-Host "Do you want to download ${name} (yes/no)"
    if ($userChoice -match '^(yes|y|Y)$') {
		if (-not (Test-Path "${target_path}")) {
			$global:UserResponse = "yes"
			New-Item -Path "${target_path}" -ItemType Directory | Out-Null
		}
		Write-Host "Downloading ${name} ..."
		# Start-BitsTransfer -Source $url -Destination $file
		Invoke-WebRequest -Uri ${url} -OutFile ${file}
		Write-Host "${name} downloaded successfully."
		# Invoke-WebRequest -Uri $url -OutFile $file
		# Invoke-RestMethod -Uri $url -OutFile $file
    } else {
		$global:UserResponse = "no"
        Write-Host "${name} download canceled."
    }
}

# TODO Every installer folder has the OS specific batch file creation which call the PowerShell 

# TODO download whitepaper if not exist
# TODO make every directory and file exist check a function
# TODO add plotter
# TOTO add miner
# TODO setup menu mariadb setup signum node setup e.g.

# Initialize the script by showing the install menu
# Pause

# Show-InstallMenu

#===================================================================#

#================#
# Start GUI Code #
#================#

#=======================#
# Functions definitions #
#=======================#

#================#
# Util functions #
#================#

# TODO modify parameter call 
# Function to select YES/NO answer
function question-prompt-backend ($process, $name, $installFunction) {
	# Initialize the global variable
	$global:UserResponse = $null
    $userChoice = Read-Host "Do you want to ${process} ${name} (yes/no)"
    if ($userChoice -match '^(yes|YES|Yes|y|Y)$') {
		$global:UserResponse = "yes"
        &$installFunction
	} elseif ($userChoice -match '^(no|NO|No|n|N)$') {
		$global:UserResponse = "no"
		Write-Host "${name} ${process} canceled."
	} else {
		$global:UserResponse = $null
		Write-Host "Wrong choice, please try again"
		Pause
		question-prompt-backend $process $name $installFunction
	}
}

# Function to start a process
function start-process-menu-backend($file, $name, $installFunction) {
	if (Test-Path $file) {
		Write-Host "Starting ${name} ..."
		# Start-Process -FilePath $file $command
		& $POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File "$file"
		# Start-Process -FilePath $POWERSHELL_EXEC_PATH -ArgumentList "-ExecutionPolicy Bypass", "-File", $file
		Pause
		Show-StartMenu
	} else {
		Write-Host "${name} is not installed, please install first!"
		question-prompt-backend "Install" $name $installFunction
		Pause
		Show-StartMenu
	}
}

# Function to create executable to starter PS1 files
function create-starter-ps1-exec-backend {
	param (
        [string]$PSFileName,
		[string]$PSExecRelPath,
		[string]$StarterExecName,
		[string]$StarterExecRelPath
    )
	try {
		if (-not (Test-Path $StarterExecRelPath)) {
			# Create start-node batch file with the desired content
			$content = 
@"
cd %~dp0
$PSExecRelPath -ExecutionPolicy Bypass -File ".\$PSFileName"
"@
			$content | Out-File -FilePath $StarterExecRelPath -Force
			Write-Host "$StarterExecName successfully created."  -ForegroundColor Green
		} else {
			Write-Host "File already exists: $StarterExecName"  -ForegroundColor Yellow
		}
	} catch {
		Write-Host "Error during creation $StarterExecName file."  -ForegroundColor Red
		Write-Host $_.Exception.Message -ForegroundColor DarkRed
	}
}

# Function to check port availability
function Test-PortAvailability {
    param (
        [int]$Port
    )
    $tcpListener = New-Object System.Net.Sockets.TcpListener([System.Net.IPAddress]::Any, $Port)
    try {
        $tcpListener.Start()
        $tcpListener.Stop()
        return $true  # Port is available
    } catch {
        return $false # Port is already in use
    }
}

# Function to check if running as Administrator
function Test-IsAdmin {
    if ($IsWindows) {
        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $principal = New-Object System.Security.Principal.WindowsPrincipal($currentUser)
        return $principal.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
    }
    elseif ($IsLinux -or $IsMacOS) {
        return $(whoami) -eq "root"
    }
    return $false
}

# Function to restart PowerShell as Administrator
function Restart-AsAdmin {
    if ($IsWindows) {
		try {
			Start-Process -FilePath $POWERSHELL_EXEC_PATH -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -Verb RunAs
			Write-Host "Restarting PowerShell as Administrator..." -ForegroundColor Yellow
		}
		catch {
			Write-Host "Error ocurred while Restarting PowerShell as Administrator." -ForegroundColor Red
			Write-Host $_.Exception.Message -ForegroundColor DarkRed
		}
        exit
    }
    elseif ($IsLinux -or $IsMacOS) {
		try {
			sudo pwsh "$PSCommandPath"
			Write-Host "Restarting PowerShell as root..." -ForegroundColor Yellow
		}
		catch {
			Write-Host "Error ocurred while Restarting PowerShell as root." -ForegroundColor Red
			Write-Host $_.Exception.Message -ForegroundColor DarkRed
		}
        exit
    }
    else {
        Write-Host "Unknown OS. Cannot restart with elevated privileges." -ForegroundColor Red
        exit 1
    }
}

#=====================#
# Installer functions #
#=====================#

# Function to download documentations
function install-doc-init-backend {
	
	# Create directory
    if (-not (Test-Path -Path $DOCUMENTS_DIR)) {
		New-Item -Path "$DOCUMENTS_DIR" -ItemType Directory | Out-Null
	} else {
		Write-Host "$DOCUMENTS_DIR already exists."
	}
	
	$content = 
@"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signum Cryptocurrency Resources</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            text-align: center;
        }
        .section {
            margin-bottom: 20px;
        }
        .section h2 {
            border-bottom: 2px solid #000;
            padding-bottom: 5px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li {
            margin: 5px 0;
        }
        a {
            color: #007BFF;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Signum Cryptocurrency Resources</h1>
    
    <div class="section">
        <h2>Documentation & Development</h2>
        <ul>
            <li><a href="https://github.com/deleterium/SmartC/blob/v2.1/docs%2FREADME.md">SmartC README</a></li>
            <li><a href="https://docs.signum.network/ecosystem/resources-for-developers">Developer Resources</a></li>
            <li><a href="https://wiki.signum.network/signum-software/index.htm">Signum Software Wiki</a></li>
            <li><a href="https://github.com/signum-network/signumj">SignumJ GitHub</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Research & Papers</h2>
        <ul>
            <li><a href="https://www.signum.network/wp/Signum_Business_Whitepaper.pdf">Signum Business Whitepaper</a></li>
            <li><a href="https://indecs.eu/2024/indecs2024-pp738-762.pdf">Blockchain for IoT Devices</a></li>
            <li><a href="https://www.whitehouse.gov/wp-content/uploads/2022/09/09-2022-Crypto-Assets-and-Climate-Report.pdf">Crypto-Assets and Climate Report</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Community & Social Media</h2>
        <ul>
            <li><a href="https://discord.com/invite/QHZkF4KHDS">Signum Discord</a></li>
            <li><a href="https://x.com/signum_official">Signum X</a></li>
            <li><a href="https://t.me/signumnetwork">Signum Network Telegram</a></li>
            <li><a href="https://t.me/Signum_Russia">Signum Russia Telegram</a></li>
            <li><a href="https://t.me/signumchain">Signum Chain Telegram</a></li>
            <li><a href="https://t.me/Signum_HK">Signum HK Telegram</a></li>
            <li><a href="https://t.me/signa_holders">Signa Holders Telegram</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Tools & Services</h2>
        <ul>
            <li><a href="https://miningpoolstats.stream/signa">Mining Pool Stats</a></li>
            <li><a href="http://ciyam.org/at/">CIYAM AT</a></li>
            <li><a href="https://signum.dappository.world/">Signum Dappository</a></li>
            <li><a href="https://signum-neo-node.pages.dev/">Signum Neo Node</a></li>
            <li><a href="https://docs.signum.network/signumswap/add-a-customised-icon">SignumSwap Custom Icon</a></li>
            <li><a href="https://explorer.signum.network/">Signum Explorer</a></li>
        </ul>
    </div>
    
    <div class="section">
        <h2>External Resources</h2>
        <ul>
            <li><a href="https://coindar.org/en/coin/signum">Coindar Signum</a></li>
            <li><a href="https://bitcointalk.org/index.php?action=profile;u=364787">BitcoinTalk Profile</a></li>
            <li><a href="https://xeggex.com/market/SIGNA_BTC">Xeggex Market SIGNA/BTC</a></li>
            <li><a href="https://fomplo.com/signum-subscriptions">Signum Subscriptions</a></li>
            <li><a href="https://signum.network/">Signum Network</a></li>
            <li><a href="https://www.signumart.io/">NFT Portal</a></li>
        </ul>
    </div>
</body>
</html>
"@
	
	# Create Signum link collection page
	if (-not (Test-Path $SIGNUM_LINK_COLLECTION_PATH)) {
		
		# Create Signum-Link-Collection.html file with the desired content
		$content | Out-File -FilePath $SIGNUM_LINK_COLLECTION_PATH -Force
		Write-Host "${SIGNUM_LINK_COLLECTION_PATH} successfully created."
		
	} else {
		
		Write-Host "File already exists: ${SIGNUM_LINK_COLLECTION_PATH}"
		$fileContent = Get-Content -Path $SIGNUM_LINK_COLLECTION_PATH -Raw
		# Compare the content
		
		if ($fileContent.TrimEnd() -eq $content.TrimEnd()) {
			
			Write-Output "The contents are the same."
			
		} else {
			
			Write-Output "The contents are different."
			Write-Output "Update $SIGNUM_LINK_COLLECTION."
			$content | Out-File -FilePath $SIGNUM_LINK_COLLECTION_PATH -Force
			
		}
	}
	
	if (-not (Test-Path -Path $WHITEPAPER_DOC_PATH)) {
		Write-Host "Downloading $WHITEPAPER_DOC_NAME"
		Invoke-WebRequest -Uri $WHITEPAPER_URL -OutFile $WHITEPAPER_DOC_PATH
	} else {
		Write-Host "$WHITEPAPER_DOC_PATH already exists."
	}
	
	if (-not (Test-Path -Path $WHITEHOUSE_DOC_PATH)) {
		Write-Host "Downloading $WHITEHOUSE_DOC_NAME"
		Invoke-WebRequest -Uri $WHITEHOUSE_URL -OutFile $WHITEHOUSE_DOC_PATH
	} else {
		Write-Host "$WHITEHOUSE_DOC_PATH already exists."
	}
	
	if (-not (Test-Path -Path $INDECS_DOC_PATH)) {
		Write-Host "Downloading $INDECS_DOC_NAME"
		Invoke-WebRequest -Uri $INDECS_URL -OutFile $INDECS_DOC_PATH
	} else {
		Write-Host "$INDECS_DOC_PATH already exists."
	}

	Write-Host "Documents downloaded successfully"
	
}

# Function to install nodejs
function install_nodejs-backend {
    # Create NodeJS directory
    if (-not (Test-Path "${NODEJS_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${NODEJS_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${NODEJS_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${NODEJS_DIR_NAME}"
    }

    if (Test-Path "${NODEJS_ZIP_PATH}") {
        Write-Host "${NODEJS_ZIP_PATH} already downloaded."
    } else {
        # Download NodeJs
        Write-Host "Downloading NodeJS ..."
        # Start-BitsTransfer -Source "${NODEJS_URL}" -Destination "${NODEJS_ZIP_PATH}"
		Invoke-WebRequest -Uri ${NODEJS_URL} -OutFile ${NODEJS_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path "${NODEJS_ZIP_PATH}")) {
            Write-Host "Error: Failed to download Notepad."
            Pause
            return
        }
    }

    if (Test-Path "${NODEJS_UNZIP_PATH}") {
        Write-Host "${NODEJS_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Notepad to $NODEJS_UNZIP_PATH ..."
        Expand-Archive -Path "$NODEJS_ZIP_PATH" -DestinationPath "$NODEJS_DIR_PATH" -Force
    }

	# Create starter ps1
	if (-not (Test-Path $NODEJS_STARTER_PS1_PATH)) {
		# Create start-nodejs.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start NodeJS
Set-Location -Path `$PSScriptRoot

# Start NodeJS
Start-Process -FilePath ".\$NODEJS_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $NODEJS_STARTER_PS1_PATH -Force

		Write-Host "${NODEJS_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${NODEJS_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec-backend -PSFileName $NODEJS_STARTER_PS1_NAME `
								-PSExecRelPath "..\..\..\$POWERSHELL_EXEC_PATH" `
								-StarterExecName $NODEJS_STARTER_EXEC_NAME `
								-StarterExecRelPath $NODEJS_STARTER_EXEC_PATH

	Write-Host "NodeJS installed successfully."
	
}

# Function to install portable browser
function install_chromium_browser_backend {
	Write-Host "Installing Chromium Browser ..."

    # Create Browser directory
    if (-not (Test-Path "$BROWSER_CHROMIUM_DIR_PATH")) {
        New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_DIR_PATH" | Out-Null
        Write-Host "Created directory: ${BROWSER_CHROMIUM_DIR_PATH}"
    } else {
        Write-Host "Directory already exists: ${BROWSER_CHROMIUM_DIR_PATH}"
    }

    if (Test-Path "$BROWSER_CHROMIUM_ZIP_PATH") {
        Write-Host "${BROWSER_CHROMIUM_ZIP_PATH} already downloaded."
    } else {
        # Download Chromium Browser
        Write-Host "Downloading Chromium Browser ..."
        # Start-BitsTransfer -Source "${BROWSER_CHROMIUM_URL}" -Destination "${BROWSER_CHROMIUM_ZIP_PATH}"
		Invoke-WebRequest -Uri $BROWSER_CHROMIUM_URL -OutFile $BROWSER_CHROMIUM_ZIP_PATH

        # Check if download was successful
        if (-not (Test-Path "$BROWSER_CHROMIUM_ZIP_PATH")) {
            Write-Host "Error: Failed to download Notepad."
            Pause
            return
        }
    }

	# Unzip files
    if (Test-Path "$BROWSER_CHROMIUM_UNZIP_PATH") {
        Write-Host "$BROWSER_CHROMIUM_UNZIP_PATH already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping Chromium Browser to $BROWSER_CHROMIUM_UNZIP_PATH ..."
        Expand-Archive -Path "$BROWSER_CHROMIUM_ZIP_PATH" -DestinationPath "$BROWSER_CHROMIUM_DIR_PATH" -Force
    }

	# Create starter ps1
	if (-not (Test-Path $BROWSER_CHROMIUM_STARTER_PS1_PATH)) {
		# Create start-notepad.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start Chromium Browser
Set-Location -Path `$PSScriptRoot

# Start Chromium Browser
Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_NAME" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}"

exit
"@

		$content | Out-File -FilePath $BROWSER_CHROMIUM_STARTER_PS1_PATH -Force

		Write-Host "${BROWSER_CHROMIUM_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${BROWSER_CHROMIUM_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec-backend -PSFileName $BROWSER_CHROMIUM_STARTER_PS1_NAME `
								-PSExecRelPath "..\..\..\$POWERSHELL_EXEC_PATH" `
								-StarterExecName $BROWSER_CHROMIUM_STARTER_EXEC_NAME `
								-StarterExecRelPath $BROWSER_CHROMIUM_STARTER_EXEC_PATH

	# Create Extensins directory
	if (-not (Test-Path "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH")) {
		New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH" | Out-Null
		Write-Host "Created directory: ${BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH}"
	} else {
		Write-Host "Directory already exists: ${BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH}"
	}

	# In case true installation of released version
	if ($BROWSER_CHROMIUM_SIGNUM_XT_VERSION_INSTALL) {
		# Install SignumXT Extension from github release
		# Check if given SignumXT Extention is installed
		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH\fullpage.html") {
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH already installed."
		} else {
			# Create SignumXT directory from github release version
			if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH")) {
				New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH" | Out-Null
				Write-Host "Created directory: ${BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH}"
			} else {
				Write-Host "Directory already exists: ${BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH}"
			}

			if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH") {
				Write-Host "${BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH} already downloaded."
			} else {
				# Download SignumXT Extension
				Write-Host "Downloading SignumXT Extension ..."
				# Start-BitsTransfer -Source "${BROWSER_CHROMIUM_URL}" -Destination "${BROWSER_CHROMIUM_ZIP_PATH}"
				Invoke-WebRequest -Uri $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_URL -OutFile $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH

				# Check if download was successful
				if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH")) {
					Write-Host "Error: Failed to download Notepad."
					Pause
					return
				}
			}
			# Unzip the downloaded file to the installation directory
			Write-Host "Unzipping SignumXT to $BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH ..."
			Expand-Archive -Path "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_ZIP_PATH" -DestinationPath "$BROWSER_CHROMIUM_SIGNUM_XT_VERSION_DIR_PATH" -Force
		}

		Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}",`
			"--load-extension=.\$BROWSER_CHROMIUM_EXTENSIONS_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_VERSION"

	} else {

		# TODO BUG Extension is not loading
		# Create SignumXT directory from github main branch
		if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH")) {
			New-Item -ItemType Directory -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH" | Out-Null
			Write-Host "Created directory: ${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH}"
		} else {
			Write-Host "Directory already exists: ${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH}"
		}

		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH") {
			Write-Host "${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH} already downloaded."
		} else {
			# Download SignumXT Extension
			Write-Host "Downloading SignumXT Extension ..."
			Write-Host "From URL: $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_URL"
			Write-Host "To: $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH"
			# Start-BitsTransfer -Source "${BROWSER_CHROMIUM_URL}" -Destination "${BROWSER_CHROMIUM_ZIP_PATH}"
			Invoke-WebRequest -Uri $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_URL -OutFile $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH

			# Check if download was successful
			if (-not (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH")) {
				Write-Host "Error: Failed to download Notepad."
				Pause
				return
			}
		}

		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH") {
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH already unzipped."
		} else {
			# Unzip the downloaded file to the installation directory
			Write-Host "Unzipping original main to $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH ..."
			Expand-Archive -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH" -DestinationPath "$BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH" -Force
		}

		# Install nodejs
		install_nodejs-backend

		Set-Location ".\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH"

		# Build SignumXT from github main branch
		Write-Host "Build SignumXT from github main branch"
		& "..\..\..\..\..\${NODEJS_UNZIP_PATH}\node_modules\corepack\shims\yarn.cmd" install
		& "..\..\..\..\..\${NODEJS_UNZIP_PATH}\node_modules\corepack\shims\yarn.cmd" build:chrome
		
		Set-Location -Path $PSScriptRoot

		# Install SignumXT Extension from github main branch
		# Unzip files
		# TODO Questionprompt for reinstall
		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH\fullpage.html") {
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH already installed."
		} else {
			# Unzip the SignumXT to the installation directory
			Write-Host "Unzipping SignumXT original main to $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH ..."
			Expand-Archive -Path "${BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH}\dist\${BROWSER_CHROMIUM_SIGNUM_XT_ZIP_NAME}" -DestinationPath "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_PATH" -Force
	
		}
<#
		Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}",`
			"--load-extension=.\$BROWSER_CHROMIUM_EXTENSIONS_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_DIR_NAME\$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_DIR_NAME"
#>

		Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH" -ArgumentList "--user-data-dir=.\${BROWSER_CHROMIUM_PROFILE_DIR_NAME}"

		# Delete files
		Write-Host "Cleaning $BROWSER_CHROMIUM_EXTENSIONS_DIR_PATH directory."
		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH") {
			Write-Host "Delete $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH file."
			Remove-Item -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH" -Force
		} else {
			# Delete the downloaded file
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_ZIP_ORIGINAL_PATH already deleted"
		}

		if (Test-Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH") {
			Write-Host "Delete $BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH file."
			Remove-Item -Path "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH" -Recurse -Force
		} else {
			# Delete the downloaded file
			Write-Host "$BROWSER_CHROMIUM_SIGNUM_XT_MAIN_UNZIP_ORIGINAL_PATH already deleted"
		}

	}

	Write-Host "Chromium Browser installed successfully."
	
}

# Function to install neccessary modules
function Ensure-PortableModule {
    param (
        [string]$ModuleName,
        [string]$ModulePath = ".\PowerShellModules"
    )

    # Ensure the module directory exists
    if (!(Test-Path $ModulePath)) {
        New-Item -ItemType Directory -Path $ModulePath -Force | Out-Null
    }

    # Add module path to PSModulePath
    $env:PSModulePath = "$ModulePath;$env:PSModulePath"

    # Check if the module is already installed
    $installedModule = Get-Module -ListAvailable -Name $ModuleName | Sort-Object Version -Descending | Select-Object -First 1
    $latestModule = Find-Module -Name $ModuleName | Select-Object -First 1

    if (!$installedModule) {
        Write-Host "$ModuleName is not installed. Installing it to $ModulePath..." -ForegroundColor Yellow
        try {
            Save-Module -Name $ModuleName -Path $ModulePath -Force
            Write-Host "$ModuleName installed successfully!" -ForegroundColor Green
        } catch {
            Write-Host "❌ Failed to install ${ModuleName}: $_" -ForegroundColor Red
            exit 1
        }
    } elseif ($installedModule.Version -lt $latestModule.Version) {
        Write-Host "⚠️ A newer version of $ModuleName is available. Updating..."
        try {
            Remove-Item -Recurse -Force "$ModulePath\$ModuleName"
            Save-Module -Name $ModuleName -Path $ModulePath -Force
            Write-Host "✅ $ModuleName updated to version $($latestModule.Version)" -ForegroundColor Green
        } catch {
            Write-Host "❌ Failed to update ${ModuleName}: $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "✅ $ModuleName is up to date (version $($installedModule.Version))." -ForegroundColor Cyan
    }

    # Import the module
    try {
        Import-Module -Name "$ModulePath\$ModuleName" -Force -ErrorAction Stop
        Write-Host "✅ $ModuleName imported successfully!" -ForegroundColor Green
    } catch {
        Write-Host "❌ Failed to import ${ModuleName}: $_" -ForegroundColor Red
        exit 1
    }
}

<#
# Function to define the web server function
function Start-PowerShellWebServer {
    param (
        [int]$Port = 8080
    )

    # Create an HTTP listener
    $listener = New-Object System.Net.HttpListener
    $listener.Prefixes.Add("http://+:$Port/")
    $listener.Start()
    Write-Host "🚀 Web server started on http://localhost:$Port"

    while ($listener.IsListening) {
        # Wait for a request
        $context = $listener.GetContext()
        $request = $context.Request
        $response = $context.Response

        # Generate a response
        $responseString = "<html><body><h1>Hello from .NET PowerShell Web Server!</h1></body></html>"
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($responseString)
        $response.ContentLength64 = $buffer.Length
        $output = $response.OutputStream
        $output.Write($buffer, 0, $buffer.Length)
        $output.Close()
    }

	Show-StartMenu

    # Stop the listener
    $listener.Stop()
}
#>

<#
# Function to define the web server function
function Start-PowerShellWebServer {
    param (
        [int]$Port = 8080
    )

    # Create an HTTP listener
    $listener = New-Object System.Net.HttpListener
    $listener.Prefixes.Add("http://+:$Port/")
    $listener.Prefixes.Add("http://+:$Port/start-menu/")  # Add a route for triggering Show-StartMenu
    $listener.Start()
    Write-Host "🚀 Web server started on http://localhost:$Port"

    while ($listener.IsListening) {
        try {
            # Wait for a request
            $context = $listener.GetContext()
            $request = $context.Request
            $response = $context.Response

            if ($request.Url.AbsolutePath -eq "/start-menu" -and $request.HttpMethod -eq "POST") {
                # If button was clicked, execute Show-StartMenu
                Write-Host "🟢 Button clicked, executing Show-StartMenu..."
                Show-StartMenu
                $responseString = "<html><body><h1>Show-StartMenu executed!</h1><a href='/'>Go Back</a></body></html>"
            }
            else {
                # Serve main page with a button
                $responseString = @"
<html>
<body>
    <h1>PowerShell Web Server</h1>
    <button onclick="fetch('/start-menu', { method: 'POST' }).then(() => alert('Show-StartMenu executed!'));">
        Start Menu
    </button>
</body>
</html>
"@
            }

            # Send response
            $buffer = [System.Text.Encoding]::UTF8.GetBytes($responseString)
            $response.ContentLength64 = $buffer.Length
            $output = $response.OutputStream
            $output.Write($buffer, 0, $buffer.Length)
            $output.Close()
        }
        catch {
            Write-Host "❌ Error: $_"
        }
    }

    # Stop the listener
    $listener.Stop()
}
#>

function install_heidisql-backend {
    # Create HeidiSQL directory
    if (-not (Test-Path "${HEIDISQL_DIR_PATH}")) {
        New-Item -ItemType Directory -Path "${HEIDISQL_DIR_PATH}" | Out-Null
        Write-Host "Created directory: ${HEIDISQL_DIR_NAME}"
    } else {
        Write-Host "Directory already exists: ${HEIDISQL_DIR_NAME}"
    }

    if (Test-Path "${HEIDISQL_ZIP_PATH}") {
        Write-Host "${HEIDISQL_ZIP_NAME} already downloaded."
    } else {
        # Download HeidiSQL
        Write-Host "Downloading HeidiSQL ..."
        # Start-BitsTransfer -Source "${HEIDISQL_URL}" -Destination "${HEIDISQL_ZIP_PATH}"
		Invoke-WebRequest -Uri ${HEIDISQL_URL} -OutFile ${HEIDISQL_ZIP_PATH}

        # Check if download was successful
        if (-not (Test-Path "${HEIDISQL_ZIP_PATH}")) {
            Write-Host "Error: Failed to download HeidiSQL."
            Pause
            return
        }
    }

    if (Test-Path "${HEIDISQL_UNZIP_PATH}") {
        Write-Host "${HEIDISQL_UNZIP_NAME} already installed."
    } else {
        # Unzip the downloaded file to the installation directory
        Write-Host "Unzipping HeidiSQL to $TOOLS_DIR_NAME\$HEIDISQL_DIR_NAME\$HEIDISQL_UNZIP_NAME ..."
        Expand-Archive -Path "$TOOLS_DIR_NAME\$HEIDISQL_DIR_NAME\$HEIDISQL_ZIP_NAME" -DestinationPath "$TOOLS_DIR_NAME\$HEIDISQL_DIR_NAME\$HEIDISQL_UNZIP_NAME" -Force
	}
		
	# Create starter ps1
	if (-not (Test-Path $HEIDISQL_STARTER_PS1_PATH)) {
		# Create start-node.ps1 file with the desired content
		$content = 
@"
# PowerShell script to start HeidiSQL
Set-Location -Path `$PSScriptRoot

# Start HeidiSQL
Start-Process -FilePath ".\$HEIDISQL_EXEC_NAME"

exit
"@

		$content | Out-File -FilePath $HEIDISQL_STARTER_PS1_PATH -Force

		Write-Host "${HEIDISQL_STARTER_PS1_PATH} successfully created."
	} else {
			Write-Host "File already exists: ${HEIDISQL_STARTER_PS1_PATH}"
	}

	# Create starter batch
	create-starter-ps1-exec ${HEIDISQL_STARTER_PS1_NAME} ..\..\..\${POWERSHELL_EXEC_PATH} ${HEIDISQL_STARTER_EXEC_NAME} ${HEIDISQL_STARTER_EXEC_PATH}

	Write-Host "HeidiSQL installed successfully."
		
}

function install_mariadb-frontend {

	# TODO check .json file and list every mariadb instances
	# TODO follow the path database/mariadb/mariadb_version/id/mariadb_instance

	$html=
@"
	<script>
		async function fetchMariadbVersions() {

			try {
				let response = await fetch('/database/mariadb/release/versions');
				let versions = await response.json();
				let select = document.getElementById('mariadbVersionSelect');
				select.innerHTML = '';

				versions.forEach(version => {
					let opt = document.createElement('option');
					opt.value = version;
					opt.innerText = version;
					select.appendChild(opt);
				});

			} catch (error) {
				document.getElementById('loading').innerText = 'Error fetching data!';
				console.error("An error occured during Mariadb Version Fetching:", error);
				alert("An error occured during Mariadb Version Fetching: " + error.message);
			}
		}

		async function callInstallMariadbBackend() {

			const version = document.getElementById('mariadbVersionSelect').value;
			const port = document.getElementById('mariadbPort').value;

			const payload = {
				version: version,
				port: port
			};

			try {
				const response = await fetch('/database/mariadb/install', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify(payload)
				});

				if (!response.ok) {
					throw new Error("Bad response: " + response.status);
				}

				const result = await response.text(); // vagy response.json() ha JSON-t vársz
				alert("MariaDB install eredmény:\n" + result);
			} catch (error) {
				console.error("An error occured during Mariadb Installation:", error);
				alert("An error occured during Mariadb Installation: " + error.message);
			}
		}

		window.onload = fetchMariadbVersions;
	</script>
	
	<div id="loading" style="font-size:20px; color:blue;">Fetching necessary data...</div>

	<div id="content" style="display:block;">
		<h2>MariaDB Installation</h2>
		<form method="POST">
			<label>Version:</label>
			<select id="mariadbVersionSelect" name="version">
				<option>Loading...</option>
			</select>
			<label>Port:</label>
			<input type="text" id="mariadbPort" value="$MARIADB_PORT"/>
			<!--TODO Check all mariadb installation ports and set red color if port is already used, else green-->
			<!--TODO Check all mariadb installation fields and set Install button active if all check is correct, else set button to inactive-->
		</form>
		<button onclick="callInstallMariadbBackend()">Install MariaDB</button>
		<button onclick="fetchMariadbVersions()">Refresh Versions</button>
	</div>
"@

return $html
	
}

# TODO naming
function install_mariadb-backend {
    # install_heidisql-backend

	# TODO more comments

	if (-not (Test-Path $MARIADB_DIR_PATH)) {
		try {
			New-Item -ItemType Directory -Force -Path $MARIADB_DIR_PATH -ErrorAction Stop | Out-Null
			Write-Host "Directory created successfully: $MARIADB_DIR_PATH" -ForegroundColor Green
		}
		catch {
			Write-Host "Error occurred during directory creation: $MARIADB_DIR_PATH" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
		}
	} else {
		Write-Host "Directory already exists: $MARIADB_DIR_PATH" -ForegroundColor Green
	}
	
	if (-not (Test-Path $MARIADB_DOWNLOADS_DIR_PATH)) {
		try {
			New-Item -ItemType Directory -Force -Path $MARIADB_DOWNLOADS_DIR_PATH -ErrorAction Stop | Out-Null
			Write-Host "Directory created successfully: $MARIADB_DOWNLOADS_DIR_PATH" -ForegroundColor Green
		}
		catch {
			Write-Host "Error occurred during directory creation: $MARIADB_DOWNLOADS_DIR_PATH" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
		}
	} else {
		Write-Host "Directory already exists: $MARIADB_DOWNLOADS_DIR_PATH" -ForegroundColor Green
	}

    if (Test-Path "$MARIADB_ZIP_PATH") {
        Write-Host "${MARIADB_ZIP_NAME} already downloaded." -ForegroundColor Green
    } else {
        try {
			Invoke-WebRequest -Uri ${MARIADB_URL} -OutFile $MARIADB_ZIP_PATH
			Write-Host "MariaDB version downloaded successfully: ${MARIADB_VERSION}" -ForegroundColor Green
		}
		catch {
			Write-Host "Failed to download MariaDB version ${MARIADB_VERSION}" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
			Read-Host "Press Enter to continue"
            return
		}
    }

	# Unzip MariaDB to Downloads folder
	if (-not (Test-Path "$MARIADB_UNZIP_PATH")) {
		try {
			Expand-Archive -Path "$MARIADB_ZIP_PATH" -DestinationPath "$MARIADB_DOWNLOADS_DIR_PATH" -Force
			Write-Host "MariaDB successfully unzipped to $MARIADB_UNZIP_PATH" -ForegroundColor Green
		}
		catch {
			Write-Host "Failed to unzip MariaDB version ${MARIADB_VERSION}" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
			Read-Host "Press Enter to continue"
			return
		}
	} else {
		Write-Host "MariaDB already unzipped to $MARIADB_UNZIP_PATH" -ForegroundColor Green
	}

	# Check MariaDB installation
    if (-not (Test-Path "$MARIADB_BIN_PATH")) {
        try {
			Copy-Item -Path "$MARIADB_UNZIP_PATH\*" -Destination $MARIADB_DIR_PATH -Recurse -Force
			Write-Host "MariaDB successfully installed to $MARIADB_DIR_PATH" -ForegroundColor Green
		}
		catch {
			Write-Host "Failed to install MariaDB version ${MARIADB_VERSION}" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
			Read-Host "Press Enter to continue"
            return
		}
    }

	# TODO create version json

	# Create data dir if not exists
    if (-not (Test-Path "$MARIADB_DATA_PATH")) {
		try {
			New-Item -ItemType Directory -Force -Path $MARIADB_DATA_PATH -ErrorAction Stop | Out-Null
			Write-Host "Directory created successfully: $MARIADB_DATA_PATH" -ForegroundColor Green
		}
		catch {
			Write-Host "Error occurred during directory creation: $MARIADB_DATA_PATH" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
		}
    } else {
		Write-Host "Directory already exists: $MARIADB_DATA_PATH" -ForegroundColor Green
    }

	# Initializing MariaDB data directory
	if (-not (Test-Path "$MARIADB_DATA_PATH\my.ini")) {
		try {
			& "${MARIADB_BIN_PATH}\${MARIADB_INSTALL_EXEC_NAME}"
			Write-Host "MariaDB data directory initialized successfully" -ForegroundColor Green
		}
		catch {
			Write-Host "Error occurred during MariaDB data directory initialization" -ForegroundColor Red
			Write-Host "Error message: $PSItem" -ForegroundColor Red
		}
	} else {
		Write-Host "MariaDB data directory already initialized" -ForegroundColor Green
	}

	# TODO error handling
    if (-not (Test-Path $MARIADB_STARTER_PS1_PATH)) {
        $content = 
@"
# PowerShell script to start MariaDB
Set-Location -Path `$PSScriptRoot

# TODO find out how to run mariadb 1 within a powershell window, or 2 without powershell within mariadb own terminal window. Use the chosen soluton for 
# mariadb setup as well currently mariadb within powershell is used in mariadb setup
# 1:
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-Command", ".\bin\${MARIADBD_EXEC_NAME} --no-defaults" -WindowStyle Hidden
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-Command", ".\bin\${MARIADBD_EXEC_NAME} --no-defaults --console --port=$MARIADB_PORT" -WindowStyle Hidden
# Last OK
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-NoExit", "-Command", "```$host.UI.RawUI.WindowTitle = 'MariaDB'; .\bin\${MARIADBD_EXEC_NAME} --no-defaults --console --port=$MARIADB_PORT" -WindowStyle Minimized
# Start-Process -FilePath "..\..\..\${POWERSHELL_EXEC_PATH}" "-Command", ".\bin\${MARIADBD_EXEC_NAME} --no-defaults"
# 2: If I can set powershell window title it is ok as well
# Start-Process -FilePath ".\bin\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized

# & .\bin\${MARIADBD_EXEC_NAME} --no-defaults --console --port=$MARIADB_PORT

Start-Process -FilePath "..\..\${POWERSHELL_EXEC_PATH}" ``
    -ArgumentList "-NoExit", "-Command", `@"
    try {
        ```$host.UI.RawUI.WindowTitle = 'MariaDB'
        # Check if MariaDB is already running
		```$portInUse = Get-NetTCPConnection | Where-Object { ```$_.LocalPort -eq $MARIADB_PORT -and ```$_.State -eq 'Listen' }
        if (```$portInUse) {
            Write-Host 'MariaDB is already running.'
			exit
        } else {
			# Start MariaDB
			.\bin\mariadbd.exe --no-defaults --console --port=$MARIADB_PORT
		}
    } catch {
        Write-Host 'An error occurred while starting MariaDB: ```$_'
    } finally {
        # Always set the title to 'MariaDB Stopped' after MariaDB exits
        ```$host.UI.RawUI.WindowTitle = 'MariaDB Stopped'
    }
"`@ ``
    -WindowStyle Minimized
exit
"@
        $content | Out-File -FilePath $MARIADB_STARTER_PS1_PATH -Force
        Write-Host "${MARIADB_STARTER_PS1_PATH} successfully created."
    } else {
        Write-Host "File already exists: ${MARIADB_STARTER_PS1_PATH}"
    }

	# Create starter batch
	create-starter-ps1-exec-backend -PSFileName $MARIADB_STARTER_PS1_NAME `
		-PSExecRelPath "..\..\$POWERSHELL_EXEC_PATH" `
		-StarterExecName $MARIADB_STARTER_EXEC_NAME `
		-StarterExecRelPath $MARIADB_STARTER_EXEC_PATH
	
	Write-Host "MariaDB installed successfully."
}

function setup_mariadb-backend ($name, $database, $user, $password) {
	
	$DATABASE_NAME = ""
	$DATABASE_USERNAME = ""
	$DATABASE_PASSWORD = ""
	
	$global:DATABASE_NAME = $null
	$global:DATABASE_USERNAME = $null
	$global:DATABASE_PASSWORD = $null
	
    $DATABASE_NAME = Read-Host "Enter Signum ${name} database name (or press Enter for default ${database})"
    if (-not $DATABASE_NAME) { $DATABASE_NAME = $database }
    Write-Host "Database name: ${DATABASE_NAME}"

    $DATABASE_USERNAME = Read-Host "Enter the username (or press Enter for default ${user})"
    if (-not $DATABASE_USERNAME) { $DATABASE_USERNAME = $user }
    Write-Host "Username: ${DATABASE_USERNAME}"

    $DATABASE_PASSWORD = Read-Host "Enter the password (or press Enter for default ${password})"
    if (-not $DATABASE_PASSWORD) { $DATABASE_PASSWORD = $password }
    Write-Host "Password: ${DATABASE_PASSWORD}"

    Write-Host "Starting MariaDB server ..."
	# Last OK
    # Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Hidden
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	
	.\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\Database\MariaDB\mariadb-10.6.20-winx64\start-mariadb.ps1" "-WindowStyle Minimized"

    Start-Sleep -Seconds $SLEEP_SECONDS

    Write-Host "Creating database: ${DATABASE_NAME}"
	$createDatabaseQuery = "CREATE DATABASE IF NOT EXISTS ``${DATABASE_NAME}``;"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createDatabaseQuery

    Write-Host "Creating user: ${DATABASE_USERNAME}"
	$createUserQuery = "CREATE USER IF NOT EXISTS '${DATABASE_USERNAME}'@'localhost' IDENTIFIED BY '${DATABASE_PASSWORD}';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createUserQuery

    Write-Host "Granting permissions to user ${DATABASE_USERNAME} on database ${DATABASE_NAME} ..."
	$grantPermissionsQuery = "GRANT ALL PRIVILEGES ON ``${DATABASE_NAME}``.* TO '${DATABASE_USERNAME}'@'localhost';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $grantPermissionsQuery
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e "FLUSH PRIVILEGES;"

	$global:DATABASE_NAME = $DATABASE_NAME
	$global:DATABASE_USERNAME = $DATABASE_USERNAME
	$global:DATABASE_PASSWORD = $DATABASE_PASSWORD

    Write-Host "MariaDB setup complete."
}

function setup_mariadb_readonly-backend ($name, $database, $user, $password) {
	
	$DATABASE_NAME = ""
	$DATABASE_USERNAME = ""
	$DATABASE_PASSWORD = ""
	
	$global:DATABASE_NAME = $null
	$global:DATABASE_USERNAME = $null
	$global:DATABASE_PASSWORD = $null
	
	$DATABASE_NAME = $database
    Write-Host "Database name: ${DATABASE_NAME}"

    $DATABASE_USERNAME = Read-Host "Enter the username (or press Enter for default ${user})"
    if (-not $DATABASE_USERNAME) { $DATABASE_USERNAME = $user }
    Write-Host "Username: ${DATABASE_USERNAME}"

    $DATABASE_PASSWORD = Read-Host "Enter the password (or press Enter for default ${password})"
    if (-not $DATABASE_PASSWORD) { $DATABASE_PASSWORD = $password }
    Write-Host "Password: ${DATABASE_PASSWORD}"

    Write-Host "Starting MariaDB server ..."
	# Last OK
    # Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Hidden
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	
	.\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\Database\MariaDB\mariadb-10.6.20-winx64\start-mariadb.ps1" "-WindowStyle Minimized"

    Start-Sleep -Seconds $SLEEP_SECONDS

    Write-Host "Creating user: ${DATABASE_USERNAME}"
	$createUserQuery = "CREATE USER IF NOT EXISTS '${DATABASE_USERNAME}'@'localhost' IDENTIFIED BY '${DATABASE_PASSWORD}';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createUserQuery

    Write-Host "Granting permissions to user ${DATABASE_USERNAME} on database ${DATABASE_NAME} ..."
	$grantPermissionsQuery = "GRANT SELECT, SHOW VIEW ON ``${DATABASE_NAME}``.* TO '${DATABASE_USERNAME}'@'localhost';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $grantPermissionsQuery

<#
	# Indexing
	# SQL commands to execute
	$sqlCommands = 
@"
USE ``${DATABASE_NAME}``;
CREATE INDEX transaction_height_timestamp ON transaction(height, timestamp);
CREATE INDEX asset_height ON asset(height);
CREATE INDEX account_latest ON account(latest);
"@
	
	# Execute each SQL command
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $sqlCommands
#>	
	
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e "FLUSH PRIVILEGES;"

	$global:DATABASE_NAME = $DATABASE_NAME
	$global:DATABASE_USERNAME = $DATABASE_USERNAME
	$global:DATABASE_PASSWORD = $DATABASE_PASSWORD

    Write-Host "MariaDB setup complete."
}


# TODO important fentch mariadb version data once and after refresh page
function Start-PowerShellWebServer_1 {
    # param ([int]$Port = 8080)

	# Load GUI contets
	$mariadb_htmlContent = install_mariadb-frontend

    $listener = New-Object System.Net.HttpListener
    $listener.Prefixes.Add("http://+:$WEB_GUI_PORT/")
    $listener.Start()
    Write-Host "🚀 Web server started on http://localhost:$WEB_GUI_PORT"

	# Start browser
	Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH"  -ArgumentList "--user-data-dir=.\$BROWSER_CHROMIUM_PROFILE_DIR_NAME", "http://localhost:$WEB_GUI_PORT"

    while ($listener.IsListening) {
        $context = $listener.GetContext()
        $request = $context.Request
        $response = $context.Response
        $urlPath = $request.Url.AbsolutePath

		# TODO check installed versions at starting and every 60 sec or after nyew installation and list it to a new raw

		switch ($request.HttpMethod) {
			"GET" {
				if ($urlPath -eq "/database/mariadb/release/versions") {
					# Fetch MariaDB versions dynamically
					$mariadbVersions = Fetch-MariaDBVersions
					$jsonResponse = ConvertTo-Json -InputObject $mariadbVersions
					$buffer = [System.Text.Encoding]::UTF8.GetBytes($jsonResponse)
					$response.ContentType = "application/json"
					# Send response
					$response.ContentLength64 = $buffer.Length
					<#
					$output = $response.OutputStream
					$output.Write($buffer, 0, $buffer.Length)
					$output.Close()
					#>
				} else {

					# Initial HTML page with JavaScript to load data
					$html = 
@"
<html>
<head>
	<title>MariaDB Installer</title>
</head>
<body>
$mariadb_htmlContent
</body>
</html>
"@
		
					$buffer = [System.Text.Encoding]::UTF8.GetBytes($html)
					$response.ContentType = "text/html"
			
					# Send response
					$response.ContentLength64 = $buffer.Length
				}
			}
			"POST" {
				if ($urlPath -eq "/database/mariadb/install") {
					$reader = New-Object IO.StreamReader $request.InputStream
					$body = $reader.ReadToEnd()
					$reader.Close()
		
					$data = $body | ConvertFrom-Json

					$version = $data.version
					$port = $data.port

					Write-Host("MariaDB Install started") -ForegroundColor Blue
					Write-Host("MariaDB version selected: $version") -ForegroundColor Blue
					Write-Host("MariaDB port selected: $port") -ForegroundColor Blue

					updateMariadbVariables -version $version -port $port
		
					install_mariadb-backend
		
					$responseStr = "MariaDB install initiated for version $($data.version), port $($data.port)"

					$response.ContentType = "application/json"
					$response.ContentEncoding = [System.Text.Encoding]::UTF8
					$response.ContentLength64 = ([System.Text.Encoding]::UTF8.GetByteCount($responseStr))
					$buffer = [System.Text.Encoding]::UTF8.GetBytes($responseStr)
					<#
					$output = $response.OutputStream
					$output.Write($buffer, 0, $buffer.Length)
					$output.Close()
					#>
				}
			}
		}
<#
		# Initial HTML page with JavaScript to load data
		$html = 
@"
<html>
<head>
	<title>MariaDB Installer</title>
</head>
<body>
$mariadb_htmlContent
</body>
</html>
"@

		$buffer = [System.Text.Encoding]::UTF8.GetBytes($html)
		$response.ContentType = "text/html"

		# Send response
		$response.ContentLength64 = $buffer.Length
#>
		$output = $response.OutputStream
		$output.Write($buffer, 0, $buffer.Length)
		$output.Close()

    }

    $listener.Stop()
}

# Function to Fetch MariaDB Versions from API
function Fetch-MariaDBVersions {
    try {
        $apiUrl = "https://downloads.mariadb.org/rest-api/mariadb/10.6/"

		$headers = @{
            "Accept" = "application/json"
            "User-Agent" = "PowerShell"
        }

		# $response = Invoke-WebRequest -Uri "https://downloads.mariadb.org/rest-api/mariadb/10.6/" -Headers @{ "User-Agent" = "PowerShell" }

		$response = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method Get

        $versions = $response.releases.PSObject.Properties.Name

        Write-Host "MariaDB fetched versions: $($versions -join ', ')"

        # Sort and take the latest 10 versions
        return $versions
    }
    catch {
        Write-Host "⚠️ Error fetching MariaDB versions from API: $_"
        return @("10.6.21", "10.6.20", "10.6.19", "10.6.18", "10.6.17", "10.6.16", "10.6.15", "10.6.14", "10.6.13", "10.6.12")
    }
}

# Start the Web Server
# Start-PowerShellWebServer -Port 8080



function setup_mariadb_explorer-backend ($name, $database, $user, $password) {
	
	$DATABASE_NAME = ""
	$DATABASE_USERNAME = ""
	$DATABASE_PASSWORD = ""
	
	$global:DATABASE_NAME = $null
	$global:DATABASE_USERNAME = $null
	$global:DATABASE_PASSWORD = $null
	
    $DATABASE_NAME = Read-Host "Enter Signum ${name} database name (or press Enter for default ${database})"
    if (-not $DATABASE_NAME) { $DATABASE_NAME = $database }
    Write-Host "Database name: ${DATABASE_NAME}"

    $DATABASE_USERNAME = Read-Host "Enter the username (or press Enter for default ${user})"
    if (-not $DATABASE_USERNAME) { $DATABASE_USERNAME = $user }
    Write-Host "Username: ${DATABASE_USERNAME}"

    $DATABASE_PASSWORD = Read-Host "Enter the password (or press Enter for default ${password})"
    if (-not $DATABASE_PASSWORD) { $DATABASE_PASSWORD = $password }
    Write-Host "Password: ${DATABASE_PASSWORD}"

    Write-Host "Starting MariaDB server ..."
	# Last OK
    # Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults" -WindowStyle Minimized
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Hidden
	# Start-Process -FilePath "${MARIADB_BIN_PATH}\${MARIADBD_EXEC_NAME}" -ArgumentList "--no-defaults", "--console --port=$MARIADB_PORT" -WindowStyle Minimized
	
	.\$POWERSHELL_EXEC_PATH -ExecutionPolicy Bypass -File ".\Database\MariaDB\mariadb-10.6.20-winx64\start-mariadb.ps1" "-WindowStyle Minimized"

    Start-Sleep -Seconds $SLEEP_SECONDS

    Write-Host "Creating database: ${DATABASE_NAME}"
	$createDatabaseQuery = "CREATE DATABASE IF NOT EXISTS ``${DATABASE_NAME}``;"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createDatabaseQuery

    Write-Host "Creating user: ${DATABASE_USERNAME}"
	$createUserQuery = "CREATE USER IF NOT EXISTS '${DATABASE_USERNAME}'@'localhost' IDENTIFIED BY '${DATABASE_PASSWORD}';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $createUserQuery

    Write-Host "Granting permissions to user ${DATABASE_USERNAME} on database ${DATABASE_NAME} ..."
	$grantPermissionsQuery = "GRANT ALL PRIVILEGES ON ``${DATABASE_NAME}``.* TO '${DATABASE_USERNAME}'@'localhost';"
    & "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $grantPermissionsQuery

	# Define the SQL queries
	$sqlQueryGetUser = "SELECT '$DATABASE_USERNAME' FROM mysql.user;"

	$sqlQueryCreateTable = 
@"
USE $DATABASE_NAME;

CREATE TABLE scan_peermonitor (
	announced_address VARCHAR(255) PRIMARY KEY,
	real_ip VARCHAR(255),
	platform VARCHAR(255),
	application VARCHAR(255),
	version VARCHAR(255),
	height INTEGER,
	cumulative_difficulty VARCHAR(255),
	country_code CHAR(2),
	state SMALLINT,
	downtime INTEGER DEFAULT 0,
	lifetime INTEGER DEFAULT 0,
	availability FLOAT DEFAULT 0,
	last_online_at TIMESTAMP,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	reward_state VARCHAR(255) DEFAULT 'none',
	reward_time TIMESTAMP
);
"@

	# Run the queries
	Write-Host "Executing query to retrieve user details..."
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $sqlQueryGetUser

	Write-Host "Creating table in the Signum ${name} database..."
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e $sqlQueryCreateTable
	& "${MARIADB_BIN_PATH}\${MARIADB_EXEC_NAME}" --user=root --password= -e "FLUSH PRIVILEGES;"
	
	$global:DATABASE_NAME = $DATABASE_NAME
	$global:DATABASE_USERNAME = $DATABASE_USERNAME
	$global:DATABASE_PASSWORD = $DATABASE_PASSWORD

    Write-Host "MariaDB setup complete."
}

# Function to define the web server function
function Start-PowerShellWebServer {

    # Create an HTTP listener
    $listener = New-Object System.Net.HttpListener
    $listener.Prefixes.Add("http://+:$WEB_GUI_PORT/")
    $listener.Prefixes.Add("http://+:$WEB_GUI_PORT/start-menu/")  # Ensure trailing /

    $listener.Start()
    Write-Host "🚀 Web server started on http://localhost:$WEB_GUI_PORT"

	# Start browser
	Start-Process -FilePath ".\$BROWSER_CHROMIUM_EXEC_PATH"  -ArgumentList "--user-data-dir=.\$BROWSER_CHROMIUM_PROFILE_DIR_NAME", "http://localhost:$WEB_GUI_PORT"
	
	# Serve the installation form
	$html = 
@"
<html>
<head><title>MariaDB Installer</title></head>
<body>
	# TODO adding frontend functions and checks here calling functions calculate neccessary values
	<h2>MariaDB Installation</h2>
	<form method='POST'>
		<label>Version:</label>
		<select name='version'>
			<option value='10.6.10'>10.6.10</option>
			<option value='10.5.8'>10.5.8</option>
		</select>
		<br>
		<label>Port:</label>
		<input type='text' name='port' value='3306'/>
		<br>
		<label>Database Name:</label>
		<input type='text' name='dbname'/>
		<br>
		<button type='submit'>Install MariaDB</button>
	</form>
</body>
</html>
"@

    while ($listener.IsListening) {
        try {
            # Wait for a request
            $context = $listener.GetContext()
            $request = $context.Request
            $response = $context.Response

			# Check if data was submitted
			if ($request.HttpMethod -eq "POST") {
				$reader = New-Object System.IO.StreamReader($request.InputStream, $request.ContentEncoding)
				$postData = $reader.ReadToEnd()
				$reader.Close()
	
				# Process installation request
				Install-MariaDB $postData
			}



            if ($request.Url.AbsolutePath -eq "/start-menu/" -and $request.HttpMethod -eq "POST") {
                # Run Show-StartMenu in the background (asynchronously)
                # Start-Job -ScriptBlock { Show-StartMenu }
				# Show-StartMenu
                Write-Host "🟢 Button clicked, Show-StartMenu is running in background..."

				# TODO run with portable PowerShell
				# Run Show-StartMenu in a new terminal window
				Start-Process -FilePath $POWERSHELL_EXEC_PATH -ArgumentList "-NoExit -NoProfile -ExecutionPolicy Bypass -Command `"Show-StartMenu`""
				# -Verb RunAs
                # Start-Process -NoNewWindow -FilePath "powershell.exe" -ArgumentList "-NoProfile -ExecutionPolicy Bypass -Command `"Show-StartMenu`""
                Write-Host "🟢 Button clicked, Show-StartMenu is running in a new terminal..."


                $responseString = "<html><body><h1>Show-StartMenu executed in the background!</h1><a href='/'>Go Back</a></body></html>"
            }
            else {
                # Serve main page with a button
                $responseString = @"
<html>
<body>
    <h1>PowerShell Web Server</h1>
    <button onclick="fetch('/start-menu/', { method: 'POST' }).then(() => alert('Show-StartMenu executed!'));">
        Start Menu
    </button>
</body>
</html>
"@
            }

            # Send response
            # $buffer = [System.Text.Encoding]::UTF8.GetBytes($responseString)
			$buffer = [System.Text.Encoding]::UTF8.GetBytes($html)
            $response.ContentLength64 = $buffer.Length
            $output = $response.OutputStream
            $output.Write($buffer, 0, $buffer.Length)
            $output.Close()
        }
        catch {
            Write-Host "❌ Error: $_"
        }
    }

    # Stop the listener
    $listener.Stop()
}



# Function to Open WEB GUI
function Get-WebPage {
    $databaseRows = $config.databases | ForEach-Object { "<tr><td>$_</td><td><button onclick=`"deleteDatabase('$_')`">Delete</button></td></tr>" }

    $userRows = $config.users.Keys | ForEach-Object {
        $assignedDBs = $config.users[$_]["databases"].Keys -join ", "
        "<tr><td>$_</td><td>$assignedDBs</td><td><button onclick=`"deleteUser('$_')`">Remove</button></td></tr>"
    }

    $page = html {
        head {
            title { "MariaDB Manager" }
            style { "body { font-family: Arial, sans-serif; padding: 20px; } button { background: #28a745; color: white; }" }
            script {
@"
function addDatabase() {
	let dbName = document.getElementById('newDatabase').value;
	fetch('/api?action=addDatabase&dbName=' + encodeURIComponent(dbName))
	.then(response => response.json())
	.then(data => { alert(data.message); if (data.status === 'success') location.reload(); });
}

function addUser() {
	let username = document.getElementById('newUsername').value;
	let password = document.getElementById('newPassword').value;
	fetch('/api?action=addUser&username=' + encodeURIComponent(username) + '&password=' + encodeURIComponent(password))
	.then(response => response.json())
	.then(data => { alert(data.message); if (data.status === 'success') location.reload(); });
}

function assignUser() {
	let username = document.getElementById('assignUsername').value;
	let dbName = document.getElementById('assignDatabase').value;
	let permission = document.getElementById('assignPermission').value;
	fetch('/api?action=assignUser&username=' + encodeURIComponent(username) + '&dbName=' + encodeURIComponent(dbName) + '&permission=' + encodeURIComponent(permission))
	.then(response => response.json())
	.then(data => { alert(data.message); if (data.status === 'success') location.reload(); });
}

function deleteUser(username) {
	fetch('/api?action=deleteUser&username=' + encodeURIComponent(username))
	.then(response => response.json())
	.then(data => { alert(data.message); if (data.status === 'success') location.reload(); });
}
"@
            }
        }
        body {
            h1 { "MariaDB Server Management" }

            input -type 'text' -id 'newDatabase' -placeholder 'Enter database name'
            button -type 'button' -onclick "addDatabase()" { "Add New Database" }
            hr
            table -id 'databaseTable' {
                tr { th { "Database Name" } th { "Action" } }
                $databaseRows
            }

            hr
            h2 { "User Management" }
            input -type 'text' -id 'newUsername' -placeholder 'Username'
            input -type 'password' -id 'newPassword' -placeholder 'Password'
            button -type 'button' -onclick "addUser()" { "Add User" }

            hr
            table -id 'userTable' {
                tr { th { "User" } th { "Assigned Databases" } th { "Action" } }
                $userRows
            }

            hr
            select -id 'assignUsername' { $config.users.Keys | ForEach-Object { option { $_ } } }
            select -id 'assignDatabase' { $config.databases | ForEach-Object { option { $_ } } }
            select -id 'assignPermission' { option { "ALL" } option { "SELECT" } }
            button -type 'button' -onclick "assignUser()" { "Assign User" }
        }
    }
    return $page
}


# Ensure PSHTML and Pode are installed in the portable path
# Ensure-PortableModule -ModuleName "PSHTML"
# Ensure-PortableModule -ModuleName "Pode"


#================#
# Function calls #
#================#

# Check if running as Admin/root
if (-not (Test-IsAdmin)) {
    Write-Host "❌ Not running as Administrator/root. Elevating now..." -ForegroundColor Red
    Restart-AsAdmin
} else {
    Write-Host "✅ Running with elevated privileges!" -ForegroundColor Green
}

# Download documentations
install-doc-init-backend

# TODO
# Dev steps
# 1 MAriadb install - frontend + backend
# 2 Write datas into JOSN file
# 3 function to check json consistenci regardong folders -> syncronization
# 4 database and user syncronization with json -> need to log in to database
# 5 Manual update root user if changed
# 6 Fetching MariaDB versions
# 7 Possibilities to install more instances
# 8 Read out mariadb ini file for port

# TODO open new tab instead of open new window
# TODO check installation and only install if needed
# TODO extensin manual install is not working on browser
# TODO letöltési hiba: nem sikerült a bővítmény könyvtárat áthelyezni a profilba
# TODO rename functions to backand and frontend
# TODO create .json file to populate input forms add checkbox + update buton to update json file if user make the changes outside the installer
# TODO request datas if user want to syncronise -> need database user + password, update if not correct
# Install portable browser 
install_chromium_browser_backend
# TODO Install Chromium browser if not yet installed
# start-process-menu-backend $BROWSER_CHROMIUM_STARTER_PS1_PATH "Chromium Browser" {install_chromium_browser}

# Modul installation check
# Ensure-PortableModule -ModuleName "PSHTML"
# Ensure-PortableModule -ModuleName "ThreadJob"

# Start-WebServer -Port 8080 -Content { "Hello, PowerShell!" }

# Start the web server in the background
<#
Start-Job -ScriptBlock {
    Import-Module WebServer
    Start-WebServer -Port 8089 -Content { "Hello, PowerShell!" }
	# Start-WebServer
}
#>

<#
Start-Job -ScriptBlock {
    #Import-Module WebServer
    Start-PowerShellWebServer -Port 8080
	# Start-WebServer
}
#>

# Start the web server
# Start-PowerShellWebServer -Port $WEB_GUI_PORT

# TODO replace port check within PS1 starters with cross platform compatible Test-PortAvailability method, or make different chack based on platform
# Check if the port is already in use
if (Test-PortAvailability -Port $WEB_GUI_PORT) {
    Write-Host "✅ Port $WEB_GUI_PORT is available. Starting server..." -ForegroundColor Green
    try {
		<#
		$job = Start-ThreadJob -Name "PowerShellWebServerJob" -ScriptBlock {
			param ($Port)
			Start-PowerShellWebServer -Port $Port
		} -ArgumentList 8080
		#>
		# TODO open in portable browser within new tab if browser is open
        # Start-PowerShellWebServer -Port $WEB_GUI_PORT
		# Start-PowerShellWebServer_1 -Port $WEB_GUI_PORT
		Start-PowerShellWebServer_1
    } catch {
        Write-Host "❌ Error starting server: $_" -ForegroundColor Red
		Pause
        exit 1
    }
} else {
	# TODO open WEB GUI within portable browser
    Write-Host "⚠️ Port $WEB_GUI_PORT is already in use. Server might be running." -ForegroundColor Yellow
}




# Start-PSHTMLServer -port $WEB_GUI_PORT -Content { param ($request) Handle-Request @($request.Query) }
Write-Host "Server started at http://localhost:$WEB_GUI_PORT"

Pause

# TODO Mariadb port user and password check (maybe from init config) to use for database query for list
# Store root/admin user/password and databases on json to request databases pipe to use default root account or use custom one
# Add/remove database
# Add/remove user
# TODO wireshark portable

# GUI functions
# Install Chromium browser

# Start web-GUI

# Show-InstallMenu-GUI
